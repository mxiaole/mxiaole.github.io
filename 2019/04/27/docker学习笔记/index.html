<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="0. 安装dockerubuntu环境下安装：sudo apt install docker-iocentos上安装：https:&#x2F;&#x2F;docs.docker.com&#x2F;install&#x2F;linux&#x2F;docker-ce&#x2F;centos&#x2F; 参考官方文档完成安装即可 将用户添加到docker用户组：gpasswd -M mxiaole docker  将mxiaole用户添加到docker组  vagrant">
<meta property="og:type" content="article">
<meta property="og:title" content="docker学习笔记">
<meta property="og:url" content="http://yoursite.com/2019/04/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="人生识字忧患始，不待扬鞭自奋蹄">
<meta property="og:description" content="0. 安装dockerubuntu环境下安装：sudo apt install docker-iocentos上安装：https:&#x2F;&#x2F;docs.docker.com&#x2F;install&#x2F;linux&#x2F;docker-ce&#x2F;centos&#x2F; 参考官方文档完成安装即可 将用户添加到docker用户组：gpasswd -M mxiaole docker  将mxiaole用户添加到docker组  vagrant">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2019/04/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg">
<meta property="og:image" content="http://yoursite.com/2019/04/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker%E7%BD%91%E7%BB%9C.png">
<meta property="article:published_time" content="2019-04-27T06:31:37.000Z">
<meta property="article:modified_time" content="2020-02-18T05:36:53.100Z">
<meta property="article:author" content="Cody">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/04/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg">

<link rel="canonical" href="http://yoursite.com/2019/04/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>docker学习笔记 | 人生识字忧患始，不待扬鞭自奋蹄</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">人生识字忧患始，不待扬鞭自奋蹄</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cody">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人生识字忧患始，不待扬鞭自奋蹄">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          docker学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-27 14:31:37" itemprop="dateCreated datePublished" datetime="2019-04-27T14:31:37+08:00">2019-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-18 13:36:53" itemprop="dateModified" datetime="2020-02-18T13:36:53+08:00">2020-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0-安装docker"><a href="#0-安装docker" class="headerlink" title="0. 安装docker"></a>0. 安装docker</h1><p>ubuntu环境下安装：<code>sudo apt install docker-io</code><br>centos上安装：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a> 参考官方文档完成安装即可</p>
<p><strong>将用户添加到docker用户组：<code>gpasswd -M mxiaole docker  将mxiaole用户添加到docker组</code></strong></p>
<blockquote>
<p>vagrant + virtualbox使用：借助该工具可以直接在virtualbox中创建虚拟机</p>
<ul>
<li>首先安装virtualbox和vagrant：下载地址<a href="https://www.vagrantup.com/downloads.html和https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.vagrantup.com/downloads.html和https://www.virtualbox.org/wiki/Downloads</a></li>
<li>使用vagrant快速的创建Linux虚拟机：<ul>
<li>创建一个目录centos，然后cd到该目录，执行<code>vagrant init centos/7</code>命令，会生成一个Vagrantfile文件</li>
<li>然后运行<code>vagrant up</code>命令，之后就会创建好了一个虚拟机</li>
<li>连接到生成的虚拟机：<code>vagrant ssh</code></li>
</ul>
</li>
<li>vagrant的其他命令：vagrant status、vagrant halt、vagrant destroy</li>
</ul>
</blockquote>
<h1 id="1-docker-machine使用"><a href="#1-docker-machine使用" class="headerlink" title="1. docker-machine使用"></a>1. docker-machine使用</h1><p>这个工具可以用来创建远端的docker server，但是要有相关的驱动，然后在本地使用docker-machine命令就可以在virtual-box, vm-ware, aws，aliyun上使用相应的驱动创建安装了docker的虚拟机。</p>
<p>使用virtualbox驱动直接创建一个安装了docker的虚拟机：<code>docker-machine create 虚拟机的名字</code><br>直接进入创建好的虚拟机：<code>docker-machine ssh 虚拟机的名字</code><br>docker-machine 的其他命令，使用docker-manchine –help 查看</p>
<blockquote>
<p>tips<br>可以使用mac上的client 连接docker-machine创建的安装了docker的虚拟机，在终端执行如下的两条命令：<br><code>docker-machine env 虚拟机的名字</code>  ,  <code>eval ($docker-machine env 虚拟机的名字)</code><br>撤销使用的命令： <code>docker-machine env --unset</code>, <code>eval $(docker-machine env --unset)</code></p>
</blockquote>
<p>dockerplayground可以随意的玩</p>
<h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" alt="docker架构图"></p>
<p>共享宿主机的kernel</p>
<h2 id="docker使用的底层技术主要有："><a href="#docker使用的底层技术主要有：" class="headerlink" title="docker使用的底层技术主要有："></a>docker使用的底层技术主要有：</h2><ul>
<li>namespace实现隔离. <a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">详细了解参考</a></li>
<li>cgroup实现资源限制</li>
<li>union file systems实现container和image分层</li>
</ul>
<p>这些技术都是Linux上自带的。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><strong>镜像image</strong>: 在docker中，所有的应用程序都被制作成了镜像</li>
<li><strong>容器container</strong>: 每一个基于镜像的应用程序都必须在容器中才能执行</li>
<li><strong>宿主机</strong>: 运行docker这个应用程序的机器称为宿主机</li>
</ul>
<p>镜像的分层概念。</p>
<h1 id="3-image"><a href="#3-image" class="headerlink" title="3. image"></a>3. image</h1><h2 id="3-1-是什么"><a href="#3-1-是什么" class="headerlink" title="3.1 是什么"></a>3.1 是什么</h2><ul>
<li>是文件和meta data的集合。</li>
<li>分层，每一层都可以添加删除改变文件，称为一个新的image</li>
<li>不同的image可以共享相同的layer</li>
<li>image本身是只读的</li>
</ul>
<h2 id="3-2-怎么操作"><a href="#3-2-怎么操作" class="headerlink" title="3.2 怎么操作"></a>3.2 怎么操作</h2><p><strong>1. 获取image</strong></p>
<p>有三种获取image的方法：</p>
<ul>
<li>自己创建dockerfile文件，进行构建image: docker build -t imagename:tag .</li>
<li>基于container创建一个image: docker container commit (不推荐使用)</li>
<li>直接从镜像仓库中获取: docker pull imagename</li>
</ul>
<p><strong>2. 发布image</strong></p>
<p><strong>发布到dockerhub</strong></p>
<ul>
<li><p>创建一个docker hub账号，被push的image的name必须是<code>dockerhubID/imagename[:tag]</code></p>
</li>
<li><p>在发布之前必须先登录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker image push mxiaole/hello-world:latest</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>推荐的做法是将dockerhub和github进行关联，在github上发布dockerfile，然后dockerhub会自动的根据dockerfile创建image</p>
<p><strong>发布到私有的dockerhub</strong></p>
<ul>
<li>使用docker创建一个私有的dockerhub: <code>docker run -d -p 5000:5000 --restart always --name registry registry:2</code></li>
<li>向本地私有仓库提交image的时候，镜像的名字必须是<code>10.10.10.2:8888/hello</code>, registry的IP:端口，开头</li>
<li>然后，使用命令<code>dockr push 10.10.2:888/hello</code>向本地仓库push镜像，但是这个时候可能会出错，<ul>
<li>在/etc/docker/目录下创建一个文件:daemon.json，添加内容<code>{&quot;insecure-registries&quot;: [&quot;10.0.2.15:500&quot;]}</code></li>
<li>同时在/lib/systemd/system/docker.service文件中添加一行: <code>EnvironmenFile=-/etc/docker/daemon.json</code></li>
<li>最后重启docker：<code>sudo service docker restart</code></li>
</ul>
</li>
<li>验证镜像是否成功的push： <code>curl localhost:5000/v2/_catlog</code> 查看</li>
</ul>
<h1 id="4-创建image"><a href="#4-创建image" class="headerlink" title="4. 创建image"></a>4. 创建image</h1><h2 id="4-1-基于container创建image"><a href="#4-1-基于container创建image" class="headerlink" title="4.1 基于container创建image"></a>4.1 基于container创建image</h2><p><code>docker commit containername newimage</code> 使用上述的命令能够基于已经存在的container创建一个新的image</p>
<h2 id="4-2-使用Dockerfile创建image"><a href="#4-2-使用Dockerfile创建image" class="headerlink" title="4.2 使用Dockerfile创建image"></a>4.2 使用Dockerfile创建image</h2><p>Dockerfile常用的命令：</p>
<ul>
<li><p>FROM: 指定创建image的base image是什么 ; 尽量使用官方的image作为baseimage</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br></pre></td></tr></table></figure></li>
<li><p>LABEL: </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"mxiaole"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">"this is description"</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>RUN:  创建镜像时执行的命令，每运行一次该命令，就会生成新的一层; 将多条命令放在一行，如果需要换行使用\</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install vim &amp;&amp; yum install git &amp;&amp; yum install gcc</span></span><br></pre></td></tr></table></figure>
<p><strong>命令有两种格式，cmd和entrypoint命令也是如此</strong></p>
<ul>
<li>shell格式<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt install -y vim</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span></span></span><br></pre></td></tr></table></figure></li>
<li>exec格式<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"apt"</span>, <span class="string">"install"</span>, <span class="string">"-y"</span>, <span class="string">"vim"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"hello world"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"hello world"</span>]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CMD: 设置容器启动之后默认执行的命令和参数, 如果在docker run的时候执行了其他的命令，那么cmd命令会被忽略；如果定义了多个cmd命令，只有最后一个会被执行。</p>
</li>
<li><p>ENTRYPOINT: 设置容器启动时执行的命令；让容器以应用程序或者服务的形式运行；该命令不会被忽略,docker run 指定的启动命令作为参数传递给它设置的命令；最好是写一个shell脚本作为entrypoint</p>
</li>
<li><p>WORKDIR: 用来设定当前的工作目录; 尽量是用绝对路径，不要使用相对路径</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span>  <span class="comment"># 输出结果应该是/root/demo</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>ADD &amp;&amp; COPY: 这两个命令都是将本地的文件，添加到docker image中<br><strong>两者的区别</strong>:</p>
<ul>
<li>ADD命令还可以进行解压: ADD xxx.tar.gz /</li>
<li>大部分的情况优先使用COPY</li>
</ul>
</li>
<li><p>ENV: 用来设定环境变量</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MYSQL_VERSION <span class="number">5.7</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install mysql=<span class="variable">$&#123;MYSQL_VERSION&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>VOLUME: 指定当前容器中要备份的文件路径，会将docker container中该路径下的文件挂载到宿主机上的某个位置。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /var/lib/mysql</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-3-demo"><a href="#4-3-demo" class="headerlink" title="4.3 demo"></a>4.3 demo</h2><p><strong>demo1: 创建一个Python的flask应用</strong></p>
<ul>
<li>创建dockerfile<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"mxiale"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install flask</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> main.py /app/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"main.py"</span>]</span></span><br></pre></td></tr></table></figure></li>
<li>build镜像文件 : <code>docker build -t mxiaole/flask-demo .</code></li>
<li>运行创建的镜像：<code>docker run -d mxiaole/flask-demo</code></li>
</ul>
<p><strong>使用dockerfile创建image时的debug</strong><br>因为在build的时候，每一层都会生成一个镜像，可以通过运行这些中间生成的镜像来进行debug</p>
<p><strong>demo2: 创建一个命令行工具</strong></p>
<ul>
<li>创建dockerfile<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update &amp;&amp; apt install stress</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/bin/stress/"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> []</span></span><br></pre></td></tr></table></figure></li>
<li>创建镜像：<code>docker build -t mxiaole/ubuntu-stress .</code></li>
<li>使用: <code>docker run -it mxiaole/ubuntu-stress --help</code> 可以直接指定stress的命令参数</li>
</ul>
<h1 id="5-container操作"><a href="#5-container操作" class="headerlink" title="5. container操作"></a>5. container操作</h1><h2 id="5-1-启动容器"><a href="#5-1-启动容器" class="headerlink" title="5.1 启动容器"></a>5.1 启动容器</h2><p>最简单的启动方式就是：<code>docker run image</code>。容器的生命周期：运行时，运行结束后退出。</p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul>
<li>exec命令: <code>docker exec -it conainerid /bin/bash</code> 进入一个运行的容器</li>
<li>inspect: <code>docker inspect conainerid</code> 检测一个container的信息</li>
<li>logs: <code>docker logs containerid</code> 查看container的输出日志</li>
</ul>
<blockquote>
<p>tips: 快速清除多个container<br>docker container ls -aq  # 查看容器的ID<br>docker rm $(docker container ls -aq)  # 可以实现快速的删除多个container<br>docker container ls -f “status=exited” -q  # 查看所有的已经退出的container<br>docker rm $(docker container ls -f “status=exited” -q)  # 快速的清除所有已经退出的container</p>
</blockquote>
<h1 id="6-网络管理"><a href="#6-网络管理" class="headerlink" title="6. 网络管理"></a>6. 网络管理</h1><p><img src="docker%E7%BD%91%E7%BB%9C.png" alt="docker网络"></p>
<p>Docker使用Linux桥接，在宿主机上虚拟一个Docker网桥。Docker在启动一个容器时会根据Docker网桥的网段分配容器的IP，同时Docker网桥是每个容器的默认网关。</p>
<p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络无法寻址到，如果希望容器能够被外部网络访问到，就需要通过映射容器端口到宿主机的端口</p>
<h1 id="7-数据持久化"><a href="#7-数据持久化" class="headerlink" title="7. 数据持久化"></a>7. 数据持久化</h1><p>Docker中的数据持久化：使用Docker数据卷将宿主机上的文件或者目录挂载到容器中。</p>
<p><strong>如果使用容器，启动一个myql，当这个container销毁后，如果MySQL中的数据保存在container中，那么MySQL中的数据也会消失；这时候应该怎么处理呢？</strong></p>
<p>将宿主机上的目录或者文件挂载到容器中，即使容器销毁，数据卷中的数据仍然保留在宿主机上，下次启动的时候可以使用。</p>
<p>共有两种 Volume 类型。每种 Volume 都是宿主机上的的一个目录对应到container内的一个目录，其不同只在于主机上的位置。</p>
<p>第 1 种叫绑定挂载的 Volume (bind mount volume)：用户<strong>指定将主机上的某个目录</strong>挂载到<strong>容器中的某个目录</strong>。(-v参数指定，宿主机的目录：container的目录， 这两个目录是一一对应的)， 在运行container的时候，直接使用-v参数指定。</p>
<p>第 2 种叫受管理的 Volume (managed volume)：所使用的主机上的位置是由 Docker daemon 创建并管理的，这些位置称为 Docker managed space, 在dockerfile文件中使用VOLUME指令指定volume的路径，然后使用-v参数给这个volume起个名字, 这个volume对应的宿主机的位置不是用户指定的，是docker运行时自动指定的。</p>
<p>例如：创建一个MySQL container: <code>docker run -d --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql</code>, 这时候查看一下<code>docker volume ls</code>会看到生成了一个volume，使用<code>docker volume inspect volumenameid</code>命令可以查看详情</p>
<p>上面的命令创建的container生成的volumeID不方便使用，可以使用<code>docker run -d -v mysql:/var/lib/mysql --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql</code>创建（-v参数指定volume的名字），当把创建的MySQL container销毁之后，下一次启动一个新的container(<code>docker run -d -v mysql:/var/lib/mysql --name mysql2 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql</code>)的时候可以继续通过volume的名字指定使用销毁的container的volume。</p>
<p>上述命令中的<code>-v</code>参数：指定生成的volume名字，前面的参数是volume名字:后面的是容器中备份文件的路径，</p>
<p><strong>demo: bind mount使用</strong></p>
<p>考虑这样一个场景：假如我们只有mac环境，但是我们在Mac上安装了docker。我们想要使用Mac的pycharm ide开发了一个Flask项目，我们可以创建一个Dockerfile，然后将这个项目创建一个镜像，然后运行这个镜像到container中。但是突然发现我们还有一个功能没有开发，这时候会频繁的修改Flask项目中的文件，如果我们每做一次修改就要重新build创建一个镜像，然后运行，实在是太麻烦了，这个时候我们可以考虑使用这个bind mount神器。具体操作如下：</p>
<ul>
<li>将初次的项目，创建一个镜像，然后运行的时候使用-v参数：<code>docker run -p 5000:5000 -d --name flask -v $(pwd):/root/flask mxiaole/myflask</code></li>
<li>之后，可以在Mac上修改项目文件，这些文件或自动的同步到container中</li>
</ul>
<p><strong>demo2: wordpress搭建</strong></p>
<ul>
<li>docker run -d –name mysql -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=wordpress mysql:5.7</li>
<li>docker run -d -e WORDPRESS_DB_HOST=mysql:3306 –link mysql -p 8080:80 wordpress</li>
</ul>
<h1 id="8-docker-compose"><a href="#8-docker-compose" class="headerlink" title="8. docker-compose"></a>8. docker-compose</h1><p>如果我们想要创建一个Python项目，这个Python项目依赖MySQL和Redis和Nginx，这时候需要手动的创建这些container，为了减少复杂度，我们可以将这些container创建成一个组，将这些容器进行统一的启动，删除等操作。docker-compose就是为了解决这个问题的。</p>
<p>注意：该方式不适合在生产环境使用</p>
<h2 id="8-1-使用"><a href="#8-1-使用" class="headerlink" title="8.1 使用"></a>8.1 使用</h2><p>基本的使用流程：创建一个docker-compose.yaml文件，然后使用docker-compose进行操作。</p>
<p><strong>命令</strong></p>
<ul>
<li>docker-compose up</li>
<li>docker-compose images</li>
<li>docker-compose ps</li>
<li>docker-compose exec </li>
</ul>
<h2 id="8-2-docker-compose-yml文件"><a href="#8-2-docker-compose-yml文件" class="headerlink" title="8.2 docker-compose.yml文件"></a>8.2 docker-compose.yml文件</h2><p>可以直接指定镜像启动，也可以通过在compose文件中使用build命令在文件中先build镜像，然后在启动镜像。</p>
<p>docker-compose.yaml文件, 该文件主要有三个基本的概念：service，networks，volumes.</p>
<p><strong>services</strong>：一个service代表一个container，可以给service指定network和volume</p>
<p>水平扩展：<code>docker-compose up --scale web=3  -d</code>, 该命令只能实现单机上的扩容，无法实现多个物理机器上的扩容，如果想要扩容还需要使用swarm</p>
<h1 id="9-swarm容器编排"><a href="#9-swarm容器编排" class="headerlink" title="9. swarm容器编排"></a>9. swarm容器编排</h1><p>在集群中管理docker镜像</p>
<h2 id="9-1-基础"><a href="#9-1-基础" class="headerlink" title="9.1 基础"></a>9.1 基础</h2><p>物理机两个角色：manager 和 worker。swarm集群的初始化：<code>docker swarm init --advertise-addr=想要做manager的节点ip</code>，初始化manager节点</p>
<p>集群相关的命令：<code>docker node</code></p>
<p>在docker swarm集群中创建service不在使用<code>docker run</code>命令，而是使用<code>docker service create</code>命令.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create      Create a new service  # 创建一个服务</span><br><span class="line">inspect     Display detailed information on one or more services</span><br><span class="line">logs        Fetch the logs of a service or task</span><br><span class="line">ls          List services</span><br><span class="line">ps          List the tasks of one or more services</span><br><span class="line">rm          Remove one or more services</span><br><span class="line">rollback    Revert changes to a service's configuration</span><br><span class="line">scale       Scale one or multiple replicated services  # 横向扩展服务</span><br><span class="line">update      Update a service</span><br></pre></td></tr></table></figure>

<h2 id="9-2-swarm中的docker-compose"><a href="#9-2-swarm中的docker-compose" class="headerlink" title="9.2 swarm中的docker-compose"></a>9.2 swarm中的docker-compose</h2><p>首先创建docker-compose文件，然后使用命令<code>docker stack</code>命令来部署服务</p>
<h2 id="9-2-实践"><a href="#9-2-实践" class="headerlink" title="9.2 实践"></a>9.2 实践</h2><p>使用docker-machine命令创建三个安装了docker的虚拟机.<br>1.前提条件：</p>
<ul>
<li>安装了docker-machine工具</li>
<li>安装了virtual-box驱动</li>
</ul>
<p>2.安装</p>
<p>依次执行命令：<code>docker-machine create swarm-manager</code>, <code>docker-machine create swarm-worker1</code>, <code>docker-machine create swarm-worker2</code></p>
<p>3.初始化</p>
<ul>
<li>登录要作为manager的主机：<code>docker-machine ssh swarm-manager</code>, 然后执行命令: <code>docker swarm init --advertise-addr=192.168.99.101</code>，之后会得到<code>docker swarm join --token SWMTKN-1-0etbagd0a455sx2b7bu0va69qhdqzti8bc7hhqohi7rzm29lus-ekf933f62naxe37s52bk64umq 192.168.99.101:2377</code></li>
<li>登录worker机器：分别执行上面的命令输出的命令<code>docker swarm join --token SWMTKN-1-0etbagd0a455sx2b7bu0va69qhdqzti8bc7hhqohi7rzm29lus-ekf933f62naxe37s52bk64umq 192.168.99.101:2377</code></li>
<li>检查集群的状态：登录manager节点，执行<code>docker node ls</code>命令</li>
</ul>
<p>4.部署wordpress服务</p>
<ul>
<li>在manager节点上创建一个overlay驱动的网络: <code>docker network create -d overlay demo</code></li>
<li>在manager节点上创建MySQL服务: <code>docker service create --name mysql --env MYSQL_ROOT_PASSWORD=root --env MYSQL_DATABASE=wordpress --network demo --mount type=volume,source=mysql-data,destination=/var/lib/mysql mysql:5.7</code></li>
<li>在manager节点上创建wordpress服务：<code>docker service create --name wordpress -p 80:80 --env WORDPRESS_DB_PASSWORD=root --env WORDPRESS_DB_HOST=mysql --network demo wordpress</code></li>
</ul>
<h2 id="9-3-swarm中的密码管理Dockersecret"><a href="#9-3-swarm中的密码管理Dockersecret" class="headerlink" title="9.3 swarm中的密码管理Dockersecret"></a>9.3 swarm中的密码管理Dockersecret</h2><p><strong>创建</strong><br>使用<code>docker secret create</code>命令来创建secret，可以从标准输入来创建，也可以从文件来创建。</p>
<ul>
<li><code>docker secret create secret名字  文件名</code></li>
<li><code>echo &quot;*****&quot; | docker secret create secretname  -</code>  </li>
</ul>
<p><strong>使用</strong></p>
<ul>
<li><p>在命令行中使用：在创建container的时候通过–secret参数来指定secret, 然后会被保存在container上的/run/secrets目录下。例如使用MySQL密码使用：在创建container的时候可以使用如下的命令：<br><code>docker service create --name mysql --secret secretname -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/secretname mysql:5.7</code></p>
</li>
<li><p>在docker-compose文件中使用: 可以使用secret标签先创建然后使用, 也可以先手动创建然后service中直接使用。推荐采用后者。<br>方式1：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">aaa:</span></span><br><span class="line">    <span class="string">xxxxx</span> </span><br><span class="line">  </span><br><span class="line">  <span class="attr">secrect:</span></span><br><span class="line">    <span class="attr">my-pwd:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">./password</span></span><br></pre></td></tr></table></figure>
<p>方式2：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-pwd</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="9-4-docker-swarm-service的更新"><a href="#9-4-docker-swarm-service的更新" class="headerlink" title="9.4 docker swarm service的更新"></a>9.4 docker swarm service的更新</h2><p>在不停服的情况下对server进行更新：首先将service进行水平扩展<code>docker service scale server_container_name=2</code>, 然后使用命令<code>docker service update --image new_image_name server_container_name</code></p>
<p>通过端口更新, 这样会导致业务的中断：<code>docker service update --publish-rm 8080:5050 --publish-add 9999:5050 container-name</code></p>
<p>对于通过docker-compose文件创建的service的更新，需要直接修改docker-compose文件，然后重新执行docker stack deploy。</p>
<blockquote>
<p>参考文章<br>1.<a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/cli/</a><br>2.《Docker进阶与实战》<br>3.<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/docker/" rel="tag"># docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/25/kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/" rel="prev" title="kafka权威指南笔记">
      <i class="fa fa-chevron-left"></i> kafka权威指南笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/07/27/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/" rel="next" title="常用的基础架构">
      常用的基础架构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-安装docker"><span class="nav-number">1.</span> <span class="nav-text">0. 安装docker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-docker-machine使用"><span class="nav-number">2.</span> <span class="nav-text">1. docker-machine使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-基本概念"><span class="nav-number">3.</span> <span class="nav-text">2. 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#架构图"><span class="nav-number">3.1.</span> <span class="nav-text">架构图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docker使用的底层技术主要有："><span class="nav-number">3.2.</span> <span class="nav-text">docker使用的底层技术主要有：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">3.3.</span> <span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-image"><span class="nav-number">4.</span> <span class="nav-text">3. image</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-是什么"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-怎么操作"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 怎么操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-创建image"><span class="nav-number">5.</span> <span class="nav-text">4. 创建image</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-基于container创建image"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 基于container创建image</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-使用Dockerfile创建image"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 使用Dockerfile创建image</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-demo"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-container操作"><span class="nav-number">6.</span> <span class="nav-text">5. container操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-启动容器"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 启动容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他命令"><span class="nav-number">6.2.</span> <span class="nav-text">其他命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-网络管理"><span class="nav-number">7.</span> <span class="nav-text">6. 网络管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-数据持久化"><span class="nav-number">8.</span> <span class="nav-text">7. 数据持久化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-docker-compose"><span class="nav-number">9.</span> <span class="nav-text">8. docker-compose</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-使用"><span class="nav-number">9.1.</span> <span class="nav-text">8.1 使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-docker-compose-yml文件"><span class="nav-number">9.2.</span> <span class="nav-text">8.2 docker-compose.yml文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-swarm容器编排"><span class="nav-number">10.</span> <span class="nav-text">9. swarm容器编排</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-基础"><span class="nav-number">10.1.</span> <span class="nav-text">9.1 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-swarm中的docker-compose"><span class="nav-number">10.2.</span> <span class="nav-text">9.2 swarm中的docker-compose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-实践"><span class="nav-number">10.3.</span> <span class="nav-text">9.2 实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-swarm中的密码管理Dockersecret"><span class="nav-number">10.4.</span> <span class="nav-text">9.3 swarm中的密码管理Dockersecret</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-docker-swarm-service的更新"><span class="nav-number">10.5.</span> <span class="nav-text">9.4 docker swarm service的更新</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cody</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mxiaole" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mxiaole" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mengjiale6@126.com" title="E-Mail → mengjiale6@126.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cody</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
