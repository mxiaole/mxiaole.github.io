<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>rust编程入门 | 人生识字忧患始，不待扬鞭自奋蹄</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文简单的记录了一些rust语言的基础知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="rust编程入门">
<meta property="og:url" content="http://yoursite.com/2019/12/19/rust%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="人生识字忧患始，不待扬鞭自奋蹄">
<meta property="og:description" content="本文简单的记录了一些rust语言的基础知识。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-12-19T15:34:45.000Z">
<meta property="article:modified_time" content="2020-01-06T14:26:51.699Z">
<meta property="article:author" content="Cody">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="人生识字忧患始，不待扬鞭自奋蹄" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">人生识字忧患始，不待扬鞭自奋蹄</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-rust编程入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/19/rust%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2019-12-19T15:34:45.000Z" itemprop="datePublished">2019-12-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      rust编程入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文简单的记录了一些rust语言的基础知识。</p>
<a id="more"></a>

<h1 id="rust编程基础"><a href="#rust编程基础" class="headerlink" title="rust编程基础"></a>rust编程基础</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1 变量"></a>1 变量</h2><h3 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h3><h4 id="1-1-1-struct结构"><a href="#1-1-1-struct结构" class="headerlink" title="1.1.1 struct结构"></a>1.1.1 struct结构</h4><p><strong>结构体的定义</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例化结构体</strong></p>
<p>方法1：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法2：字段初始化简写语法，当参数名与字段名都完全相同</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法3：结构体更新语法，从其他结构体中创建实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    active: user1.active,</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    ..user1 <span class="comment">// .. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>注意：Rust并不允许只将结构体某个字段标记为可变</em> </p>
<p><strong>元组结构体</strong></p>
<p>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>类单元结构体</strong></p>
<p>没有任何字段的结构体被称为<strong>类单元结构体</strong>。</p>
<h3 id="1-2-创建"><a href="#1-2-创建" class="headerlink" title="1.2 创建"></a>1.2 创建</h3><h3 id="1-3-作用域"><a href="#1-3-作用域" class="headerlink" title="1.3 作用域"></a>1.3 作用域</h3><h2 id="2-逻辑控制"><a href="#2-逻辑控制" class="headerlink" title="2 逻辑控制"></a>2 逻辑控制</h2><h3 id="2-1-循环控制"><a href="#2-1-循环控制" class="headerlink" title="2.1 循环控制"></a>2.1 循环控制</h3><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><h3 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1 创建"></a>3.1 创建</h3><h3 id="3-2-调用"><a href="#3-2-调用" class="headerlink" title="3.2 调用"></a>3.2 调用</h3><h3 id="3-3-其他"><a href="#3-3-其他" class="headerlink" title="3.3 其他"></a>3.3 其他</h3><h4 id="3-3-1-闭包"><a href="#3-3-1-闭包" class="headerlink" title="3.3.1 闭包"></a>3.3.1 闭包</h4><p><strong>什么是闭包</strong></p>
<p>在rust中闭包是匿名函数。</p>
<p><strong>闭包的定义</strong></p>
<p>闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数；之所以选择这个语法是因为它与 Smalltalk 和 Ruby 的闭包定义类似。这个闭包有一个参数 num；如果有多于一个参数，可以使用逗号分隔，比如 |param1, param2|。参数之后是存放闭包体的大括号 —— 如果闭包体只有一行则大括号是可以省略的。大括号之后闭包的结尾，需要用于 let 语句的分号。因为闭包体的最后一行没有分号（正如函数体一样），所以闭包体（num）最后一行的返回值作为调用闭包时的返回值 。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expensive_closure = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中：闭包定义是 expensive_closure 赋值的 = 之后的部分</p>
<p><strong>闭包与函数的区别</strong></p>
<p>闭包不要求像 fn 函数那样在参数和返回值上注明类型。函数中需要类型注解是因为他们是暴露给用户的显式接口的一部分。严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的。但是闭包并不用于这样暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用。闭包通常很短并只与对应相对任意的场景较小的上下文中。在这些有限制的上下文中，编译器能可靠的推断参数和返回值的类型，类似于它是如何能够推断大部分变量的类型一样。但是也可以选择增加类型注解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expensive_closure = |num: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面的定义具有相同的作用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> add_one_v2 = |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v3 = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v4 = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>

<p><strong>move关键字</strong></p>
<p>你希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用<code>move</code>关键字。在将闭包传递给新线程以便将数据移动到新线程中时最为实用。</p>
<h2 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4 面向对象"></a>4 面向对象</h2><h3 id="4-1-类的定义"><a href="#4-1-类的定义" class="headerlink" title="4.1 类的定义"></a>4.1 类的定义</h3><h4 id="4-1-1-属性和方法的权限控制"><a href="#4-1-1-属性和方法的权限控制" class="headerlink" title="4.1.1 属性和方法的权限控制"></a>4.1.1 属性和方法的权限控制</h4><h3 id="4-2-接口的定义"><a href="#4-2-接口的定义" class="headerlink" title="4.2 接口的定义"></a>4.2 接口的定义</h3><h3 id="4-3-对象的创建"><a href="#4-3-对象的创建" class="headerlink" title="4.3 对象的创建"></a>4.3 对象的创建</h3><h2 id="5-错误及异常处理"><a href="#5-错误及异常处理" class="headerlink" title="5 错误及异常处理"></a>5 错误及异常处理</h2><h3 id="5-1-不可恢复的错误处理"><a href="#5-1-不可恢复的错误处理" class="headerlink" title="5.1 不可恢复的错误处理"></a>5.1 不可恢复的错误处理</h3><p>由于某些我们没有预料到的问题导致程序终止执行，或者在不满足某些条件的时候我们希望终止程序的执行。在大部分的编程语言中，出现错误的时候程序会直接崩掉，并打印出程序错误时的堆栈信息，也可以在不满足某些情况的时候直接抛出一下我们自定义的异常。在Rust中，处理程序中的错误是通过<code>panic!</code>这一宏来实现的。对于程序终止时的输出内容有两种选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 对程序出现错误的地方进行栈展开</span><br><span class="line">2. 对程序出现错误直接终止程序的执行</span><br></pre></td></tr></table></figure>

<p><em>最佳实践：如果实在release版本中，我们希望项目最终的二进制文件越小越好，此时可以在Cargo.toml文件中增加panic=‘abort’，可以有展开切换为终止</em></p>
<h3 id="5-2-可以恢复的错误处理"><a href="#5-2-可以恢复的错误处理" class="headerlink" title="5.2 可以恢复的错误处理"></a>5.2 可以恢复的错误处理</h3><p>首先，我们应该知道，在rust中有些函数的返回值是Result类型，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code>代表成功时返回的Ok成员中的数据类型，<code>E</code>代表失败时返回的<code>Err</code>成员中的错误的类型。</p>
<p>并不是所有的错误，我们都想要让程序终止执行。此时，我们选择可以匹配这个错误，然后执行一些我们需要执行的动作。可以使用<code>match</code>语句来进行匹配，也可以使用<code>unwrap</code>和<code>expect</code>来简写<code>match</code>匹配。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unwrap</code>: 如果<code>Resut</code>中的成员是<code>Ok</code>，<code>unwrap</code>会返回<code>Ok</code>中的值，如果<code>Result</code>中的成员是<code>Err</code>，<code>unwrap</code>会调用<code>panic!</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>except</code>: 该方法能够允许我们自定义<code>panic!</code>时的错误信息。</p>
<h3 id="5-3-错误的传递"><a href="#5-3-错误的传递" class="headerlink" title="5.3 错误的传递"></a>5.3 错误的传递</h3><p>有时候，我们并不希望在函数中处理错误，而是将错误返回给函数的调用者。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; <span class="literal">Ok</span>(s),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的错误的传播太过于复杂，在rust中可以使用<code>?</code>运算符来简写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-包和模块"><a href="#6-包和模块" class="headerlink" title="6 包和模块"></a>6 包和模块</h2><p>在我们平时开发中创建的项目要么是提供给别人使用的lib库文件，要么是最后编译之后可以执行文件。<br>rust中的包叫做crate，每个包装箱(crate)有一个隐含的根模块（root module）包含了该包装箱的代码. rust中的模块是模块树结构，Cargo 遵循的一个约定：src/main.rs 就是一个与包同名的二进制 crate 的 crate 根。同样的，Cargo 知道如果包目录中包含 src/lib.rs，则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根。 如果一个包同时含有 src/main.rs 和 src/lib.rs，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 src/bin 目录下，一个包可以享有多个二进制 crate：每个文件都是一个分离出来的二进制 crate。</p>
<h3 id="6-1-创建和导入"><a href="#6-1-创建和导入" class="headerlink" title="6.1 创建和导入"></a>6.1 创建和导入</h3><h4 id="6-1-1-包的创建"><a href="#6-1-1-包的创建" class="headerlink" title="6.1.1 包的创建"></a>6.1.1 包的创建</h4><p><code>cargo new my-project</code></p>
<h4 id="6-1-2-模块的创建"><a href="#6-1-2-模块的创建" class="headerlink" title="6.1.2 模块的创建"></a>6.1.2 模块的创建</h4><p>使用<code>mod</code>关键字来定义模块。定义的方式有两种：</p>
<p>定义方式1：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> english &#123;</span><br><span class="line">    <span class="comment">// Contents of our module go here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义方式2：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> english;</span><br></pre></td></tr></table></figure>
<p>使用第二种方式定义：表示Rust会期望能找到一个包含我们模块内容的english.rs文件，或者包含我们模块内容的english/mod.rs文件</p>
<h4 id="6-1-3-模块的引用"><a href="#6-1-3-模块的引用" class="headerlink" title="6.1.3 模块的引用"></a>6.1.3 模块的引用</h4><p>模块的使用就是，引用模块树中的项。在Rust 如何在模块树中找到一个项的位置，使用路径的方式，就像在文件系统使用路径一样。如果我们想要调用一个函数，我们需要知道它的路径。路径有两种形式：相对路径和绝对路径。使用<code>use</code>关键字使用模块中的函数。</p>
<h3 id="6-2-访问权限控制"><a href="#6-2-访问权限控制" class="headerlink" title="6.2 访问权限控制"></a>6.2 访问权限控制</h3><p>在Rust中默认所有的模块和模块内的函数都是私有的。可以使用<code>pub</code>关键字将模块或者模块内的函数导出。但是在私有模块中的函数都必须是私有的，在公有模块中的函数可以是私有的也可以是公开的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> a_public_module &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">a_public_function</span></span>() &#123;</span><br><span class="line">        <span class="comment">// 公有的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">a_private_function</span></span>() &#123;</span><br><span class="line">        <span class="comment">// 私有的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> a_private_module &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">a_private_function</span></span>() &#123;</span><br><span class="line">        <span class="comment">// 私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-第三方库的管理和下载"><a href="#6-3-第三方库的管理和下载" class="headerlink" title="6.3 第三方库的管理和下载"></a>6.3 第三方库的管理和下载</h3><p>在rust中如果使用别人的crate需要在Cargo.toml文件中将依赖添加进去：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">"0.5.5"</span></span><br></pre></td></tr></table></figure>
<p>在 Cargo.toml 中加入 rand 依赖告诉了 Cargo 要从 crates.io 下载 rand 和其依赖，并使其可在项目代码中使用</p>
<h3 id="6-4-常用的标准库"><a href="#6-4-常用的标准库" class="headerlink" title="6.4 常用的标准库"></a>6.4 常用的标准库</h3><h2 id="7-并发编程"><a href="#7-并发编程" class="headerlink" title="7 并发编程"></a>7 并发编程</h2><h3 id="7-1-进程"><a href="#7-1-进程" class="headerlink" title="7.1 进程"></a>7.1 进程</h3><h3 id="7-2-线程"><a href="#7-2-线程" class="headerlink" title="7.2 线程"></a>7.2 线程</h3><h3 id="7-3-协程"><a href="#7-3-协程" class="headerlink" title="7.3 协程"></a>7.3 协程</h3><h2 id="8-语言特性"><a href="#8-语言特性" class="headerlink" title="8 语言特性"></a>8 语言特性</h2><h3 id="8-1-rust所有权"><a href="#8-1-rust所有权" class="headerlink" title="8.1 rust所有权"></a>8.1 rust所有权</h3><h4 id="8-1-1-所有权的概念"><a href="#8-1-1-所有权的概念" class="headerlink" title="8.1.1 所有权的概念"></a>8.1.1 所有权的概念</h4><p>所有权所说的是：程序中的<strong>值</strong>，每个值都有一个被称为其所有者的变量，并且有且仅有唯一的所有者。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> var = <span class="string">"hello world"</span>  <span class="comment">// "hello world"这个值的所有者是 var</span></span><br></pre></td></tr></table></figure>

<h4 id="8-1-2-所有权的借用"><a href="#8-1-2-所有权的借用" class="headerlink" title="8.1.2 所有权的借用"></a>8.1.2 所有权的借用</h4><p>在rust中的引用是允许使用值但是不获取所有权，这种操作被称为<strong>所有权借用</strong></p>
<h3 id="8-2-模式匹配"><a href="#8-2-模式匹配" class="headerlink" title="8.2 模式匹配"></a>8.2 模式匹配</h3><p>match表达式</p>
<h2 id="9-最佳实践"><a href="#9-最佳实践" class="headerlink" title="9 最佳实践"></a>9 最佳实践</h2><blockquote>
<p>参考</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MjAzNDI1MA==&mid=2648210254&idx=1&sn=08124b76f639aec44e7446e43a15ac1f&chksm=f1c536ebc6b2bffdcfa23cd3f434570d9c88d3a698da1b1adc8ffca846d2004b8449672eecc3&mpshare=1&scene=1&srcid=&sharer_sharetime=1576727581650&sharer_shareid=bd726766a074fa81de1978890c5213aa%23rd" target="_blank" rel="noopener">如何理解rust中的可变与不可变</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn" target="_blank" rel="noopener">Rust程序语言设计</a></li>
</ol>
</blockquote>
<h1 id="rust网络编程"><a href="#rust网络编程" class="headerlink" title="rust网络编程"></a>rust网络编程</h1><h2 id="1-基础套接字"><a href="#1-基础套接字" class="headerlink" title="1 基础套接字"></a>1 基础套接字</h2><h2 id="2-异步网络编程s"><a href="#2-异步网络编程s" class="headerlink" title="2 异步网络编程s"></a>2 异步网络编程s</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/19/rust%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" data-id="ck64myhhe004kzpsb95j32klt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据结构专题
        
      </div>
    </a>
  
  
    <a href="/2019/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">设计模式</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">后台开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/">爬虫开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/">通用编程技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/burp/" rel="tag">burp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmake/" rel="tag">cmake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/curl/" rel="tag">curl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/erlang/" rel="tag">erlang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es/" rel="tag">es</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/" rel="tag">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grcp/" rel="tag">grcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kakfa/" rel="tag">kakfa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lantern/" rel="tag">lantern</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lua/" rel="tag">lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/make/" rel="tag">make</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust/" rel="tag">rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql%E6%B3%A8%E5%85%A5/" rel="tag">sql注入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/" rel="tag">基础架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/burp/" style="font-size: 10px;">burp</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/tags/curl/" style="font-size: 10px;">curl</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/erlang/" style="font-size: 10px;">erlang</a> <a href="/tags/es/" style="font-size: 10px;">es</a> <a href="/tags/etcd/" style="font-size: 15px;">etcd</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/go/" style="font-size: 20px;">go</a> <a href="/tags/grcp/" style="font-size: 10px;">grcp</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/kakfa/" style="font-size: 10px;">kakfa</a> <a href="/tags/lantern/" style="font-size: 10px;">lantern</a> <a href="/tags/lua/" style="font-size: 10px;">lua</a> <a href="/tags/make/" style="font-size: 10px;">make</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/rust/" style="font-size: 10px;">rust</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/sql%E6%B3%A8%E5%85%A5/" style="font-size: 10px;">sql注入</a> <a href="/tags/vscode/" style="font-size: 10px;">vscode</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">基础架构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">网络编程</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/02/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/">http协议基础</a>
          </li>
        
          <li>
            <a href="/2020/01/31/go%E6%A1%86%E6%9E%B6-gin/">go框架-gin</a>
          </li>
        
          <li>
            <a href="/2020/01/29/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">go语言基础</a>
          </li>
        
          <li>
            <a href="/2020/01/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%AE%80%E4%BB%8B/">分布式系统--简介</a>
          </li>
        
          <li>
            <a href="/2020/01/04/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Cody<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>