<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见算法题目</title>
    <url>/2020/02/18/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-字符串常见的问题"><a href="#1-字符串常见的问题" class="headerlink" title="1 字符串常见的问题"></a>1 字符串常见的问题</h2><h3 id="数值转为字符串"><a href="#数值转为字符串" class="headerlink" title="数值转为字符串"></a>数值转为字符串</h3><p>num % 10和num / 10</p>
<h3 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h3><p>while迭代</p>
<h3 id="逆序字符串中的单词"><a href="#逆序字符串中的单词" class="headerlink" title="逆序字符串中的单词"></a>逆序字符串中的单词</h3><p>begin和end定为一个单词的开始和结束为止</p>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>动态规划</p>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>动态规划</p>
<h3 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言进阶</title>
    <url>/2020/02/07/go%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>本文记录了go语言中常用的包</p>
<a id="more"></a>

<h2 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1 文件操作"></a>1 文件操作</h2><p>使用<code>os</code>, <code>ioutil</code> 包来操作文件</p>
<h3 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fileInfo, err := os.Stat(<span class="string">"a.txt"</span>) <span class="comment">// 获取文件信息</span></span><br><span class="line">file, err := os.Open(<span class="string">"a.txt"</span>) <span class="comment">// 打开文件, 此方式打开的文件是只读的</span></span><br><span class="line">file, err := os.OpenFile(<span class="string">"fileName"</span>, os.O_RDONLY|os.O_WRONLY, os.ModePerm)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-grpc"><a href="#2-grpc" class="headerlink" title="2 grpc"></a>2 grpc</h2>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp协议基础</title>
    <url>/2020/02/07/tcp%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文记录了tcp协议相关的知识点。</p>
<a id="more"></a>

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><h3 id="数据包的封装"><a href="#数据包的封装" class="headerlink" title="数据包的封装"></a>数据包的封装</h3><p>以浏览器向服务器端发送请求为例，具体的数据包的封装流程如下：</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%B0%81%E8%A3%85.png" alt="数据包的封装"></p>
<p>首先，将发送的数据<strong>在浏览器中进行http协议</strong>封装；然后，浏览器将数据发送给<strong>内核协议栈进行tcp、ip</strong>进行封装，之后内核将数据发送给<strong>网卡驱动进行数据链路层</strong>的封装，最后封装好的数据经过网卡发送出去。</p>
<ul>
<li>在http协议封装数据包的时候，http首部主要包含一些<code>目标主机域名host, connection等字段</code></li>
<li>在tcp封装的时候，tcp首部主要是<code>源端口号、目的端口号、序号、校验和</code></li>
<li>在ip封装的时候，ip首部主要是<code>源ip、目的ip</code></li>
<li>在以太网协议封装的时候，以太网首部包含<code>源mac、下一节点的mac、标志以太网类型的以太网数据</code></li>
</ul>
<p>服务器收到请求之后，进行解包处理：</p>
<ul>
<li>主机收到以太网包之后，首先从以太网的首部找到mac地址判断是否是发送给自己的包，如果不是发送给自己的包就丢弃，如果是发送给自己的，就查找以太网首部中的类型域从而确定以太网协议所发送过来的数据类型，如果是ip包，就交给处理IP的子程序，如果是ARP，就交给处理arp的子程序，如果是无法识别的，就丢弃</li>
<li>IP模块处理：收到包之后，判断首部的ip地址和自己的ip地址是否匹配，如果匹配就看是TCP还是UDP，然后交给相应的子程序处理 </li>
<li>tcp模块处理: 收到之后首先计算校验和，判断数据是否被破坏，然后检查是否在按照序列号接收数据，最后检查端口，确定具体的应用程序</li>
<li>浏览器处理http数据包，将数据进行渲染展示</li>
</ul>
<h2 id="2-数据链路层协议"><a href="#2-数据链路层协议" class="headerlink" title="2 数据链路层协议"></a>2 数据链路层协议</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC地址是一般会被烧入ROM中的，任意一个网卡的MAC地址都是全球唯一的；</p>
<p>MAC地址<code>48位(6个字节)</code>: </p>
<ul>
<li>1位: 表示是单播地址(0)还是多播地址(1)</li>
<li>2位: 表示是全局地址(0)还是本地之地(1)</li>
<li>3-24位: 厂商识别码</li>
<li>25-48位: 厂商内部使用</li>
</ul>
<h3 id="2-2-以太网协议"><a href="#2-2-以太网协议" class="headerlink" title="2.2 以太网协议"></a>2.2 以太网协议</h3><h2 id="3-网络层协议"><a href="#3-网络层协议" class="headerlink" title="3 网络层协议"></a>3 网络层协议</h2><h3 id="3-1-IP协议"><a href="#3-1-IP协议" class="headerlink" title="3.1 IP协议"></a>3.1 IP协议</h3><h3 id="3-2-ICMP协议"><a href="#3-2-ICMP协议" class="headerlink" title="3.2 ICMP协议"></a>3.2 ICMP协议</h3><h3 id="3-3-ARP协议"><a href="#3-3-ARP协议" class="headerlink" title="3.3 ARP协议"></a>3.3 ARP协议</h3><h2 id="4-传输层协议"><a href="#4-传输层协议" class="headerlink" title="4 传输层协议"></a>4 传输层协议</h2><p>tcp协议是一种面向连接的、可靠的流协议。udp是不具有可靠性的数据包协议。</p>
<h3 id="4-1-TCP"><a href="#4-1-TCP" class="headerlink" title="4.1 TCP"></a>4.1 TCP</h3><h4 id="4-1-1-tcp首部字段"><a href="#4-1-1-tcp首部字段" class="headerlink" title="4.1.1 tcp首部字段"></a>4.1.1 tcp首部字段</h4><p><img src="tcp%E6%8A%A5%E6%96%87%E5%A4%B4.png" alt="tcp首部"></p>
<ul>
<li>序号：使用tcp在发送数据的时候，数据的每个字节都会进行编号。该字段告知对端自己传输的数据的第多少个字节, 即本报文段所发送数据的第一个字节的编号</li>
<li>确认序号：告知对端自己期望收到发送方下一个报文段的第一个字节数据的编号</li>
<li>标识位<ul>
<li>URG：紧急指针有效</li>
<li>ACk：确认序号有效</li>
<li>PSH：告知接收方尽快将这个报文段交给应用层</li>
<li>RST：重建连接</li>
<li>SYN：同步序号，用来发起一个连接</li>
<li>FIN：发端完成发送任务</li>
</ul>
</li>
<li>窗口：单位为字节，告知对方自己接收的缓存大小, 也就是告诉对方，从本报文段的确认号开始允许对方发送的数据量。</li>
<li>选项：<ul>
<li>MSS最大报文段长度：指明数据字段的最大长度。数据字段的长度加上TCP首部的长度才等于整个TCP报文段的长度。MSS值指示自己期望对方发送TCP报文段时那个数据字段的长度。通信双方可以有不同的MSS值。如果未填写，默认采用536字节。MSS只出现在SYN报文中。即：MSS出现在SYN=1的报文段中</li>
<li>窗口扩大选项：</li>
<li>SACK：来确保只重传缺少的报文段，而不是重传所有报文段。比如主机A发送报文段1、2、3，而主机B仅收到报文段1、3。那么此时就需要使用SACK选项来告诉发送方只发送丢失的数据。那么又如何指明丢失了哪些报文段呢？使用SACK需要两个功能字节。一个表示要使用SACK选项，另一个指明这个选项占用多少字节。描述丢失的报文段2，是通过描述它的左右边界报文段1、3来完成的。而这个1、3实际上是表示序列号，所以描述一个丢失的报文段需要64位即8个字节的空间。那么可以推算整个选项字段最多描述(40-2)/8=4个丢失的报文段。</li>
<li>时间戳选项（Timestamps）：可以用来计算RTT(往返时间)，发送方发送TCP报文时，把当前的时间值放入时间戳字段，接收方收到后发送确认报文时，把这个时间戳字段的值复制到确认报文中，当发送方收到确认报文后即可计算出RTT。也可以用来防止回绕序号PAWS，也可以说可以用来区分相同序列号的不同报文。因为序列号用32为表示，每2^32个序列号就会产生回绕，那么使用时间戳字段就很容易区分相同序列号的不同报文</li>
</ul>
</li>
</ul>
<h4 id="4-1-2-可靠传输的实现"><a href="#4-1-2-可靠传输的实现" class="headerlink" title="4.1.2 可靠传输的实现"></a>4.1.2 可靠传输的实现</h4><p>tcp协议可靠性的实现是通过<code>确认应答机制</code>实现的，确认应答是通过tcp协议首部中的<strong>序号和确认号</strong>实现的。所谓的确认应答就是, 发送端将数据发出去之后会等待对端的确认应答:</p>
<ul>
<li>如果收到了确认应答，说明数据已经成功的到达对端</li>
<li>如果<code>一定时间内</code>没有收到确认应答，发送方会重新发送, 称为<code>超时重传</code>。数据重发时候如果还是收不到确认应答，则再次进行发送，此时，等待确认应答的时间将会以2倍、4倍的指数函数增长。但是，数据不会被无限次数的重发，达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。</li>
</ul>
<p><strong>超时重传中的超时的具体时间是怎么确定的？</strong></p>
<p>TCP每发送一个报文，就对这个报文设置一个计时器，只要计时器设置的重传时间到但是还没有收到确认，就要重传这一个包。这个重传时间是一个RTT往返时间。RTT时间不是一个固定的值，是一个平均时间，有一个计算公式：RTTS=(1-α)<em>旧的RTTS + α</em>新的RTT样本，因为网络的复杂每一个的往返时间是不一样的。</p>
<h4 id="4-1-3-连接管理"><a href="#4-1-3-连接管理" class="headerlink" title="4.1.3 连接管理"></a>4.1.3 连接管理</h4><p><strong>建立连接</strong></p>
<p><strong>断开连接</strong></p>
<h4 id="4-1-3-数据传输"><a href="#4-1-3-数据传输" class="headerlink" title="4.1.3 数据传输"></a>4.1.3 数据传输</h4><p>tcp以段位单位发送数据。</p>
<p><strong>数据传输数据包的大小</strong></p>
<p>通信的双方在发送数据的时候，数据包中传输的有效数据的大小为MSS值的大小，MSS的值是在三次握手的时候确定的（在握手的时候通信双方都会告诉对端自己能够适应的MSS的大小，然后在两者中的较小的那个使用）。</p>
<p>在以太网中，由于网络硬件的限制最大MTU=1500字节，传输数据的最大值为可以是<code>1500字节-IP首部20字节-TCP首部20字节 = 1460字节</code>。</p>
<p><strong>如何提高单位时间内传输的数据量大小</strong></p>
<p>如果通信的双方对每一个分段进行一次应答的处理，包的往返时间越长，单位时间内发送的数据量就越小，造成通信性能的降低。为了解决这个问题，引入了TCP窗口的概念。在这种情况下确认应答不再以每个分段而是以更大的单位进行确认，也就是说发送端主机在发送了一个段以后，不必要一直等待确认应答，而是继续发送。<code>窗口的大小</code>就是无需等待确认应答可以继续发送数据的最大值。</p>
<h3 id="4-2-UDP"><a href="#4-2-UDP" class="headerlink" title="4.2 UDP"></a>4.2 UDP</h3>]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>信息收集</title>
    <url>/2020/02/05/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>本文记录了在渗透测试中，信息收集阶段的一些常用方法和工具。</p>
<a id="more"></a>

<p><strong>思考</strong></p>
<p>收集什么信息？</p>
<p>怎么进行信息收集？</p>
<p>常用的信息收集工具？</p>
<h2 id="1-主动信息收集"><a href="#1-主动信息收集" class="headerlink" title="1 主动信息收集"></a>1 主动信息收集</h2><p>所谓的主动信息收集就是，直接与目标主机进行通信，获取相应的信息。</p>
<h2 id="2-被动信息收集"><a href="#2-被动信息收集" class="headerlink" title="2 被动信息收集"></a>2 被动信息收集</h2><p>被动信息收集就是，不与目标主机直接进行通信</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter-notebook使用</title>
    <url>/2020/02/05/jupyter-notebook%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="运行快捷键"><a href="#运行快捷键" class="headerlink" title="运行快捷键"></a>运行快捷键</h2><ul>
<li>运行当前的cell：command + enter</li>
<li>运行当前并且在选中下一行cell：shift + enter</li>
<li>运行当前并且在下面插入一行cell：option + enter</li>
</ul>
<h2 id="移动光标快捷键"><a href="#移动光标快捷键" class="headerlink" title="移动光标快捷键"></a>移动光标快捷键</h2><ul>
<li>esc：退出写代码模式</li>
<li>enter：进入写代码模式</li>
<li>j,k：上下移动光标</li>
</ul>
<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><ul>
<li>a：在当前cell上面插入一行cell</li>
<li>b：在当前cell下面插入一行cell但是不运行</li>
<li>dd：删除当前的cell</li>
</ul>
<h2 id="markdown和代码的切换"><a href="#markdown和代码的切换" class="headerlink" title="markdown和代码的切换"></a>markdown和代码的切换</h2><ul>
<li>m：将该cell以注释的方式输入</li>
<li>y：将该cell以代码的方式输入</li>
</ul>
<h2 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h2><ul>
<li>%run调用.py文件：<code>%run path(相对地址和绝对地址都可以)/code.py</code>加载执行整个的code.py文件，然后在notebook中可以使用code.py中的变量和方法</li>
<li>调用.py文件的包和模块：直接调用就可以，跟在.py文件中一样调用</li>
<li>%timeit：测试一个代码的执行时间，会自动执行多次，取平均值进行统计时间</li>
<li>%%timeit: 测试一个cell内所有代码的执行时间，多次平均值</li>
<li>%time: 测试代码的执行时间，执行一次得到代码的执行时间</li>
</ul>
<p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.png" alt="实例展示"></p>
<p>更多的魔法命令可以通过：<code>%lsmagic</code>命令来查看</p>
<p>查看魔法命令的帮助文档: <code>%run?</code>,查看run魔法命令</p>
<h2 id="查看某个函数的帮助文档"><a href="#查看某个函数的帮助文档" class="headerlink" title="查看某个函数的帮助文档"></a>查看某个函数的帮助文档</h2><p><code>函数名?</code>: 直接使用函数名加一个?的方式即可</p>
<p><code>help(函数名)</code>: 使用此种方式也可以</p>
<h2 id="远程开发配置"><a href="#远程开发配置" class="headerlink" title="远程开发配置"></a>远程开发配置</h2><p><a href="https://blog.csdn.net/simple_the_best/article/details/77005400" target="_blank" rel="noopener">远程开发配置参考文档</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>jupyter-notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础</title>
    <url>/2020/02/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文记录了机器学习常用的包及其基于sklearn包的常用的机器学习算法</p>
<a id="more"></a>

<h2 id="1-常用的机器学习包的使用"><a href="#1-常用的机器学习包的使用" class="headerlink" title="1 常用的机器学习包的使用"></a>1 常用的机器学习包的使用</h2><h3 id="1-1-numpy"><a href="#1-1-numpy" class="headerlink" title="1.1 numpy"></a>1.1 numpy</h3><p>该包提供了向量、矩阵的表示和相关的运算。numpy中的核心对象是<code>ndarray</code>，该对象的一些基本属性和操作方法。如何创建所需要的向量或者数组？如何进行向量或者数组的运算？</p>
<h4 id="使用numpy创建向量或矩阵"><a href="#使用numpy创建向量或矩阵" class="headerlink" title="使用numpy创建向量或矩阵"></a>使用numpy创建向量或矩阵</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""numpy创建ndarry向量和矩阵"""</span></span><br><span class="line"><span class="comment"># 创建一个行向量</span></span><br><span class="line">array = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line"><span class="comment"># 创建一个2*3的矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一些特殊的向量或者矩阵</span></span><br><span class="line">array1 = np.zeros(<span class="number">10</span>)  <span class="comment"># 创建一个全0的行向量</span></span><br><span class="line">array2 = np.ones(<span class="number">10</span>)  <span class="comment"># 创建一个全1的行向量</span></span><br><span class="line">array3 = np.zeros((<span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># 创建一个全0的矩阵</span></span><br><span class="line">array4 = np.ones((<span class="number">3</span>, <span class="number">5</span>))  <span class="comment"># 创建一个全1的矩阵</span></span><br><span class="line">array5 = np.full((<span class="number">3</span>, <span class="number">5</span>), <span class="number">3</span>)  <span class="comment"># 创建一个全为指定值的矩阵</span></span><br><span class="line">array6 = np.arange(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0.3</span>)  <span class="comment"># 创建一个步长为0.2,值为从1到2的行向量</span></span><br><span class="line">array7 = np.linspace(<span class="number">1</span>, <span class="number">30</span>, <span class="number">10</span>)  <span class="comment"># 创建一个向量,将1-30等长的分成10份</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建随机的向量或者矩阵</span></span><br><span class="line">array8 = np.random.randint(<span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>)  <span class="comment"># 创建一个向量，向量中的值为0-10的随机数</span></span><br><span class="line"><span class="comment"># np.random.seed(10)  # 使用随机种子, 之后随机的向量或者矩阵都是相同的</span></span><br><span class="line">array9 = np.random.randint(<span class="number">10</span>, <span class="number">20</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">array10 = np.random.random(<span class="number">10</span>)  <span class="comment"># 生成一个向量，其中的值都是介于0-1之间的浮点数</span></span><br><span class="line">float_value = np.random.normal()  <span class="comment"># 生成一个符合正态分布的浮点数, 可以指定均值和方差</span></span><br><span class="line">float_value2 = np.random.normal(<span class="number">10</span>, <span class="number">100</span>)  <span class="comment"># 生成一个均值是10，方差是100的正态分布中的随机数</span></span><br></pre></td></tr></table></figure>

<h4 id="ndarry的基本属性"><a href="#ndarry的基本属性" class="headerlink" title="ndarry的基本属性"></a>ndarry的基本属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(matrix.dtype)  <span class="comment"># 矩阵中元素的类型</span></span><br><span class="line">print(matrix.ndim)  <span class="comment"># 表示矩阵的维度</span></span><br><span class="line">print(matrix.size)  <span class="comment"># 矩阵中元素的个数</span></span><br><span class="line">print(matrix.shape)  <span class="comment"># 矩阵的shape</span></span><br></pre></td></tr></table></figure>

<h4 id="ndarry的基本操作"><a href="#ndarry的基本操作" class="headerlink" title="ndarry的基本操作"></a>ndarry的基本操作</h4><p><strong>数据访问</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向量数据的访问</span></span><br><span class="line">vector = np.arange(<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line">print(vector[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 矩阵数据的访问</span></span><br><span class="line">matrix = np.array([[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">print(matrix[<span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># 访问1行5列的元素</span></span><br><span class="line">print(matrix[:<span class="number">1</span>, :<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong>基本运算</strong></p>
<p>矩阵的基本运算、转置等常用的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vector = np.arange(<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>)  <span class="comment"># 生成一个行向量</span></span><br><span class="line">matrix = vector.reshape((<span class="number">5</span>, <span class="number">2</span>))  <span class="comment"># 将一个行向量转为一个矩阵</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-pandas"><a href="#1-2-pandas" class="headerlink" title="1.2 pandas"></a>1.2 pandas</h3><h3 id="1-3-matplotlib"><a href="#1-3-matplotlib" class="headerlink" title="1.3 matplotlib"></a>1.3 matplotlib</h3>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议基础</title>
    <url>/2020/02/02/http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文记录了http协议的基础知识。</p>
<a id="more"></a>

<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h2><p>http是应用层协议。</p>
<p>http是一种<strong>无状态</strong>的协议，不对请求和响应之间的通信状态进行保存，无法根据之前的状态进行本次的请求处理。</p>
<p>http1.1支持<strong>持久连接</strong>：持久连接的特点是只要任意一端没有提出断开连接，则保持TCP连接状态。持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互。http1.1中的连接默认都是持久连接。</p>
<p>http请求必须是客户端发起，服务端进行响应。</p>
<p>当客户端请求资源的时候需要将作为请求报文中的请求 URI 包含在内，指定请求uri的方法有如下：</p>
<p>方式1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;hackr.jp&#x2F;index.html HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure>

<p>如果不是访问特定资源而对服务器本身发起请求，可以使用<code>*</code>代替请求的uri，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>http版本有http1.0和http1.1版本。</p>
<p><strong>URI和URL</strong></p>
<p>uri：由某个协议方案（http，ftp）表示的资源资源的定位标识符，uri用来标识某一个互联网资源</p>
<p>url：是uri的子集，用来标识某一个互联网资源所在的地点</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uri: ftp:&#x2F;&#x2F;ftp.is.co.za&#x2F;rfc&#x2F;rfc1808.txt &#x2F;&#x2F; 表示的是一个资源</span><br><span class="line">url：ftp.is.co.za&#x2F;rfc&#x2F;rfc1808.txt &#x2F;&#x2F; 表示资源的地址</span><br></pre></td></tr></table></figure>

<h2 id="2-请求报文"><a href="#2-请求报文" class="headerlink" title="2 请求报文"></a>2 请求报文</h2><h3 id="2-1-请求报文的结构"><a href="#2-1-请求报文的结构" class="headerlink" title="2.1 请求报文的结构"></a>2.1 请求报文的结构</h3><ul>
<li>请求行：请求方法、请求URI、协议版本</li>
<li>请求头：请求首部字段、通用首部字段、实体首部字段</li>
<li>空行</li>
<li>请求主体：</li>
</ul>
<p>结构如下图：</p>
<p><img src="%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="请求报文结构"></p>
<h3 id="2-2-请求方法"><a href="#2-2-请求方法" class="headerlink" title="2.2 请求方法"></a>2.2 请求方法</h3><ul>
<li>GET：用来请求已被uri识别的资源</li>
<li>POST：传输实体主体，get方法也可以传输实体的主体但是不常用，post的主要目的不是获取响应的主题内容</li>
<li>PUT：传输文件。但是http1.1的put方法没有验证机制存在安全问题，一般使用</li>
<li>HEAD：和get方法一样，只是不反回报文的主体</li>
<li>DELETE：删除文件；也存在安全问题，不使用</li>
<li>OPTIONS：询问支持的方法</li>
<li>TRACE：让 Web 服务器端将之前的请求通信环回给客户端的方法，不常用并且容易引发XST（跨站追踪）攻击</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信</li>
</ul>
<p>内容加 密后经网络隧道传输。</p>
<h3 id="2-3-请求首部字段"><a href="#2-3-请求首部字段" class="headerlink" title="2.3 请求首部字段"></a>2.3 请求首部字段</h3><p>用于补充请求的附加信息、客户端信息、对应响应内容的优先级等内容。</p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><p>客户端告诉服务器，自己能够处理的媒体类型以及类型的相对优先级，当服务器提供多种内容的时候，会首先返回权重最高的媒体类型</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accept: application&#x2F;json</span><br></pre></td></tr></table></figure>

<p>常用的媒体类型：</p>
<ul>
<li>文本文件： text/html，text/plain等</li>
<li>图片文件: image/jpeg, image/png等</li>
<li>视频文件: video/mpeg, video/mp4等</li>
<li>二进制文件: application/zip等</li>
</ul>
<h4 id="accept-charset"><a href="#accept-charset" class="headerlink" title="accept-charset"></a>accept-charset</h4><p>客户端通知服务器，自己支持的字符集及字符集的相对优先级</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, unicode-1-1;q&#x3D;0.8</span><br></pre></td></tr></table></figure>

<h4 id="accept-encoding"><a href="#accept-encoding" class="headerlink" title="accept-encoding"></a>accept-encoding</h4><p>客户端告诉服务器，自己支持的内容编码及内容编码的优先级</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accept-encoding: gzip, deflate, brs</span><br></pre></td></tr></table></figure>

<h4 id="accept-language"><a href="#accept-language" class="headerlink" title="accept-language"></a>accept-language</h4><p>客户端告诉服务器自己能够处理的自然语言以及相对优先级</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accept-language: zh-CN,zh;q&#x3D;0.9</span><br></pre></td></tr></table></figure>

<h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>客户端告诉服务器，请求的服务器所在的互联网主机名(即域名)和端口号，该字段必须被包含在请求头中。</p>
<h4 id="if-match"><a href="#if-match" class="headerlink" title="if-match"></a>if-match</h4><p>条件请求，当服务器收到带有这个字段的请求之后，会判断自己拥有的请求的资源的值是否与请求中的条件值一直，只有两者一致时，才会执行请求。与之相对的是if-no-match</p>
<h4 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h4><p>客户端告诉服务器这个请求是从哪个url发起的。</p>
<h3 id="2-4-请求主体"><a href="#2-4-请求主体" class="headerlink" title="2.4 请求主体"></a>2.4 请求主体</h3><h2 id="3-响应报文"><a href="#3-响应报文" class="headerlink" title="3 响应报文"></a>3 响应报文</h2><h3 id="3-1-响应报文结构"><a href="#3-1-响应报文结构" class="headerlink" title="3.1 响应报文结构"></a>3.1 响应报文结构</h3><ul>
<li>状态行：协议版本、状态码、原因短语</li>
<li>响应头：响应首部字段、通用首部字段、实体首部字段</li>
<li>空行</li>
<li>响应主体</li>
</ul>
<p>结构如下图：</p>
<p><img src="%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="响应报文结构"></p>
<h3 id="3-2-状态码"><a href="#3-2-状态码" class="headerlink" title="3.2 状态码"></a>3.2 状态码</h3><h4 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h4><p>表示请求被正常的处理了</p>
<ul>
<li>200: 表示从客户端发送来的请求在服务端被正常的处理了</li>
<li>204: 表示请求被正常的处理，但是响应的正文中没有数据</li>
<li>206: 当客户端是进行部分请求，且服务端正常的处理了该请求</li>
</ul>
<h4 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h4><p>表示客户端需要执行某些特殊的处理以正确的处理请求</p>
<ul>
<li>301: 永久重定向，表示请求的资源被分配了新的uri，客户端以后应该使用资源现在所指的uri</li>
<li>302: 临时重定向，表示请求的资源已经被分配了新的uri，希望用户本次使用新的uri</li>
<li>303: 功能同302，但是指定了要访问这个新的uri，需要使用get方法</li>
<li>304: 表示客户端请求的资源存在，但是客户端发送请求时设置的条件不满足</li>
</ul>
<h4 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h4><p>表示客户端是发生错误的原因所在</p>
<ul>
<li>400: 表示客户端发送的请求报文中存在语法错误</li>
<li>401: 表示客户端发送的请求需要通过http认证</li>
<li>403: 表示客户端发送的请求访问被服务器拒绝了</li>
<li>404: 表示服务器上无法找到客户端请求的资源</li>
<li>405: 请求的方法不被支持</li>
</ul>
<h4 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h4><p>表示服务器本身发生错误</p>
<ul>
<li>500: 表示服务器端在执行请求的时候发生了错误</li>
<li>502: 表示充当网关或者代理的服务器，从上游服务器接收到了一个非法的响应</li>
<li>503: 表示服务器现在无法处理请求，可能是处于超负荷或停机维护</li>
<li>504: Gateway Timeout  由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答</li>
</ul>
<h3 id="3-3-响应首部字段"><a href="#3-3-响应首部字段" class="headerlink" title="3.3 响应首部字段"></a>3.3 响应首部字段</h3><h4 id="etag"><a href="#etag" class="headerlink" title="etag"></a>etag</h4><p>服务器告诉客户端，实体的标识。服务器会为每一个资源分配一个etag</p>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>服务器端使用该字段，告诉客户端重定向的地址，配合响应码301，302使用</p>
<h4 id="vary"><a href="#vary" class="headerlink" title="vary"></a>vary</h4><p>服务器端告诉缓存服务器，只有当客户端的请求与这个值相同的时候才会将缓存的资源返回给客户端。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure>
<p>只有当客户端的请求中accept-language的值与缓存中资源的accept-language一致时才将缓存的数据返回。</p>
<h4 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h4><p>用于控制请求的资源页面在其他的web网站的frame标签内的显示问题，主要目的是为了防止点击劫持. 该字段有两个参数可选：</p>
<ul>
<li>deny：表示该请求得到的响应html，不能在frame中展示</li>
<li>SAMEORIGIN：表示该页面可以在相同域名页面的 frame 中展示</li>
</ul>
<h4 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h4><p>用于控制浏览器XSS防护机制的开关。浏览器内置了一个针对XSS攻击的防护机制，浏览器检测到了含有恶意代码的输入被呈现在HTML文档中，那么这段呈现的恶意代码要么被删除，要么被转义，恶意代码不会被正常的渲染出来。</p>
<ul>
<li>0: 表示将xss状态设置成无效状态，就是关闭浏览器的xss防护机制</li>
<li>1: 表示将xss状态设置成有效状态，如果检测到恶意代码就删除这个恶意代码, 这是浏览器的默认设置</li>
<li>1; mode=block：如果检测到恶意代码，在不渲染恶意代码</li>
</ul>
<h3 id="3-4-响应主体"><a href="#3-4-响应主体" class="headerlink" title="3.4 响应主体"></a>3.4 响应主体</h3><p>响应正文的压缩：</p>
<p>响应正文的分块发送：</p>
<h2 id="4-使用http与服务器的通信"><a href="#4-使用http与服务器的通信" class="headerlink" title="4 使用http与服务器的通信"></a>4 使用http与服务器的通信</h2><p>客户端与服务器进行通信的目的是<code>获取服务器上的资源</code>, 那么这个实际存放着资源的服务器才是客户端最终要访问的目标服务器。从客户端请求到最终的目标服务器的过程中，可能还会经过一些其他的服务器节点。</p>
<h3 id="4-1-单台服务器有多个域名"><a href="#4-1-单台服务器有多个域名" class="headerlink" title="4.1 单台服务器有多个域名"></a>4.1 单台服务器有多个域名</h3><p>当一个服务器和多个域名绑定的时候，此时这多个域名被DNS解析之后的ip地址是相同的，此时在发送http请求的时候，必须在host内部完整的指定主机名或者域名的url</p>
<h3 id="4-2-客户端与服务器端间有代理或者网关"><a href="#4-2-客户端与服务器端间有代理或者网关" class="headerlink" title="4.2 客户端与服务器端间有代理或者网关"></a>4.2 客户端与服务器端间有代理或者网关</h3><p>客户端与实际请求的服务器之间的通信不是直接的，而是通过代理或者网关服务器与实际请求的服务器进行间接的数据传输。</p>
<h4 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h4><p>所谓的代理服务器就是，接收客户端的请求并转发给实际的服务器，同时接收实际服务器的响应并转发给客户端。代理服务器可以分类如下：</p>
<ul>
<li>缓存代理: 预先将资源的副本保存在代理服务器上，当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</li>
<li>透明代理: 转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理</li>
</ul>
<p><img src="http-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="代理服务器"></p>
<h4 id="网关服务器"><a href="#网关服务器" class="headerlink" title="网关服务器"></a>网关服务器</h4><p>转发其他服务器<strong>通信数据</strong>的服务器，接收从客户端发送过来的请求的时候，就像自己是拥有资源的服务器一样对请求进行处理</p>
<p><img src="http-%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="网关服务器"></p>
<h2 id="5-通用首部字段"><a href="#5-通用首部字段" class="headerlink" title="5 通用首部字段"></a>5 通用首部字段</h2><p>这类字段在<code>请求的首部</code>和<code>响应的首部</code>都会使用。</p>
<h3 id="5-1-cache-control"><a href="#5-1-cache-control" class="headerlink" title="5.1 cache-control"></a>5.1 cache-control</h3><p>该字段中常用的指令及指令值如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cache-control: max-age&#x3D;0, private, must-revalidate</span><br></pre></td></tr></table></figure>

<p>带有缓存服务器时的请求流程：</p>
<p><img src="http-%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="请求流程"></p>
<p>该字段能够控制缓存的行为。客户端发送请求的时候携带该字段给缓存服务器发送指令，服务器返回响应携带该字段也给缓存服务器发送指令。该字段常用的指令参数有如下：</p>
<ul>
<li>public：服务器端告诉缓存服务器，这个缓存资源可以给任意的客户端</li>
<li>private：服务器端告知缓存服务器，这个缓存资源只可以给这个客户端</li>
<li>no-cache: <strong>客户端</strong>向服务器发送请求，使用该指令来告知缓存服务器不从缓存服务器获取数据，防止从缓存服务器中获取过期的资源；<strong>服务器</strong>向客户端发送响应使用该指令告知缓存服务器不能对资源进行缓存；</li>
<li>no-store: 该指令规定缓存不能在本地存储请求或响应的任一部分</li>
<li>max-age: 当<strong>客户端</strong>发送的请求中包含该指令的时候，缓存服务器会判断自己持有的资源的缓存时间是否比客户端携带的值小，如果小，就将该缓存的资源给客户端，当max-age=0时，缓存服务器通常将请求转发给实际资源服务器。当<strong>服务器端</strong>携带该指令的时候，表示缓存服务器需要将资源进行缓存，缓存的时间就是max-age设置的值。</li>
<li>only-if-cache: 客户端请求中使用此指令，表示如果缓存服务器有这个资源就返回，如果没有也不用向实际资源服务器去进行请求，而是给客户端响应504</li>
<li>must-revalidate: 客户端请求中使用此指令，表示缓存服务器准备将数据给客户端的时候，需要再次请求资源服务器以确定这个资源是否过期，如果缓存服务器请求资源服务器的时候出错, 就响应给客户端504</li>
<li>no-transform: 无论是客户端还是服务器端使用该指令，缓存服务器都不能改变实体主体的媒体类型，可防止缓存或代理压缩图片等类似操作</li>
</ul>
<h3 id="5-2-connection"><a href="#5-2-connection" class="headerlink" title="5.2 connection"></a>5.2 connection</h3><p>该字段有两个作用：</p>
<ul>
<li>控制不再转发给代理的首部字段：在该字段中指明的首部字段，在转发给代理服务器之前都要去掉。</li>
<li>管理持久连接：在http1.1中默认是持久连接，服务器端如果想断开连接则使用close指令，明确的告诉客户端想断开连接；http1.1之前默认是非持久连接，如果有想要使用持久连接，需要在请求中使用keep-alive指令</li>
</ul>
<h3 id="5-3-date"><a href="#5-3-date" class="headerlink" title="5.3 date"></a>5.3 date</h3><p>表示http报文的时间和日期</p>
<h3 id="5-4-pragma"><a href="#5-4-pragma" class="headerlink" title="5.4 pragma"></a>5.4 pragma</h3><p>这是一个遗留字段，为了兼容1.1之前的协议，在客户端的请求中使用此字段，告知缓存服务器，客户端不接收缓存的资源</p>
<h3 id="5-5-transfer-encoding"><a href="#5-5-transfer-encoding" class="headerlink" title="5.5 transfer-encoding"></a>5.5 transfer-encoding</h3><p>说明了传输报文时的编码方式</p>
<h3 id="5-6-upgrade"><a href="#5-6-upgrade" class="headerlink" title="5.6 upgrade"></a>5.6 upgrade</h3><p>用来检测是否可以使用更高版本的协议进行通信，在该字段后面指明想要使用的更高版本的协议。</p>
<h3 id="5-7-via"><a href="#5-7-via" class="headerlink" title="5.7 via"></a>5.7 via</h3><p>使用该字段是为了追踪客户端与服务器之间的请求和响应报文的传输路径。每经过一个代理服务器，代理服务器就会将自身的信息添加到via字段中，然后发送给下一个服务器。</p>
<h2 id="6-实体首部字段"><a href="#6-实体首部字段" class="headerlink" title="6 实体首部字段"></a>6 实体首部字段</h2><p>报文中实体部分使用的首字段。用于补充内容的更新时间等与实体相关的信息。</p>
<h3 id="6-1-content-encoding"><a href="#6-1-content-encoding" class="headerlink" title="6.1 content-encoding"></a>6.1 content-encoding</h3><p>服务器端告诉客户端，对实体部分使用的内容编码方式，主要使用的内容编码方式有：</p>
<ul>
<li>gzip</li>
<li>compress </li>
<li>deflate </li>
<li>identity</li>
</ul>
<h3 id="6-2-content-type"><a href="#6-2-content-type" class="headerlink" title="6.2 content-type"></a>6.2 content-type</h3><p>告知客户端，实体主体使用的自然语言</p>
<h3 id="6-3-Content-Location"><a href="#6-3-Content-Location" class="headerlink" title="6.3 Content-Location"></a>6.3 Content-Location</h3><p>当返回的页面内容与实际请求的对象不同 时，首部字段 Content-Location 内会写明 URI。</p>
<h3 id="6-4-content-type"><a href="#6-4-content-type" class="headerlink" title="6.4 content-type"></a>6.4 content-type</h3><p>首部字段 Content-Type 说明了实体主体内对象的媒体类型</p>
<h2 id="7-状态管理"><a href="#7-状态管理" class="headerlink" title="7 状态管理"></a>7 状态管理</h2><p>用来解决http无状态的缺点，因为http无状态，无法根据上次的请求来处理这次的请求，导致在<code>需要登录</code>的业务场景下，每一次的http请求都要进行再次登录。cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。</p>
<p>Cookie会根据从服务器端发送的<strong>响应报文内的一个叫做Set-Cookie的首部字段</strong>信息，通知客户端保存Cookie（服务器端生成，然后在响应报文的set-cookie字段中携带给客户端）。当下次客户端再往该服务器发送请求时，客户端会<strong>自动在请求报文中加入Cookie值</strong>后发送出去。服务器端发现客户端发送过来的 Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<p>与之相关的首部字段主要有：</p>
<ul>
<li><p>set-cookie: 用于响应首部字段; 用来通知客户端保存cookie，字段的属性：</p>
<ul>
<li>name=value: cookie名称和值</li>
<li>expire：cookie的有效期</li>
<li>path：cookie适用的对象即使用这个cookie可以访问哪些资源（如果不设置默认为文档所在的文件目录）</li>
<li>domain: cookie适用对象的域名</li>
<li>httponly： cookie不能被JavaScript脚本访问</li>
</ul>
</li>
<li><p>cookie: 用于请求首部字段, 首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收 到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>
</li>
</ul>
<h2 id="8-https"><a href="#8-https" class="headerlink" title="8 https"></a>8 https</h2><h3 id="8-1-http存在的问题及https解决的方案"><a href="#8-1-http存在的问题及https解决的方案" class="headerlink" title="8.1 http存在的问题及https解决的方案"></a>8.1 http存在的问题及https解决的方案</h3><h4 id="通信使用明文"><a href="#通信使用明文" class="headerlink" title="通信使用明文"></a>通信使用明文</h4><p>该问题在https中是怎么解决的呢？</p>
<ul>
<li>在https中使用了ssl或者tls将传输的明文数据进行加密</li>
</ul>
<h4 id="不验证通信双发的身份"><a href="#不验证通信双发的身份" class="headerlink" title="不验证通信双发的身份"></a>不验证通信双发的身份</h4><p>客户端如果遇到假的服务器怎么办？服务器如果遇到假的客户端怎么办？服务器无法确定客户端是否有权限访问某个资源？</p>
<p>针对上述问题https怎么解决呢？</p>
<ul>
<li>使用ssl解决，因为ssl在提供加密的同时也提供了一种叫做证书的东西。</li>
<li>客户端在请求服务器的时候使用证书确定自己访问的服务器是不是假的。</li>
<li>服务器在收到请求的时候使用证书判断发送该请求的客户端是不是假的</li>
</ul>
<h4 id="无法验证通信中的报文是否被篡改"><a href="#无法验证通信中的报文是否被篡改" class="headerlink" title="无法验证通信中的报文是否被篡改"></a>无法验证通信中的报文是否被篡改</h4><p>https怎么解决？</p>
<ul>
<li>ssl提供的摘要功能</li>
</ul>
<h3 id="8-2-ssl和tls"><a href="#8-2-ssl和tls" class="headerlink" title="8.2 ssl和tls"></a>8.2 ssl和tls</h3><p>通常htt和tcp直接通信，当使用了ssl之后就是http先和ssl通信，然后由ssl和tcp通信。SSL是最早由网景公司开发，回来交给了IETF，IETF以ssl3.0为基础，制定了TLS1.0、TLS1.1，TLS1.2。当前主流的版本是SSL3.0和TLS1.0</p>
<p><img src="ssl%E9%80%9A%E4%BF%A1.png" alt="使用ssl通信"></p>
<h3 id="8-3-https"><a href="#8-3-https" class="headerlink" title="8.3 https"></a>8.3 https</h3><p>先了解一下基本的加密概念: </p>
<ul>
<li>加密和解密使用同一个秘钥的加密方式叫做<strong>对称加密</strong>;</li>
<li>加密和解密不使用同一个秘钥，而是使用两个，一个叫做<strong>公钥</strong>，一个叫做<strong>私钥</strong>，加密的时候使用公钥加密，解密的时候使用私钥，这种加密方式称为<strong>非对称加密</strong>。其中公钥可以给任何人，但是私钥不能让其他人知道。</li>
</ul>
<p>https使用上述的两种方式混合:</p>
<ul>
<li>在通信的双方<strong>交换密钥环节</strong>(这里交换的秘钥是<code>通信阶段报文加密的秘钥</code>)使用公开密钥加密(非对称加密)方式</li>
<li>之后的建立通信<strong>交换报文阶段</strong>则使用共享密钥加密(对称加密)方式。</li>
</ul>
<h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>假如正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥, 或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。如何解决这个问题？</p>
<ul>
<li>使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书</li>
<li>服务器会将这份由数字证书认证机构颁发的<strong>公钥证书</strong>发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。</li>
<li>客户端收到证书之后可使用<code>数字证书认证机构的公开密钥</code>，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：<ul>
<li>认证服务器的公开密钥的是真实有效的数字证书认证机构。</li>
<li>服务器的公开密钥是值得信赖的。</li>
</ul>
</li>
</ul>
<p>怎么获取这个证书?</p>
<ul>
<li>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。</li>
<li>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名(数字签名的实现：数字认证机构用自己的<strong>私有密钥</strong>向服务器的公开密钥签名)，然后分配这个<strong>已签名的公开密钥</strong>，并将该公开密钥放入公钥证书后绑定在一起。</li>
</ul>
<p><strong>数字证书认证机构的公开秘钥</strong>：认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的<strong>公开密钥</strong>(这个公开密钥来验证服务器的数字签名)。</p>
<h4 id="https的通信过程"><a href="#https的通信过程" class="headerlink" title="https的通信过程"></a>https的通信过程</h4><p>通信的过程包含两个部分：</p>
<ul>
<li>获取把报文使用对称加密时加密的密钥, ssl握手协商部分</li>
<li>通信双方交换数据</li>
</ul>
<p>ssl握手协商部分:</p>
<ul>
<li>首先，客户端发送client hello报文，通过该报文告诉服务器自己使用的ssl版本、自己支持的加密算法和秘钥长度列表</li>
<li>服务器端收到之后，回复给客户端server hello报文, 通过该报文告诉客户端自己选择了他发送过来的加密算法和密钥长度是什么</li>
<li>紧接着，服务器端发送certificate报文，在该报文中将自己的证书发送给客户端，证书中包含<strong>公钥</strong></li>
<li>随后，服务器端会发送server hello done报文，使用该报文通知客户端，自己这边已经完事。</li>
<li>客户端收到上述的三个报文之后, 以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。注意这是的报文已经使用，上述确定的<strong>公钥</strong>和<strong>加密算法</strong>进行加密</li>
<li>接着客户端继续发送Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用<strong>Pre-master secret密钥</strong>（这个密钥就是对称加密的密钥）加密报文交换阶段的数据</li>
<li>随后客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。 </li>
<li>之后, 服务器同样发送Change Cipher Spec报文。</li>
<li>最后，服务器发送Finished报文。</li>
</ul>
<p>通信双发交换数据部分：</p>
<ul>
<li>客户端使用上述协商好的密钥对发送的数据进行加密 </li>
<li>服务器端也使用上述协商好的密钥对客户端发送的数据进行解密，并将自己要发送的数据采用这个密钥进行</li>
</ul>
<h3 id="8-4-nginx配置https"><a href="#8-4-nginx配置https" class="headerlink" title="8.4 nginx配置https"></a>8.4 nginx配置https</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen        443 ssl;                                                 </span><br><span class="line">      server_name    www.****.com;#域名                         </span><br><span class="line">      ssl_certificate      ssl&#x2F;nginx.crt;#证书路径     </span><br><span class="line">      ssl_certificate_key  ssl&#x2F;nginx.key;#key路径             </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-http升级"><a href="#9-http升级" class="headerlink" title="9 http升级"></a>9 http升级</h2><h3 id="9-1-http的性能问题及解决方案"><a href="#9-1-http的性能问题及解决方案" class="headerlink" title="9.1 http的性能问题及解决方案"></a>9.1 http的性能问题及解决方案</h3><ul>
<li>一条连接，在同一时刻只能发送一个请求</li>
<li>请求只能从客户端开始</li>
<li>请求和响应的首部发送的时候没有经过压缩</li>
<li>每次交互发送的首部字段太长，造成浪费</li>
<li>可任意选择压缩格式，非强制压缩发送</li>
</ul>
<h4 id="spdy协议"><a href="#spdy协议" class="headerlink" title="spdy协议"></a>spdy协议</h4><p>spyd协议介于ssl和http之间，属于会话层。该协议实现了如下的功能：</p>
<ul>
<li>多路复用：通过一个tcp连接可以处理多个http请求</li>
<li>压缩http首部</li>
<li>推送功能，可以实现服务器向客户端主动推送数据</li>
</ul>
<p>spdy存在的问题：</p>
<ul>
<li>它的多路复用，只是将单个域名进行了多路复用，当一个网站上使用多个域名的时候，效果受到限制</li>
</ul>
<h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><p>功能：</p>
<ul>
<li>支持服务器向客户端推送数据</li>
<li>通信过程中的数据量也减少了</li>
</ul>
<p>websocket连接的建立</p>
<ul>
<li>它的建立是在http连接建立之后</li>
<li>通过发送一个http请求, 在upgrade首部字段使用<code>websocket</code>, 询问服务器是否可以使用这个高版本的协议</li>
<li>如果服务器支持使用websocket会发送响应报文，状态码为101</li>
<li>成功确立了websocket连接之后，通信时就不适用http协议而是使用websocket独立的数据帧</li>
</ul>
<p>http请求报文</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/1.1 </span><br><span class="line"><span class="attribute">Host</span>: server.example.com </span><br><span class="line"><span class="attribute">Upgrade</span>: websocket </span><br><span class="line"><span class="attribute">Connection</span>: Upgrade </span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ== </span><br><span class="line"><span class="attribute">Origin</span>: http://example.com </span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat </span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure>

<p>http响应报文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols </span><br><span class="line">Upgrade: websocket </span><br><span class="line">Connection: Upgrade </span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D; </span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<h3 id="9-2-http2-0"><a href="#9-2-http2-0" class="headerlink" title="9.2 http2.0"></a>9.2 http2.0</h3><h2 id="10-web安全问题"><a href="#10-web安全问题" class="headerlink" title="10 web安全问题"></a>10 web安全问题</h2><h3 id="10-1-xss"><a href="#10-1-xss" class="headerlink" title="10.1 xss"></a>10.1 xss</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>跨站脚本攻击，恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的</p>
<h4 id="怎么防御"><a href="#怎么防御" class="headerlink" title="怎么防御"></a>怎么防御</h4><h3 id="10-2-跨站点请求伪造"><a href="#10-2-跨站点请求伪造" class="headerlink" title="10.2 跨站点请求伪造"></a>10.2 跨站点请求伪造</h3><p>csrf, 是什么？怎么防御？</p>
<h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><ul>
<li>用户已经登录了站点 A，并在本地记录了 cookie</li>
<li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点B</li>
<li>B站点要求访问站点A</li>
</ul>
<h4 id="怎么防御-1"><a href="#怎么防御-1" class="headerlink" title="怎么防御"></a>怎么防御</h4><p>在服务端进行预防, 对客户端发送的请求进行验证，判断客户端是不是非法的客户端。</p>
<h3 id="10-3-sql注入"><a href="#10-3-sql注入" class="headerlink" title="10.3 sql注入"></a>10.3 sql注入</h3><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h4><h4 id="怎么防御-2"><a href="#怎么防御-2" class="headerlink" title="怎么防御"></a>怎么防御</h4><ul>
<li>对进入数据库的特殊字符进行转移处理</li>
<li>参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《图解http》</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>go框架-gin</title>
    <url>/2020/01/31/go%E6%A1%86%E6%9E%B6-gin/</url>
    <content><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h2><p>安装gin框架</p>
<p><code>go get -u github.com/gin-gonic/gin</code></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础</title>
    <url>/2020/01/29/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文简单的记录了go语言的基础知识。</p>
<a id="more"></a>
<h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>去官网直接下载，然后进行安装。安装完成之后需要配置环境变量。配置<code>GOROOT</code>和<code>GOPATH</code>。其中的GOROOT是go的安装路径，GOPATH是go项目路径。<br>安装完成之后使用<code>go env</code>命令来检测安装</p>
<h3 id="go源码文件分类"><a href="#go源码文件分类" class="headerlink" title="go源码文件分类"></a>go源码文件分类</h3><p><strong>命令源码文件</strong></p>
<p>该文件属于main包，并且有main函数</p>
<p><strong>库源码文件</strong></p>
<p>不属于命令源码文件的普通源码文件</p>
<p><strong>测试源码文件</strong></p>
<p>文件名：以_test.go为后缀</p>
<p>文件中的函数名：以Testxxx、或者Benchmarkxxx为前缀</p>
<h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><p><code>go build</code>: 用来进行编译。</p>
<ul>
<li>默认编译目录下的所有的go文件（不包含以_或者.开头的头go文件），</li>
<li>如果执行编译一个指定的文件，可以使用<code>go build 文件名</code>。</li>
<li>如果编译的是普通的包，执行了go build命令之后不会产生任何的文件，如果是main包执行了该命令之后，会在当前目录下生成一个可执行文件。</li>
<li>当代码包中有且只有一个命令源码文件的时候，在目录下执行go build命令，会在该目录下生成一个和目录名同名的可执行文件。</li>
</ul>
<p><code>go get</code>: 从远程代码仓库上下载并安装代码包。</p>
<ul>
<li><p><code>go install</code>: 用来编译并安装代码包或者源码文件</p>
</li>
<li><p>第一步：生成结果文件（可执行文件或者.a包）</p>
<ul>
<li>可执行文件：一般是带main函数的go文件生成的</li>
<li>.a文件：一般是不包含main函数的go文件产生的，没有函数入口，只能被调用</li>
</ul>
</li>
<li><p>第二步：把编译好的结果一道<code>$GOPATH/pkg</code>或者<code>$GOPATH/bin</code>目录下</p>
</li>
</ul>
<p><code>go run</code>: 该命令不是用来运行所有的go源码文件的，它只能用来运行<strong>命令源码文件</strong>, 不能运行测试源码文件</p>
<h2 id="1-变量和常量"><a href="#1-变量和常量" class="headerlink" title="1 变量和常量"></a>1 变量和常量</h2><h3 id="1-1-变量的定义"><a href="#1-1-变量的定义" class="headerlink" title="1.1 变量的定义"></a>1.1 变量的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1： 先定义，然后在进行赋值</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">name = <span class="string">"cody"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：定义的同时进行赋值</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"cody"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：定义的时候进行赋值，不指定类型，使用类型推导</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"cody"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：不使用var关键字, 简短声明</span></span><br><span class="line">name := <span class="string">"cody"</span></span><br></pre></td></tr></table></figure>

<p>使用简短声明注意：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 必须有一个是新声明的</span></span><br><span class="line">name, sex, age := <span class="string">"cody"</span>, <span class="string">"male"</span>, <span class="number">10</span> </span><br><span class="line"><span class="comment">// 2. 不能声明全局的变量</span></span><br></pre></td></tr></table></figure>

<p>如果一个变量只进行了声明，没有进行赋值，那么在go语言中默认为对应类型的零值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> <span class="comment">// 默认值为''</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> <span class="comment">// 默认值为0</span></span><br><span class="line"><span class="keyword">var</span> isExist <span class="keyword">bool</span> <span class="comment">// 默认为false</span></span><br><span class="line"><span class="keyword">var</span> pointer *<span class="keyword">int</span> <span class="comment">// 默认为nil</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-常量的定义"><a href="#1-2-常量的定义" class="headerlink" title="1.2 常量的定义"></a>1.2 常量的定义</h3><p>常量一旦定义了之后，就不能改变</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义常量</span></span><br><span class="line"><span class="keyword">const</span> LENGTH <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义一组常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    NAME = <span class="string">"cody"</span></span><br><span class="line">    AGE = <span class="number">10</span></span><br><span class="line">    SEX = <span class="string">'f'</span></span><br></pre></td></tr></table></figure>

<p>定义一组常量如果这个常量没有初始值，那么这个常量的默认值和上一个常量相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    NAME = <span class="string">"cody"</span></span><br><span class="line">    AGE <span class="comment">// 默认值为cody</span></span><br><span class="line">    SEX = <span class="string">'f'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>枚举类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SPRING = <span class="number">1</span></span><br><span class="line">    SUMMER = <span class="number">2</span></span><br><span class="line">    AUTUMN = <span class="number">3</span></span><br><span class="line">    WINTER = <span class="number">4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>iota常量: 可以认为是一个可以被编译器进行修改的常量, 每当定义一个常量<code>iota</code>的值就加1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    b = <span class="literal">iota</span> <span class="comment">// 1</span></span><br><span class="line">    c = <span class="literal">iota</span> <span class="comment">// 2</span></span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		A = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">		B <span class="comment">// 1</span></span><br><span class="line">		C <span class="comment">// 2</span></span><br><span class="line">		D = <span class="string">"hello"</span> <span class="comment">// hello, iota = 3</span></span><br><span class="line">		E <span class="comment">// hello iota = 4</span></span><br><span class="line">		F = <span class="number">100</span> <span class="comment">// 100, iota = 5</span></span><br><span class="line">		G <span class="comment">// 100 , iota = 6</span></span><br><span class="line">		H = <span class="literal">iota</span> <span class="comment">// iota = 7 </span></span><br><span class="line">		I <span class="comment">// 8</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><strong>布尔</strong></p>
<p>bool</p>
<p><strong>数值</strong></p>
<p>int8, int16, int32, int64, int</p>
<p>float32, float64</p>
<p>….</p>
<p>byte: uint8</p>
<p>rune: int32</p>
<p><strong>字符串</strong></p>
<p>多个字节的集合, go中的字符都是utf-8的编码值, go中的字符串就是字符的集合即每个字符的utf-8编码值的集合。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"cody"</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">`cody`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单引号和双引号的区别</span></span><br><span class="line">s1 := <span class="string">'A'</span></span><br><span class="line">s2 := <span class="string">"A"</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%T, %d\n"</span>, s1, s1) <span class="comment">// int32, 65</span></span><br><span class="line">fmt.Printf(<span class="string">"%T, %s\n"</span>, s2, s2) <span class="comment">// string A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中文编码</span></span><br><span class="line">s3 := <span class="string">'中'</span></span><br><span class="line">fmt.Printf(<span class="string">"%T, %d, %c, %q\n"</span>, s3, s3, s3, s3) <span class="comment">// int32, 20013, 中, '中'</span></span><br><span class="line"></span><br><span class="line">s4 := <span class="string">`"hello world"`</span></span><br><span class="line">fmt.Println(s4) <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>

<p>字符串的操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">"hello world"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1)) <span class="comment">// len() 计算的是字节的个数，对于英文字符，每个字符占用一个字节，而每一个中文一般占三个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串是字节的集合</span></span><br><span class="line">slice1 := []<span class="keyword">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>&#125;</span><br><span class="line">s3 := <span class="keyword">string</span>(slice1) <span class="comment">// 字节切片转为字符串</span></span><br><span class="line">fmt.Println(s3)</span><br><span class="line"></span><br><span class="line">s4 := <span class="string">"abcde"</span></span><br><span class="line">slice2 := []<span class="keyword">byte</span>(s4) <span class="comment">// 字符串转为字节切片</span></span><br><span class="line">fmt.Println(slice2)</span><br></pre></td></tr></table></figure>

<p>字符串常用的包</p>
<p><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">strings包，字符串常用的操作</a></p>
<p><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">strconv包，字符串和其他类型的转换</a></p>
<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p><strong>array</strong></p>
<ul>
<li>类型是：<code>[size]type</code></li>
<li>值传递: 将数组类型的变量传递给其他的变量，传递的是副本</li>
<li>数组比较：使用<code>==</code>号比较, 比较的两个数组必须是相同的类型，比较的是数组中对应下标的值是否相等</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：定义数组</span></span><br><span class="line"><span class="comment">// 声明数组</span></span><br><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 数组赋值</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    array[i] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：定义数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 [<span class="number">4</span>]<span class="keyword">int</span> = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">13</span>&#125; <span class="comment">// 其他的初始值为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125; <span class="comment">// 不指定元素的个数，根据后面的元素个数自动推导</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法5</span></span><br><span class="line">arr6 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">10</span>, <span class="number">9</span>:<span class="number">23</span>&#125; <span class="comment">// 给指定位置赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> i, e := <span class="keyword">range</span> arr1 &#123;</span><br><span class="line">    fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span> = [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;&#125; <span class="comment">// 3个一维数组，数组中的每个一个数组的长度为4</span></span><br></pre></td></tr></table></figure>

<p><strong>slice</strong></p>
<ul>
<li>类型：<code>[]type</code></li>
<li>切片是引用类型, 动态数组可以自动扩容(2倍增长)</li>
<li>引用传递: 传递的是地址</li>
<li>切片存储的是内存地址，实际存储数据的是底层的数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">int</span> = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">var</span> slice2 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">slice4 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>) <span class="comment">// make是专门用来创建引用类型的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line">slice5 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式4：基于数组创建切片</span></span><br><span class="line">array := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice6 := array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">slice5 = <span class="built_in">append</span>(slice5, <span class="number">10</span>) <span class="comment">// 向slice5末尾添加元素10</span></span><br><span class="line">slice5 = <span class="built_in">append</span>(slice5, slice4...) <span class="comment">// 将slice4中的元素追加到slice5中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy()内置函数实现深拷贝</span></span><br><span class="line">slice7 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(slice5, slice7) <span class="comment">// 将slice7中的元素，拷贝到slice5中</span></span><br></pre></td></tr></table></figure>

<p><strong>map</strong></p>
<ul>
<li>类型：map[keyType]valueType</li>
<li>引用传递</li>
</ul>
<p>定义变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> <span class="comment">// map1 == nil</span></span><br><span class="line">map1 = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">map2 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line">map3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>) <span class="comment">// map3 != nil</span></span><br></pre></td></tr></table></figure>

<p>基本操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map4 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">map4[<span class="number">1</span>] = <span class="string">"hello"</span></span><br><span class="line">map4[<span class="number">2</span>] = <span class="string">"world"</span></span><br><span class="line">fmt.Println(map4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">fmt.Println(map4[<span class="number">20</span>]) <span class="comment">// key不存在，获取的是对应类型的零值</span></span><br><span class="line"><span class="keyword">if</span> value, ok := map4[<span class="number">10</span>]; ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key exist, value is "</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key is not exist"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">map4[<span class="number">5</span>] = <span class="string">"cody"</span> <span class="comment">// 如果key存在就是修改，如果key不存在就是添加</span></span><br><span class="line">fmt.Println(map4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="built_in">delete</span>(map4, <span class="number">5</span>) <span class="comment">// 如果key存在就删除，如果key不存在没有影响</span></span><br><span class="line">fmt.Println(map4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 使用range map</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> map4 &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(map4); i++ &#123;</span><br><span class="line">    fmt.Println(map4[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>function</strong></p>
<p><strong>pointer</strong></p>
<ul>
<li>类型: *type</li>
<li>引用传递</li>
<li>指针一般用于值传递类型的变量: 数组、结构体、以及基础数据类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pointer *<span class="keyword">int</span></span><br><span class="line">	fmt.Println(pointer)</span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, pointer)</span><br><span class="line"></span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"a的地址：%p\n"</span>, &amp;a)</span><br><span class="line">	pointer = &amp;a</span><br><span class="line">	fmt.Println(<span class="string">"pointer的值"</span>, pointer)</span><br><span class="line">	fmt.Printf(<span class="string">"pointer的地址: %p\n"</span>, &amp;pointer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取指针指向的地址的值</span></span><br><span class="line">	fmt.Println(*pointer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>struct</strong></p>
<ul>
<li>值传递</li>
</ul>
<p>结构体的定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span> <span class="comment">// 成员变量, 首字母大小写控制访问权限</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体变量</span></span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line"><span class="keyword">var</span> p1 Person</span><br><span class="line">p1.name = <span class="string">"jack"</span></span><br><span class="line">p1.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">p2 := Person&#123;</span><br><span class="line">    name: <span class="string">"cody"</span>,</span><br><span class="line">    age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p2)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3</span></span><br><span class="line"><span class="keyword">var</span> p3 = Person&#123;&#125;</span><br><span class="line">p3.name = <span class="string">"lucy"</span></span><br><span class="line">p3.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4</span></span><br><span class="line">p4 := Person&#123;<span class="string">"tom"</span>, <span class="number">20</span>&#125;</span><br><span class="line">fmt.Println(p4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法5: new()内置函数，用来创建某种类型的指针</span></span><br><span class="line">p5 := <span class="built_in">new</span>(Person) <span class="comment">// 指针类型: 先创建一个Person的内存空间，然后将该空间的地址赋值给p5</span></span><br><span class="line">p5.name = <span class="string">"cat"</span></span><br><span class="line">p5.age = <span class="number">2</span></span><br><span class="line">fmt.Println(p5)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体指针</span></span><br><span class="line"><span class="keyword">var</span> p *Person</span><br><span class="line">p = &amp;p2</span><br><span class="line"></span><br><span class="line">fmt.Println((*p).name) <span class="comment">// 等价于p.name</span></span><br><span class="line">fmt.Println((*p).age)</span><br><span class="line"></span><br><span class="line">fmt.Println(p.name) <span class="comment">// 成员变量的访问</span></span><br><span class="line">fmt.Println(p.age)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>new的使用说明</p>
<ul>
<li>new是一个内置函数，用来创建对应类型的指针 new(type)</li>
<li>使用new创建出来的指针不是nil，对应的内存里面的数据是对应类型的零值</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(INT) <span class="comment">// 通过new创建出来的不是nil，里面存的数据为对应类型的零值</span></span><br><span class="line">*p = <span class="number">20</span></span><br><span class="line">fmt.Println(p)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p)</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure>

<p>匿名结构体, 所谓的匿名结构体就是结构体没有名字, 定义如下: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;<span class="string">"cody"</span>, <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>

<p>结构体中的匿名字段, 如果结构体中的字段是匿名的那么默认使用数据类型作为名字, 但是匿名字段的类型不能重复</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := Person&#123;<span class="string">"hello"</span>, <span class="number">10</span>&#125; <span class="comment">// </span></span><br><span class="line">fmt.Println(p.<span class="keyword">string</span>) <span class="comment">// 使用string数据类型作为名字</span></span><br><span class="line">fmt.Println(p.<span class="keyword">int</span>) <span class="comment">// 使用int数据类型作为名字</span></span><br></pre></td></tr></table></figure>

<p>结构体的嵌套</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值类型的嵌套</span></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	price <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">	book Book</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := Book&#123;</span><br><span class="line">		name:  <span class="string">"少年派的奇幻漂流"</span>,</span><br><span class="line">		price: <span class="number">23.5</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	s := Student&#123;</span><br><span class="line">		name: <span class="string">"cody"</span>,</span><br><span class="line">		age:  <span class="number">10</span>,</span><br><span class="line">		book: b,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问嵌套结构体的变量</span></span><br><span class="line">	fmt.Println(s.name)</span><br><span class="line">	fmt.Println(s.book.name)</span><br><span class="line"></span><br><span class="line">	s2 := Student&#123;</span><br><span class="line">		name: <span class="string">"lucy"</span>,</span><br><span class="line">		age:  <span class="number">0</span>,</span><br><span class="line">		book: Book&#123;<span class="string">"我的世界"</span>, <span class="number">2.0</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(s2.book.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体类型的嵌套, 使用指针，可以节省内存 </span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">	book *Book</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	book := Book&#123;<span class="string">"少年张三丰"</span>, <span class="number">12.5</span>&#125;</span><br><span class="line"></span><br><span class="line">	person := Person&#123;</span><br><span class="line">		name: <span class="string">"张三丰"</span>,</span><br><span class="line">		age:  <span class="number">208</span>,</span><br><span class="line">		book: &amp;book,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(person.book.name)</span><br><span class="line"></span><br><span class="line">	book.name = <span class="string">"中年张三丰"</span></span><br><span class="line">	fmt.Println(person.book.name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>interface</strong></p>
<p>接口是用来定义对象的行为的, 就如同struct是用来定义对象的属性的. 在Go中接口是一组方法的签名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Computer <span class="keyword">interface</span> &#123;</span><br><span class="line">    watchMovie() <span class="comment">// 接口方法</span></span><br><span class="line">    listenMusic() <span class="comment">// 接口方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空接口, 所有类型都实现了空接口，因此空接口可以用来存储任意类型的数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a A = Person&#123;<span class="string">"cody"</span>&#125; <span class="comment">// 空接口可以存储任意类型的数值</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口使用作为函数的参数，用来表示一个函数可以接收任意类型的数据</span></span><br><span class="line"><span class="comment">// 匿名空接口 interface&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的嵌套</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的嵌套</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123;</span><br><span class="line">	test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123;</span><br><span class="line">	test2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"test1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"test2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">test3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"test3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">interface</span> &#123;</span><br><span class="line">	A</span><br><span class="line">	B</span><br><span class="line">	test3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cat := Cat&#123;&#125;</span><br><span class="line">	cat.test1()</span><br><span class="line">	cat.test2()</span><br><span class="line">	cat.test3()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a A = cat</span><br><span class="line">	a.test1()</span><br><span class="line">	<span class="keyword">var</span> b B = cat</span><br><span class="line">	b.test2()</span><br><span class="line">	<span class="keyword">var</span> c C = cat</span><br><span class="line">	c.test1()</span><br><span class="line">	c.test2()</span><br><span class="line">	c.test3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的断言, 因为对于一个函数的形参是空接口类型的时候，需要在函数中需要对形参进行断言，从而得到真实的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">instance := 接口对象.(实际类型) <span class="comment">// 会panic</span></span><br><span class="line">instance, ok := 接口对象.(实际类型) <span class="comment">// 不会panic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="keyword">switch</span> instance := 接口对象.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> 实际类型<span class="number">1</span>：</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    <span class="keyword">case</span> 实际类型<span class="number">2</span>：</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>channel</strong></p>
<p>channel用来goroutine之间的通信.</p>
<ul>
<li>类型：<code>chan type</code> // 只能用来存放type类型的数据</li>
</ul>
<p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 声明一个channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>channel中数据读写, 向channel写入和读取数据会导致goroutine阻塞, 从一个goroutine向channel中写入数据的时候需要另一个goroutine从该channel中读取数据才会解除阻塞；一个goroutine的从channel读取数据的时候需要另一个goroutine向该channel中写入数据才会解除阻塞。channel中数据的写入和发送必须在不同的goroutine中进行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 向channel中写入数据，只能是int类型的数据</span></span><br><span class="line">num := &lt;-ch <span class="comment">// 从channel中读取数据</span></span><br><span class="line">num ok := &lt;-ch <span class="comment">// 使用ok判断是否channel已经关闭, 如果ok==false表示正在从一个关闭的channel中读取数据</span></span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 关闭channel</span></span><br></pre></td></tr></table></figure>

<p>channel的类型</p>
<ul>
<li>不带缓冲的channel</li>
<li>带缓冲的channel <code>ch := make(chan int, 10)</code> , 该类型的通道只有缓冲区满了的时候才会阻塞。</li>
</ul>
<p>单向channel和双向channel，能够写入和读出的channel是双向channel，只能够读或者写的channel是单向channel；一般是创建的时候，创建一个双向的通道，然后在函数调用中限制传参的类型来进行处理, 将双向的通道传入函数中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个单向的channel</span></span><br><span class="line">	<span class="comment">//ch1 := make(chan&lt;- int) // 只能写不能读</span></span><br><span class="line">	<span class="comment">//ch2 := make(&lt;-chan int) // 只能读不能写</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个双向的通道</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> func1(ch)</span><br><span class="line">	<span class="keyword">go</span> func2(ch)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能操作写的channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 单向写channel的定义</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能操作读的channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 单向读channel的定义</span></span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>基本语法：Type(value), 转换只能是兼容类型才能够进行转换，不是所有的类型都能够进行转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line">b = <span class="keyword">string</span>(a)</span><br></pre></td></tr></table></figure>

<h4 id="type关键字"><a href="#type关键字" class="headerlink" title="type关键字"></a>type关键字</h4><p>使用type用来</p>
<ul>
<li>定义新的类型: <code>type 新的类型 类型</code>, 新的类型和类型不能通用</li>
<li>给类型起别名: <code>type 别名 = 类型</code> 别名和类型可以通用. 在1.9版本中增加的. 注意在能够随意的为各种类型起名字，但是不能在自己包里面为这些类型添加方法。给结构体起别名，可以同时嵌入到结构体成员在中, 但是使用属性和方法的时候需要明确指明。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> INT <span class="keyword">int</span> <span class="comment">// 定义一个新的类型INT</span></span><br><span class="line"><span class="keyword">type</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> // 定义一个新的函数类型</span></span><br><span class="line"><span class="keyword">type</span> MYINT = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">c := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a INT</span><br><span class="line"><span class="comment">// a = c // 不可以赋值, 类型不一样</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b MYINT</span><br><span class="line">b = c <span class="comment">// 可以赋值</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体嵌套的别名</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> People = Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    s.Person.name = <span class="string">"cody"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-逻辑控制"><a href="#2-逻辑控制" class="headerlink" title="2 逻辑控制"></a>2 逻辑控制</h2><h3 id="2-1-选择"><a href="#2-1-选择" class="headerlink" title="2.1 选择"></a>2.1 选择</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最基本的if语句</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">20</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"a is bigger than 20"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"a is smaller than 20"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if语句的其他写法: </span></span><br><span class="line"><span class="comment">// if expression; condition &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">20</span>; num &gt; <span class="number">10</span> &#123; <span class="comment">// num的作用域是if语句中</span></span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>每个case语句后面默认有个一个break语句, 也可以手动显示的书写; <code>fallthrough</code>穿透，如果fallthrough所在的case语句得到了执行，那么它后面的case语句不进行匹配了直接进行执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. switch后面有tag</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">    fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. switch后面无tag, 此时默认为true，将case后面的表达式与true进行比较</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> a &gt; <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">case</span> a &lt; <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用break</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    fmt.Println(<span class="string">"扯犊子"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"扯犊子"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    fmt.Println(<span class="string">"扯犊子"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">    fmt.Println(<span class="string">"扯淡...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用fallthrough实现switch的穿透</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">"fallthrough"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span> <span class="comment">// 执行其后面的case语句, 只能在最后一个语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">29</span>:</span><br><span class="line">    fmt.Println(<span class="string">"false case"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">123</span>:</span><br><span class="line">    fmt.Println(<span class="string">"case 123"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>专门用于channel中</p>
<h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><p>for实现循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. for循环方式1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. for循环方式2</span></span><br><span class="line">i := <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">0</span> &#123; <span class="comment">// 类似于其他语言的while</span></span><br><span class="line">    fmt.Println(<span class="string">"world"</span>)</span><br><span class="line">    i--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. for循环方式3</span></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// wile(true)</span></span><br><span class="line">    fmt.Println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><h3 id="3-1-定义和调用"><a href="#3-1-定义和调用" class="headerlink" title="3.1 定义和调用"></a>3.1 定义和调用</h3><ul>
<li>函数的类型: func(typ1, typ2) (type3, type4)</li>
</ul>
<p><strong>函数定义语法</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(p1 type1, p2 type2)</span> <span class="params">(type3, type4)</span></span> &#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数返回值：</p>
<ul>
<li>如果只有一个返回值可以不使用括号, 如果指明了返回的变量是哪一个需要使用()</li>
<li>可以在函数定义的时候指明返回的数据是哪一个, 相当于先在函数中定义了这个变量, 初始为类型对应的零值</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(a, b)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    <span class="comment">// 或者 </span></span><br><span class="line">    <span class="comment">// return sum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数的调用语法</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r1, r2 := funcName(p1, p2)</span><br></pre></td></tr></table></figure>

<p><strong>可变参数</strong></p>
<ul>
<li>可变参数：接收的类型是切片</li>
<li>将可变参数放在参数列表的最后</li>
<li>参数列表中，最多一个可变参数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(a <span class="keyword">int</span>, args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-匿名函数"><a href="#3-2-匿名函数" class="headerlink" title="3.2 匿名函数"></a>3.2 匿名函数</h3><p>没有名字的函数，通常这个匿名函数只能调用一次，但是如果将匿名函数赋值给一个变量，那么可以实现多次调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名函数的定义和调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 匿名函数体</span></span><br><span class="line">&#125;() <span class="comment">// 使用()调用匿名函数</span></span><br></pre></td></tr></table></figure>

<p><strong>匿名函数的作用</strong></p>
<ol>
<li>使用匿名函数实现回调函数和高阶函数</li>
</ol>
<p>函数1和函数2, 如果把函数1作为函数2的参数：函数2就是高阶函数，函数1是回调函数。</p>
<ul>
<li>回调函数：作为另一个函数的参数的函数</li>
<li>高阶函数：接收函数作为参数的函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation</span><span class="params">(a, b <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    res := f(a, b)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := operation(<span class="number">1</span>, <span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用匿名函数实现闭包</li>
</ol>
<p>闭包: 如果在一个函数中，有内层函数，并且该内层函数中使用了该函数的某个局部变量，并且这个函数的返回值是这个内层函数，这时候称<code>内层函数和使用到的这个局部变量</code>为闭包. 其中这个使用到的局部变量不会随着外层函数的结束而销毁.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span> <span class="comment">// 在匿名函数中使用的局部变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个匿名函数, 并返回</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := f()</span><br><span class="line">	fmt.Println(res()) <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(res()) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    res = f()</span><br><span class="line">    fmt.Println(res) <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(res) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4 面向对象"></a>4 面向对象</h2><p>go语言中的面向对象的封装是通过结构体来实现的。继承是通过匿名结构体来模拟的，多态通过接口来实现</p>
<h3 id="4-1-继承的模拟"><a href="#4-1-继承的模拟" class="headerlink" title="4.1 继承的模拟"></a>4.1 继承的模拟</h3><p>继承的模拟，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	sex  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">	Person <span class="comment">// 匿名结构体的嵌套模拟继承, Person中的字段就是Player结构体的提升字段， 如果是p Person就是模拟聚合关系而不是继承关系了</span></span><br><span class="line">	sport  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建父类对象</span></span><br><span class="line">	p := Person&#123;</span><br><span class="line">		name: <span class="string">"张三"</span>,</span><br><span class="line">		sex:  <span class="string">"f"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(p.name, p.sex)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建子类对象</span></span><br><span class="line">	s := Player&#123;</span><br><span class="line">		Person: Person&#123;</span><br><span class="line">			<span class="string">"李四"</span>,</span><br><span class="line">			<span class="string">"m"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		sport: <span class="string">"足球"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(s.Person.name, s.Person.sex, s.sport)</span><br><span class="line">	fmt.Println(s.name, s.sex, s.sport) <span class="comment">// 如果一个结构体中字段是一个匿名字段，并且这个匿名字段是一个结构体，那么称这个匿名结构体中的字段为相对于这个结构体来说就是提升字段，直接进行访问</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h3><p>所谓的方法就是<code>限制了接收者</code>的函数, 谁调用它谁就是接收者, 传过来的t就是谁。 语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t 是接收者，type是接收者的类型可以是引用类型，可以是值类型, 谁调用这个方法，t就是谁</span><br><span class="line"></span><br><span class="line">func (t type) methodName(p1 t1, p2 t2) (t3, t4) &#123;</span><br><span class="line">    &#x2F;&#x2F; 方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法不同于函数：方法名可以重复,只要接收者的类型不同即可，而函数名字不可以重复的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">work</span><span class="params">()</span></span> &#123; <span class="comment">// 接收者是一个值类型</span></span><br><span class="line">	fmt.Println(w.name, <span class="string">"盖大楼"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">rest</span><span class="params">()</span></span> &#123; <span class="comment">// 接收者是一个引用类型</span></span><br><span class="line">	fmt.Println(w.name, <span class="string">"中午休息"</span>) <span class="comment">// w.name == (*w).name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	w1 := Worker&#123;name: <span class="string">"老王"</span>, age: <span class="number">32</span>&#125;</span><br><span class="line">	w1.work()</span><br><span class="line">	w1.rest()</span><br><span class="line"></span><br><span class="line">	w2 := &amp;Worker&#123;<span class="string">"老李"</span>, <span class="number">20</span>&#125;</span><br><span class="line">	w2.work()</span><br><span class="line">	w2.rest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-继承中的方法"><a href="#4-3-继承中的方法" class="headerlink" title="4.3 继承中的方法"></a>4.3 继承中的方法</h3><p>如果一个结构体中的匿名字段的结构体实现了某个方法，那么该结构体类型的变量可以直接访问该方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">面向对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">study</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(p.name, <span class="string">"is studying"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Person</span><br><span class="line">	score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写父类方法, 这样子类在调用的时候就会调用子类的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">study</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(s.name, <span class="string">"is studying.........."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := Student&#123;Person&#123;<span class="string">"张三"</span>, <span class="number">20</span>&#125;, <span class="number">100</span>,&#125;</span><br><span class="line">	<span class="comment">// 子类如果没有实现父类的方法，此时调用的是父类的方法，如果子类重写了父类的方法那么调用子类的方法</span></span><br><span class="line">	s.study() <span class="comment">// s.study() == (*s).study()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-多态"><a href="#4-4-多态" class="headerlink" title="4.4 多态"></a>4.4 多态</h3><p>参数为接口类型的地方，可以传入该接口的实现类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Computer <span class="keyword">interface</span> &#123;</span><br><span class="line">    watchMovie() <span class="comment">// 接口方法</span></span><br><span class="line">    listenMusic() <span class="comment">// 接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个struct</span></span><br><span class="line"><span class="keyword">type</span> Lenovo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Mac <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lenovo)</span> <span class="title">watchMovie</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(l.name, <span class="string">"看电影"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lenovo)</span> <span class="title">listenMusic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(l.name, <span class="string">"听音乐"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Computer)</span></span> &#123;</span><br><span class="line">    c.watchMovie()</span><br><span class="line">    c.listenMusic()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-错误及异常处理"><a href="#5-错误及异常处理" class="headerlink" title="5 错误及异常处理"></a>5 错误及异常处理</h2><p>错误：可能出现问题的地方出现了问题，这种情况在人们的意料之中</p>
<p>异常：不应该出现问题的地方出现了问题，这种情况在意料之外</p>
<h3 id="5-1-错误的处理"><a href="#5-1-错误的处理" class="headerlink" title="5.1 错误的处理"></a>5.1 错误的处理</h3><p>在go语言中，如果一个函数要返回错误，通常是将这个错误参数作为最后一个返回值。在调用函数中对错误的处理通常是将返回的错误和nil进行比较，然后用不同的逻辑去处理错误。</p>
<p><strong>go语言中的错误类型</strong></p>
<ul>
<li><code>error</code>是go语言中内置的接口类型 </li>
<li>可以使用go内置的错误类型来创建错误, 这些错误类型是内置的实现了<code>error</code>接口的类型</li>
</ul>
<p>使用内置的<code>errorString</code>类型来创建错误, 示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用errors.New()创建一个errorString类型的错误</span></span><br><span class="line">err1 := errors.New(<span class="string">"自己常见的错误"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用fmt.Errorf()创建errorString类型的错误</span></span><br><span class="line">err2 := fmt.Errorf(<span class="string">"错误的信息码%d"</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><strong>获取错误的详细信息</strong></p>
<ol>
<li>使用接口的断言将错误转为实现类型，然后调用实现类型中的属性或者方法获取错误的详细信息</li>
<li>使用<code>==</code>比较错误的类型，然后调用错误的相关属性或者方法获取错误详情</li>
</ol>
<p><strong>自定义错误类型</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义一个错误结构体</span></span><br><span class="line"><span class="keyword">type</span> areaError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg    <span class="keyword">string</span></span><br><span class="line">	radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现error接口类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"error: 半径, %.2f, %s"</span>, e.radius, e.msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的错误类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleArea</span><span class="params">(radius <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;<span class="string">"半径是非法的"</span>, radius&#125; <span class="comment">// 使用自定义的错误类型</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> math.Pi * radius * radius, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res, err := circleArea(<span class="number">23.8</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"error "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"circus area is : "</span>, res)</span><br><span class="line"></span><br><span class="line">	res, err = circleArea(<span class="number">-2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"error : "</span>, err)</span><br><span class="line">		<span class="comment">// 使用断言获取错误的数据</span></span><br><span class="line">		<span class="keyword">if</span> ins, ok := err.(*areaError); ok &#123; <span class="comment">// 获取自定义的错误类型的详细信息</span></span><br><span class="line">			fmt.Println(ins.radius)</span><br><span class="line">			fmt.Println(ins.msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"circle area is "</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-异常处理"><a href="#5-2-异常处理" class="headerlink" title="5.2 异常处理"></a>5.2 异常处理</h3><h4 id="5-2-1-defer延迟函数"><a href="#5-2-1-defer延迟函数" class="headerlink" title="5.2.1 defer延迟函数"></a>5.2.1 defer延迟函数</h4><ul>
<li>defer关键字：用来延迟函数或者方法的执行，并不会延迟函数的调用。当外围函数的所有代码执行完毕之后才能执行。</li>
<li>在函数调用前使用defer关键字，能够将函数的执行延迟.</li>
<li>一个函数中使用多个defer，defer延迟函数执行的顺序是逆序执行的</li>
</ul>
<p><strong>外围函数</strong></p>
<p>在哪个函数里面使用了defer关键字，哪个函数就是外围函数.</p>
<blockquote>
<p>注意</p>
<ul>
<li>如果<code>延迟函数</code>有参数: 参数是在执行<code>延迟语句时</code>被执行，只会延迟函数的执行，不会延迟函数的调用</li>
<li>如果<code>外围函数</code>有返回值: 只有其中的所有延迟函数都执行完成，外围函数才真正的返回</li>
<li>如果<code>外围函数</code>发生panic: 只有其中已经入延迟调用栈的所有的延迟函数都执行完成，panic才会被扩展到外围函数</li>
</ul>
</blockquote>
<h4 id="5-2-2-异常处理"><a href="#5-2-2-异常处理" class="headerlink" title="5.2.2 异常处理"></a>5.2.2 异常处理</h4><p>使用panic语句创建异常，使用recover语句捕获异常。通常的处理方法是在defer延迟函数中使用recover语句捕获异常。</p>
<blockquote>
<p>说明：<br>如果在函数中使用了panic(),那么会终止其后要执行的代码,但是已经进入延迟函数栈的延迟函数是会被执行的。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	funcA()</span><br><span class="line">	<span class="keyword">defer</span> myPrint(<span class="string">"defer main 3......."</span>)</span><br><span class="line">	funcB()</span><br><span class="line">	<span class="keyword">defer</span> myPrint(<span class="string">"defer main 4......."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPrint</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"我是函数A...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用defer延迟函数来捕获异常</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg := <span class="built_in">recover</span>(); msg != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"我是函数B......"</span>)</span><br><span class="line">	<span class="keyword">defer</span> myPrint(<span class="string">"defer funcB: 1........"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"i = "</span>, i)</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"funcB函数, panic"</span>) <span class="comment">// 创建异常</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> myPrint(<span class="string">"defer funcB: 2........"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是函数A....</span><br><span class="line">我是函数B......</span><br><span class="line">i &#x3D;  0</span><br><span class="line">i &#x3D;  1</span><br><span class="line">i &#x3D;  2</span><br><span class="line">i &#x3D;  3</span><br><span class="line">i &#x3D;  4</span><br><span class="line">i &#x3D;  5</span><br><span class="line">defer funcB: 1........</span><br><span class="line">funcB函数, panic</span><br><span class="line">defer main 4.......</span><br><span class="line">defer main 3.......</span><br></pre></td></tr></table></figure>

<h2 id="6-包和模块"><a href="#6-包和模块" class="headerlink" title="6 包和模块"></a>6 包和模块</h2><h3 id="6-1-创建包"><a href="#6-1-创建包" class="headerlink" title="6.1 创建包"></a>6.1 创建包</h3><p>包和文件夹的关系：没有关系，但是建议是将包的名字设置成文件夹的名字，在同一个文件夹下的文件中声明package的名字的时候都应该是一样的</p>
<h3 id="6-2-导入包"><a href="#6-2-导入包" class="headerlink" title="6.2 导入包"></a>6.2 导入包</h3><p>使用import关键字来进行导包，导包的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1, 使用包中的函数的时候需要使用包名.函数名的方式来使用</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2, 此时在使用包中的方法的时候，不需要使用包名直接使用包中的方法名就可以</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3， 使用别名, 在使用包中的方法的时候，使用别名.函数名的方式来使用</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    f <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4， 使用_, 引入该包，但是不直接使用包中的函数，而是调用了该包中的init函数</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-包管理"><a href="#6-3-包管理" class="headerlink" title="6.3 包管理"></a>6.3 包管理</h3><h4 id="常规开发"><a href="#常规开发" class="headerlink" title="常规开发"></a>常规开发</h4><p>开发的项目需要放在GOPATH路径下下的src目录中，在项目编译的时候会查找依赖的包：</p>
<ul>
<li>首先查找GOROOT目录下的src目录中</li>
<li>然后查找GOPATH目录下的src目录中</li>
</ul>
<p>使用<code>go get</code> 命令安装的包会被下载到<code>GOPATH/src</code>目录下</p>
<p>开发项目的时候，我们需要的包类型：</p>
<ul>
<li>标准库中的包</li>
<li>第三方下载的包</li>
<li>自定义的包</li>
</ul>
<p>所谓的包管理就是管理上述三种类型的包。一般情况下，我们是将自己的项目放在<code>GOPATH/src</code>目录下:</p>
<ul>
<li><strong>标准库中的包</strong>，放在<code>GOROOT/src</code>目录下</li>
<li><strong>第三方下载的包</strong>，放在<code>GOPATH/src</code>目录下</li>
<li><strong>项目中自定义的包</strong>，随着我们的项目放在<code>GOPATH/src</code>目录下</li>
</ul>
<h4 id="vendor包管理机制"><a href="#vendor包管理机制" class="headerlink" title="vendor包管理机制"></a>vendor包管理机制</h4><p>在go1.7中引入。<strong>注意：该机制需要我们项目在<code>GOPATH/src</code>目录下.</strong></p>
<p>正常情况下，我们开发一个项目的时候，需要将该项目放在<code>GOPATH/src</code>路径下，如果我们在项目中使用了其他的依赖包，这时候我们会使用<code>go get</code>命令下载我们的依赖包，下载后的依赖包会被放在<code>GOPATH/src</code>目录下，但是我们的项目的源代码和项目依赖的包不在同一个目录下。为了解决这种项目的依赖包和项目源代码不在同一个目录下的问题，go语言引入了<code>vendor</code>机制。</p>
<p><code>vendor</code>机制：需要在项目目录下创建一个vendor目录，在该vendor目录下保存我们项目依赖的包，当对项目进行<code>go build</code>的时候会优先从该目录下寻找项目的依赖包，如果没有找到才会到GOROOT/src和GOPATH/src目录下寻找依赖的包。vendor目录下的包是从<code>GOPATH/src</code>目录下拷贝的。</p>
<p><code>govendor工具</code>是一基于该机制的包管理工具。该工具对包的管理是基于GOPATH/src下的包的，如果GOPATH中本身没有项目的依赖包，则需要通过<code>go get</code>先下载到GOPATH/src中，再通过govendor工具拷贝到vendor目录中</p>
<p><strong>govendor工具使用</strong></p>
<p>工具安装</p>
<p><code>go get -u -v github.com/kardianos/govendor</code></p>
<p>工具使用</p>
<p><code>govendor init</code>: 在项目目录下执行此命令会在该项目目录下生成一个<code>vendor</code>目录</p>
<p><code>govendor add +external</code>: 将本项目所有依赖包自动拷贝到vendor目录中，但是前提是在GOPATH/src目录下已经存在该包</p>
<h4 id="Modules包管理机制"><a href="#Modules包管理机制" class="headerlink" title="Modules包管理机制"></a>Modules包管理机制</h4><p>该机制不同于vendor机制，vendor机制依赖于GOPATH，而MODULES机制不依赖于GOPATH。go在1.11的版本中提供了基于该机制的命令行工具<code>go mod</code>。在go1.11中需要手动选择是否启用该机制，在项目中启用该机制的时候，下载的包会被存放在<code>GOPATH/pkg/mod</code>目录下，而不是<code>GOPATH/src</code>目录下。</p>
<p><code>module</code>机制：在任意位置创建自己的项目，该机制不依赖GOPATH，然后在项目的目录下创建一个<code>go.mod</code>文件，该文件中使用<code>requrie</code>来引用项目中的依赖包。当如我们在项目中引用自己开发的包的时候，需要使用go.mod文件中module的名字中定义的包名作为根路径。</p>
<p><strong>go mod命令使用</strong></p>
<p><code>go mod init module名字</code>: 该命令会在项目的路径下生成一个<code>go.mod</code>文件，module名字是我们在项目中导入自己该项目中自定义的包的根路径。</p>
<h2 id="7-并发编程"><a href="#7-并发编程" class="headerlink" title="7 并发编程"></a>7 并发编程</h2><p>go语言天然支持并发，使用go关键字就能开辟一个协程. 不要通过共享内存来进行通信而是使用通信的方式实现共享内存.</p>
<h3 id="7-1-并发编程基础"><a href="#7-1-并发编程基础" class="headerlink" title="7.1 并发编程基础"></a>7.1 并发编程基础</h3><h4 id="怎么创建协程"><a href="#怎么创建协程" class="headerlink" title="怎么创建协程"></a>怎么创建协程</h4><p>使用go关键字直接创建协程</p>
<h4 id="协程之间的数据共享"><a href="#协程之间的数据共享" class="headerlink" title="协程之间的数据共享"></a>协程之间的数据共享</h4><p><strong>共享内存实现</strong></p>
<p>竞态条件</p>
<p><strong>channel通信来实现</strong></p>
<p>channel实现</p>
<h4 id="协程的底层原理"><a href="#协程的底层原理" class="headerlink" title="协程的底层原理"></a>协程的底层原理</h4><h3 id="7-2-协程池的实现"><a href="#7-2-协程池的实现" class="headerlink" title="7.2 协程池的实现"></a>7.2 协程池的实现</h3><p>开辟多少个协程比较合适？</p>
<h4 id="什么是协程池"><a href="#什么是协程池" class="headerlink" title="什么是协程池"></a>什么是协程池</h4><h4 id="为什么需要协程池"><a href="#为什么需要协程池" class="headerlink" title="为什么需要协程池"></a>为什么需要协程池</h4><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol>
<li>将所有的任务放入到一个任务队列中</li>
<li>协程池中的协程从任务队列中获取任务去执行</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">协程池的实现</span></span><br><span class="line"><span class="comment">1. 所有的任务放入到一个任务channel中</span></span><br><span class="line"><span class="comment">2. 协程池从任务channel中获取任务执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************任务相关的逻辑****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义任务</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">	f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTask</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">error</span>) *<span class="title">Task</span></span> &#123;</span><br><span class="line">	task := Task&#123;f&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := t.f(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************创建协程池*********************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义协程池的基本结构</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	EntryChannel <span class="keyword">chan</span> *Task <span class="comment">// 对外提供的：所有的任务都放到这个里面</span></span><br><span class="line">	JobsChannel  <span class="keyword">chan</span> *Task <span class="comment">// 协程池内部使用的：所有的任务在这里面，每一个协程从这里面获取执行的任务</span></span><br><span class="line">	workNum      <span class="keyword">int</span>        <span class="comment">// 协程池中协程的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建协程池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(workNum <span class="keyword">int</span>)</span> *<span class="title">Pool</span></span> &#123;</span><br><span class="line">	p := Pool&#123;</span><br><span class="line">		EntryChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> *Task),</span><br><span class="line">		JobsChannel:  <span class="built_in">make</span>(<span class="keyword">chan</span> *Task),</span><br><span class="line">		workNum:      workNum,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 给协程池绑定方法：能够创建一个worker并且能够执行worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">worker</span><span class="params">(workId <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从JobsChannel中拉取任务</span></span><br><span class="line">	<span class="keyword">for</span> task := <span class="keyword">range</span> p.JobsChannel &#123;</span><br><span class="line">		<span class="comment">// 执行从JobsChannel拉取的任务</span></span><br><span class="line">		task.Execute()</span><br><span class="line">		fmt.Println(workId, <span class="string">"worker 执行完成一个任务"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 让协程池开始工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 根据work_num创建work去工作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.workNum; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> p.worker(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从EntryChannel中取任务，将取到的任务发送给JobsChannel</span></span><br><span class="line">	<span class="keyword">for</span> task := <span class="keyword">range</span> p.EntryChannel &#123;</span><br><span class="line">		p.JobsChannel &lt;- task</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试协程池的工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建任务</span></span><br><span class="line">	printHello := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	task := NewTask(printHello)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建协程池</span></span><br><span class="line">	pool := NewPool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将任务放入协程池</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			pool.EntryChannel &lt;- task</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动协程池</span></span><br><span class="line">	pool.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-最佳实践"><a href="#8-最佳实践" class="headerlink" title="8 最佳实践"></a>8 最佳实践</h2><h3 id="8-1-编码规范"><a href="#8-1-编码规范" class="headerlink" title="8.1 编码规范"></a>8.1 编码规范</h3><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p><strong>包命名</strong></p>
<p>保持package的名字与目录的名字一致，包名应该为消息单词，不要使用下划线或者混合大小写</p>
<p><strong>文件命名</strong></p>
<p>应该为小写单词，使用下划线分割单词</p>
<p><strong>结构体命名</strong></p>
<p>采用驼峰命名法：首字母根据访问控制权限来大写或者小写</p>
<p><strong>接口命名</strong></p>
<p>单个函数的接口名以<code>er</code>作为后缀</p>
<p><strong>变量命名</strong></p>
<ul>
<li>和结构体类似，变量名使用驼峰，首字母根据访问控制权限选择大小写</li>
<li>若变量为bool类型，名称应该以Has，Is，Can，或Allow开头</li>
</ul>
<p><strong>常量命名</strong></p>
<ul>
<li>全部大写字母，使用下划线分割单词</li>
<li>如果是枚举类型的常量，需要先创建相应的类型<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="keyword">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP Scheme = <span class="string">"http"</span></span><br><span class="line">    HTTPS Scheme = <span class="string">"https"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h4><p><strong>包注释</strong></p>
<ul>
<li>包注释：位于package包的声明前。如果包中有多个文件，只需要出现在一个go文件中（通常是和包同名的文件）<ul>
<li>包的基本简介</li>
<li>创建者</li>
<li>创建时间 </li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该包是用来提供常用的工具的</span></span><br><span class="line"><span class="keyword">package</span> util</span><br></pre></td></tr></table></figure>

<p><strong>接口或结构注释</strong></p>
<p>接口注释放在接口定义的前一行</p>
<p><strong>函数或者方法注释</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数的作用</span></span><br><span class="line"><span class="comment">// 参数：每行一个参数</span></span><br><span class="line"><span class="comment">// 返回值: 每行一个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h4><p><strong>缩进和换行</strong></p>
<ul>
<li>使用tab进行缩进</li>
<li>每行不超过120字符</li>
</ul>
<p><strong>括号和空格</strong></p>
<ul>
<li>左大括号不换行</li>
<li>运算符之间使用空格</li>
</ul>
<p><strong>import风格</strong></p>
<p>标准库中的包、程序内部的包、第三方的包</p>
<p><strong>错误的处理</strong></p>
<ul>
<li>尽早使用return</li>
<li>采用独立的错误流进行处理错误</li>
</ul>
<h3 id="8-2-使用工具"><a href="#8-2-使用工具" class="headerlink" title="8.2 使用工具"></a>8.2 使用工具</h3><h4 id="gofmt"><a href="#gofmt" class="headerlink" title="gofmt"></a>gofmt</h4><p>使用该工具对代码进行格式化</p>
<h4 id="goimport"><a href="#goimport" class="headerlink" title="goimport"></a>goimport</h4><p>使用该工具对导入的包进行格式化</p>
<h4 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h4><p>静态分析源码中存在的问题</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统--简介</title>
    <url>/2020/01/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>本文简单介绍了一下分布式系统的相关研究方向极其学习资料。</p>
<a id="more"></a>


<h2 id="0-基本概念"><a href="#0-基本概念" class="headerlink" title="0 基本概念"></a>0 基本概念</h2><p>分布式系统要做的任务就是把多台机器有机的组合、连接起来，让其协同完成一件任务，可以是计算任务，也可以是存储任务。</p>
<h2 id="1-主要方向"><a href="#1-主要方向" class="headerlink" title="1 主要方向"></a>1 主要方向</h2><h3 id="1-1-分布式存储系统"><a href="#1-1-分布式存储系统" class="headerlink" title="1.1 分布式存储系统"></a>1.1 分布式存储系统</h3><p><strong>分类</strong></p>
<ol>
<li>结构化存储：典型的场景就是事务处理系统或者关系型数据库（RDBMS）。</li>
<li>非结构化存储：非结构化存储强调的是高可扩展性，典型的系统就是分布式文件系统。和结构化存储系统相比，虽然分布式文件系统的可扩展性，吞吐率都非常好，但是几乎无法支持随机访问（random access）操作，通常只能进行文件进行追加（append）操作。而这样的限制使得非结构化存储系统很难面对那些低延时，实时性较强的应用。</li>
<li>半结构化存储：提出是为了解决结非构化存储系统随机访问性能差的问题。我们通常会听到一些流行的名词，比如 NoSQL, Key-Value Store, 甚至包括对象存储，例如 protobuf，thrift 等等，这些都属于半结构化存储研究的领域。NoSQL 系统既有分布式文件系统所具有的可扩展性，又有结构化存储系统的随机访问能力 （例如随机update, read 操作），系统在设计时通常选择简单键值（K-V）进行存储，抛弃了传统 RDBMS 里复杂 SQL 查询以及 ACID 事务。这样做可以换取系统最大的限度的可扩展性和灵活性。在 NoSQL 里比较有名系统包括：Google 的 Bigtable, Amazon 的 Dynamo, 以及开源界大名鼎鼎的 HBase，Cassandra 等.  通常这些 NoSQL 系统底层都是基于比较成熟的存储引擎，比如 Bigtable 就是基于 LevelDB ( jeff dean 写的，非常好的 C++ 源码教程) ，底层数据结构采用 LSM-Tree. 除了 LSM-Tree 之外 B-Tree （B+Tree）也是很成熟的存储引擎数据结构。</li>
<li>In-memory存储：In-memory 存储顾名思义就是将数据存储在内存中, 从而获得读写的高性能。比较有名的系统包括memcahed ，以及Redis。</li>
</ol>
<p><strong>技术</strong></p>
<p>Paxos, CAP, Consistent Hash, Timing (时钟), 2PC, 3PC 等等。一定要去思考为什么在当下环境需要某项技术，如果没有这个技术用其它技术替代是否可行，而不是一味的陷入大量的细节之中。</p>
<h3 id="1-2-分布式计算系统"><a href="#1-2-分布式计算系统" class="headerlink" title="1.2 分布式计算系统"></a>1.2 分布式计算系统</h3><p><strong>分类</strong></p>
<ol>
<li>传统基于msg的系统</li>
<li>MapReduce-like 系统： 这一类系统又叫作 dataflow 系统，其中以 MapReduce (Hadoop) 和 Spark 为代表。</li>
<li>图计算系统</li>
<li>基于状态（state）的系统</li>
<li>Streaming 系统</li>
</ol>
<h3 id="1-3-分布式管理系统"><a href="#1-3-分布式管理系统" class="headerlink" title="1.3 分布式管理系统"></a>1.3 分布式管理系统</h3><h2 id="2-学习资料"><a href="#2-学习资料" class="headerlink" title="2 学习资料"></a>2 学习资料</h2><h3 id="2-1-书籍"><a href="#2-1-书籍" class="headerlink" title="2.1 书籍"></a>2.1 书籍</h3><p>分布式系统：概念与设计<br>大话存储</p>
<h3 id="2-2-视频"><a href="#2-2-视频" class="headerlink" title="2.2 视频"></a>2.2 视频</h3><p><a href="https://www.bilibili.com/video/av24223728" target="_blank" rel="noopener">mit的6.824</a></p>
<h3 id="2-3-论文"><a href="#2-3-论文" class="headerlink" title="2.3 论文"></a>2.3 论文</h3><p><a href="https://www.zhihu.com/question/30026369/answer/940757005?utm_source=com.yinxiang&utm_medium=social&utm_oi=46744444338176" target="_blank" rel="noopener">参考</a></p>
<h2 id="3-工程实践"><a href="#3-工程实践" class="headerlink" title="3 工程实践"></a>3 工程实践</h2><p><a href="https://www.zhihu.com/question/30026369/answer/940757005?utm_source=com.yinxiang&utm_medium=social&utm_oi=46744444338176" target="_blank" rel="noopener">参考</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<ol>
<li><a href="https://www.zhihu.com/question/23645117/answer/124708083?utm_source=com.yinxiang&utm_medium=social&utm_oi=46744444338176" target="_blank" rel="noopener">学习分布式系统需要怎样的知识？马超回答</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/100283343?utm_source=com.yinxiang&utm_medium=social&utm_oi=46744444338176" target="_blank" rel="noopener">两万字深度介绍分布式系统原理，一文入魂</a></li>
<li><a href="zhihu.com/question/23645117/answer/839887396?utm_source=com.yinxiang&utm_medium=social&utm_oi=46744444338176">学习分布式系统需要怎样的知识？阿里云官网回答</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/01/04/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>本文简单的记录了网编编程相关的一些基础知识。</p>
<a id="more"></a>

<h2 id="1-网络编程基础"><a href="#1-网络编程基础" class="headerlink" title="1 网络编程基础"></a>1 网络编程基础</h2><p>在开始学习网络编程之前，先了解一些Linux的基础知识。</p>
<h3 id="1-1-Linux架构"><a href="#1-1-Linux架构" class="headerlink" title="1.1 Linux架构"></a>1.1 Linux架构</h3><p><img src="linux_arch.jpg" alt="linux架构简图"></p>
<p>上图是Linux简单的系统架构图（不一定准确）。应用程序与内核的交互是通过Linux内核提供的系统调用了来实现的。在应用程序中可以直接调用内核提供的API，也可以使用C语言标准库中对内核中API进一步进行封装的API。</p>
<h3 id="1-2-数据包的流转路径"><a href="#1-2-数据包的流转路径" class="headerlink" title="1.2 数据包的流转路径"></a>1.2 数据包的流转路径</h3><p><img src="pkg_flow.jpg" alt="数据包处理流程图"></p>
<p>首先是网卡收包，然后交给内核协议栈，最后数据到达用户进程。</p>
<h4 id="1-2-1-网卡收包"><a href="#1-2-1-网卡收包" class="headerlink" title="1.2.1 网卡收包"></a>1.2.1 网卡收包</h4><p>从整体上来说，网卡收包是网线中的高低电平转换到网卡FIFO存储然后再拷贝到主内存的过程。网卡需要有驱动才能工作，驱动是加载到内核中的模块，负责衔接网卡和内核的网络模块。驱动在加载的时候将自己注册进内核的网络模块，当相应的网卡收到数据包时，网络模块会调用相应的驱动程序处理数据。具体过程如下：</p>
<ul>
<li>客户端发送的数据包从网卡进来，网卡将数据包通过DMA的方式写入到指定的内存地址，该地址由网卡驱动分配并初始化。</li>
<li>之后网卡通过硬件中断（IRQ）通知CPU，告诉它有数据来了。CPU根据中断表，调用已经注册的中断函数，这个中断函数会调到网卡驱动程序中相应的函数。驱动先禁用网卡的中断，表示驱动程序已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停的被中断。</li>
<li>再之后网卡驱动程序启动软中断，这个软中断会被内核中的ksoftirqd进程处理，该进程在收到软中断后，就会调用相应软中断所对应的处理函数，在这里ksoftirqd进程会调用网络模块的net_rx_action函数。net_rx_action调用网卡驱动里的poll函数来一个一个的处理数据包，在pool函数中，驱动会一个接一个的读取网卡写到内存中的数据包，在驱动程序中会将内存中的数据包转换成内核网络模块能识别的skb格式，然后调用napi_gro_receive函数</li>
<li>napi_gro_receive会处理GRO相关的内容，也就是将可以合并的数据包进行合并，这样就只需要调用一次协议栈。然后判断是否开启了RPS：<ul>
<li>如果开启了，将会调用enqueue_to_backlog，在enqueue_to_backlog函数中，会将数据包放入CPU的softnet_data结构体的input_pkt_queue中，然后返回，如果input_pkt_queue满了的话，该数据包将会被丢弃。CPU会接着在自己的软中断上下文中处理自己input_pkt_queue里的网络数据（调用__netif_receive_skb_core）。</li>
<li>如果没开启RPS，napi_gro_receive会直接调用__netif_receive_skb_core</li>
</ul>
</li>
<li>__netif_receive_skb_core函数中会看是不是有AF_PACKET类型的socket（也就是我们常说的原始套接字），如果有的话，拷贝一份数据给它。调用协议栈相应的函数，将数据包交给协议栈处理。</li>
</ul>
<h4 id="1-2-2-内核协议栈处理数据包的流程"><a href="#1-2-2-内核协议栈处理数据包的流程" class="headerlink" title="1.2.2 内核协议栈处理数据包的流程"></a>1.2.2 内核协议栈处理数据包的流程</h4><p>socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。</p>
<h4 id="1-2-3-用户进程处理数据包"><a href="#1-2-3-用户进程处理数据包" class="headerlink" title="1.2.3 用户进程处理数据包"></a>1.2.3 用户进程处理数据包</h4><p>数据到达用户程序之后，在用户程序中使用socket层提供的系统API，根据自己的协议（可以是http协议）进行数据包的处理。</p>
<h2 id="2-网络IO模型"><a href="#2-网络IO模型" class="headerlink" title="2 网络IO模型"></a>2 网络IO模型</h2><p>IO操作是指：在应用程序中使用内核提供的系统调用，<strong>将内核缓冲区中的数据拷贝到用户空间的缓冲区中</strong>。</p>
<p><strong>阻塞IO</strong>：在应用程序中使用此种系统调用，如果内核缓冲区中没有数据，应用程序会被阻塞，将CPU让出。</p>
<p><strong>非阻塞IO</strong>：在应用程序中使用此种系统调用，如果内核缓冲区中没有数据，应用程序不会被阻塞，而是返回一个错误码，CPU不会让出，在应用程序中是使用轮询的方式，轮询将会不断地询问内核，这将占用大量的CPU时间。</p>
<p><strong>IO复用</strong>：select, epoll系统调用，该系统调用会使程序阻塞。所谓的复用是复用线程，在一个线程中对多个内核缓冲区进行监控，如果监控的多个内核缓冲区都没有数据，应用程序被阻塞；当监控的多个内核缓冲区中任何一个或多个有数据的时候，都会调用它相对应的IO操作函数，将数据从内核缓冲区拷贝到用户进程。</p>
<p><strong>信号IO</strong>：该类系统调用需要注册一个信号处理函数，如果内核缓冲区中没有数据，应用程序不会被阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，在信号处理函数中进行IO操作。</p>
<p><strong>异步IO</strong>：该类系统调用是POSIX规范定义的，该规范规定: 异步IO应该是应用程序告知内核启动某个操作（在IO操作中就是当内核缓冲区中有数据的时候），并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序。</p>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>通用编程技术-队列</title>
    <url>/2020/01/04/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>本文简单的记录了常用的消息队列kafka的基本使用和原理。</p>
<a id="more"></a>]]></content>
      <categories>
        <category>通用编程技术</category>
      </categories>
  </entry>
  <entry>
    <title>通用编程技术-缓存</title>
    <url>/2020/01/04/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>本文简单的记录了开发中常用的缓存技术Redis的基本使用和原理。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>通用编程技术</category>
      </categories>
  </entry>
  <entry>
    <title>通用编程技术-数据库</title>
    <url>/2020/01/04/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>本文简单的记录了数据库MySQL，MongoDB，HBase等的基本使用和原理。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>通用编程技术</category>
      </categories>
  </entry>
  <entry>
    <title>通用编程技术-网络</title>
    <url>/2020/01/04/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF-%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本文简单的记录了网路的基础知识。</p>
<a id="more"></a>]]></content>
      <categories>
        <category>通用编程技术</category>
      </categories>
  </entry>
  <entry>
    <title>通用编程技术-编程语言</title>
    <url>/2020/01/04/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>本文简单的记录了Rust, Go, Python, TypeScript, Erlang的基本语法。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>通用编程技术</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫专题</title>
    <url>/2020/01/03/%E7%88%AC%E8%99%AB%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>本文简单的记录了爬虫开发的相关基础知识。</p>
<a id="more"></a>

<h2 id="1-基本流程"><a href="#1-基本流程" class="headerlink" title="1 基本流程"></a>1 基本流程</h2><p>首先要得到我们想要的数据的url，然后去请求该url得到相应的数据，之后对响应的非结构化或者结构化的数据进行解析从中得到我们的目标数据。</p>
<h3 id="1-1-获取url"><a href="#1-1-获取url" class="headerlink" title="1.1 获取url"></a>1.1 获取url</h3><p>使用chrome有一个简单的方法：打开开发者工具<code>F12</code>快捷键，然后打开<code>network</code>选项卡，然后选择<code>search</code>复选框，输入我们要搜索的目标数据，可以直接定位到我们的数据来源的url。</p>
<h3 id="1-2-发送请求"><a href="#1-2-发送请求" class="headerlink" title="1.2 发送请求"></a>1.2 发送请求</h3><p>获取到url之后，我们需要确定获取我们需要的数据需要发送什么样的请求：</p>
<ul>
<li>请求行中的数：请求方法是GET还是POST，url是什么</li>
<li>请求头中有哪些参数</li>
<li>请求体中需要设置哪些数据</li>
</ul>
<h3 id="1-3-解析数据"><a href="#1-3-解析数据" class="headerlink" title="1.3 解析数据"></a>1.3 解析数据</h3><p>如果响应的数据是json可以直接提取，如果返回的是html数据，需要使用相应的工具进行解析。常用的python解析工具：</p>
<ul>
<li>re</li>
<li>lxml</li>
<li>bs4</li>
<li>pyquery</li>
</ul>
<h2 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2 发送请求"></a>2 发送请求</h2><p>在python中常用的发送请求的包是requests第三方包，需要使用pip进行安装。</p>
<p><a href="https://2.python-requests.org//zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">requests包的使用参考</a></p>
]]></content>
      <categories>
        <category>爬虫开发</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构专题</title>
    <url>/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>本文记录了在编程中常用的数据结构以及基本的操作。<br><a href="https://github.com/mxiaole/go-data-struct" target="_blank" rel="noopener">go-实现代码地址</a><br><a href="https://github.com/mxiaole/data-struct-and-alg" target="_blank" rel="noopener">java-实现代码地址</a></p>
<a id="more"></a>

<p>[TOC]</p>
<h2 id="0-绪论"><a href="#0-绪论" class="headerlink" title="0 绪论"></a>0 绪论</h2><h3 id="数据结构是什么"><a href="#数据结构是什么" class="headerlink" title="数据结构是什么"></a>数据结构是什么</h3><p>研究数据怎么进行存储的。<strong>数据</strong>在内存中的存储有两种方式：</p>
<ul>
<li>所有的数据存储在一块连续的内存中</li>
<li>所有的数据存储在不连续的内存中<br>为了方便某些操作，需要将数据进行封装成<strong>数据节点</strong>，在<strong>数据节点</strong>中加入一些为了方便这些操作所需要的额外信息。</li>
</ul>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul>
<li><p>掌握常用的数据结构：</p>
<ul>
<li>将数据封装成节点添加了哪些额外信息？添加的额外信息能够方便哪些操作？为什么使用这种封装能够方便这些操作？</li>
<li>抽象数据结构的成员变量有哪些？成员方法有哪些？</li>
</ul>
</li>
<li><p>能够根据自己的需求将数据封装成自己需要的<strong>数据节点</strong>，并基于这种<strong>数据节点</strong>实现自己需要操作</p>
</li>
<li><p>能够基于基础的数据结构实现高级的数据结构</p>
</li>
</ul>
<h2 id="1-常用数据结构"><a href="#1-常用数据结构" class="headerlink" title="1 常用数据结构"></a>1 常用数据结构</h2><p>最基础的数据结构就是：数组、链表、二叉树, 基于这些最基础的数据结构可以实现一些其他的数据结构：栈、队列、集合、映射等</p>
<h3 id="1-1-线性结构"><a href="#1-1-线性结构" class="headerlink" title="1.1 线性结构"></a>1.1 线性结构</h3><p>常见的线性数据结构：</p>
<ul>
<li>数组：普通数组、动态数组</li>
<li>链表：单链表、双向链表、循环链表</li>
<li>栈</li>
<li>队列：普通队列、循环队列、双端队列</li>
<li>哈希表 </li>
<li>压缩列表</li>
<li>跳跃表</li>
<li>后缀数组</li>
</ul>
<h3 id="1-2-树结构"><a href="#1-2-树结构" class="headerlink" title="1.2 树结构"></a>1.2 树结构</h3><p>每个节点可以有若干个孩子，每个孩子只能有一个父亲。常见的树结构:</p>
<ul>
<li>二叉树<ul>
<li>二叉搜索树（BST）</li>
<li>二叉平衡树（AVL树）</li>
<li>2-3查找树</li>
<li>红黑树</li>
</ul>
</li>
<li>多叉树<ul>
<li>线段树</li>
<li>字典树Trie，前缀树</li>
<li>并查集</li>
<li>B树</li>
<li>B+树</li>
</ul>
</li>
<li>堆</li>
<li>优先级队列</li>
</ul>
<h3 id="1-3-图结构"><a href="#1-3-图结构" class="headerlink" title="1.3 图结构"></a>1.3 图结构</h3><p>对于图这种数据结构，重点是研究基于图的各种算法。详细见算法一文。</p>
<ul>
<li>邻接表</li>
<li>邻接矩阵</li>
</ul>
<h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2 数组"></a>2 数组</h2><p><strong>分类</strong>：定长数组、动态数组</p>
<h3 id="2-1-定长数组"><a href="#2-1-定长数组" class="headerlink" title="2.1 定长数组"></a>2.1 定长数组</h3><h4 id="2-1-1-数据节点封装"><a href="#2-1-1-数据节点封装" class="headerlink" title="2.1.1 数据节点封装"></a>2.1.1 数据节点封装</h4><p>没有有额外信息</p>
<h4 id="2-1-2-抽象数据结构"><a href="#2-1-2-抽象数据结构" class="headerlink" title="2.1.2 抽象数据结构"></a>2.1.2 抽象数据结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstract</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*成员变量*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> E[] data;  <span class="comment">// 数组容量data.length</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*成员方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(<span class="keyword">int</span> e)</span></span>;          <span class="comment">// 向数组尾部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(<span class="keyword">int</span> e)</span></span>;         <span class="comment">// 向数组的头部添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;   <span class="comment">// 向数组中指定的位置添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;          <span class="comment">// 获取指定索引的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;   <span class="comment">// 更新数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> e)</span></span>;      <span class="comment">// 判断元素e是不是在数组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> e)</span></span>;             <span class="comment">// 查找元素e的数组下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;        <span class="comment">// 从数组中删除元素, 返回删除的元素值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span> e)</span></span>;    <span class="comment">// 从数组中删除指定的元素e, 只删除一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-部分操作实现"><a href="#2-1-3-部分操作实现" class="headerlink" title="2.1.3 部分操作实现"></a>2.1.3 部分操作实现</h4><p><strong>add添加元素</strong></p>
<p>1 步骤</p>
<ul>
<li>判断数组是否满了，不满才会进行下面的步骤</li>
<li>将index后的数据从后向前依次进行后移</li>
<li>将元素插入index位置</li>
</ul>
<p>2 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index must be non-negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除元素</strong></p>
<p>1 步骤</p>
<ul>
<li>将index后面的数据从前向后依次进行前移</li>
</ul>
<p>2 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = data[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-动态数组"><a href="#2-2-动态数组" class="headerlink" title="2.2 动态数组"></a>2.2 动态数组</h3><p>所谓的动态数组就是可以动态进行扩容和缩容的数组。</p>
<h4 id="2-2-1-数据节点封装"><a href="#2-2-1-数据节点封装" class="headerlink" title="2.2.1 数据节点封装"></a>2.2.1 数据节点封装</h4><p>没有额外信息</p>
<h4 id="2-2-2-抽象数据结构"><a href="#2-2-2-抽象数据结构" class="headerlink" title="2.2.2 抽象数据结构"></a>2.2.2 抽象数据结构</h4><p>同定长数组</p>
<h4 id="2-2-3-部分操作实现"><a href="#2-2-3-部分操作实现" class="headerlink" title="2.2.3 部分操作实现"></a>2.2.3 部分操作实现</h4><p><strong>添加元素</strong></p>
<p>1 步骤</p>
<ul>
<li>检查当前数组的容量，如果数组容量不够，会创建一个新的<code>容量是原来数组容量n倍（n常为2）</code>的新数组，</li>
<li>然后将旧数组中的数据拷贝到新的数组中。</li>
<li>在新的数组中添加元素</li>
</ul>
<p>2 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * data.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除元素</strong></p>
<p>1 步骤</p>
<ul>
<li>将数据从数组中删除</li>
<li>检查数组的容量，如果此时数组中元素的个数小于数组容量的n倍，那么会创建一个新的数组并且这个数组的容量是旧数组容量的1/n倍</li>
<li>然后将旧数组中的数据拷贝到新数组中</li>
</ul>
<p>2 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    E ret = data[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    data[size] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  动态数组缩小容量</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length / <span class="number">2</span>) &#123;</span><br><span class="line">        resize(data.length / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-时间复杂度分析"><a href="#2-2-4-时间复杂度分析" class="headerlink" title="2.2.4 时间复杂度分析"></a>2.2.4 时间复杂度分析</h4><p>使用上述的扩容和缩容策略时存在复杂度震荡的问题，这时候可以使用Lazy的方式进行扩容和缩容（当size = capacity / 4的时候才进行缩容）</p>
<h3 id="2-3-定长数组和动态数组的比较"><a href="#2-3-定长数组和动态数组的比较" class="headerlink" title="2.3 定长数组和动态数组的比较"></a>2.3 定长数组和动态数组的比较</h3><ul>
<li>定长数据存放的元素个数有限，动态数组可以存放的元素个数是无限的。</li>
</ul>
<h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3 链表"></a>3 链表</h2><p><strong>分类</strong>：单链表、双向链表、循环链表</p>
<h3 id="3-1-单链表"><a href="#3-1-单链表" class="headerlink" title="3.1 单链表"></a>3.1 单链表</h3><h4 id="3-1-1-数据节点封装"><a href="#3-1-1-数据节点封装" class="headerlink" title="3.1.1 数据节点封装"></a>3.1.1 数据节点封装</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> E e;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-抽象数据结构"><a href="#3-1-2-抽象数据结构" class="headerlink" title="3.1.2 抽象数据结构"></a>3.1.2 抽象数据结构</h4><h4 id="3-1-3-部分操作实现"><a href="#3-1-3-部分操作实现" class="headerlink" title="3.1.3 部分操作实现"></a>3.1.3 部分操作实现</h4><p><strong>添加元素</strong></p>
<p>1 步骤</p>
<ul>
<li>定义pre，使用pre找到指定的位置的前驱节点，假设新的节点是node，那么首先让node.next = head, 然后将head移动到node head = node;</li>
<li>将数据插入</li>
</ul>
<p>2 代码</p>
<p><strong>指定位置添加元素</strong></p>
<p>1 步骤</p>
<p>假设要插入的新的节点是node, 开始的时候初始化一个pre节点，让pre指向head，然后使用pre找到要插入的位置，然后将node指向pre的next，然后将pre的next执行node即可。</p>
<p>2 代码</p>
<p><strong>删除元素</strong></p>
<p>1 步骤</p>
<p>先找到要删除的节点，然后让pre-&gt;next = delNode-&gt;next; 然后让delNode会被回收进行设置delNode-&gt;next = null;</p>
<p>2 代码</p>
<h3 id="3-2-带有尾指针的链表"><a href="#3-2-带有尾指针的链表" class="headerlink" title="3.2 带有尾指针的链表"></a>3.2 带有尾指针的链表</h3><h3 id="3-3-链表基本操作时间复杂度分析"><a href="#3-3-链表基本操作时间复杂度分析" class="headerlink" title="3.3 链表基本操作时间复杂度分析"></a>3.3 链表基本操作时间复杂度分析</h3><h2 id="4-栈"><a href="#4-栈" class="headerlink" title="4 栈"></a>4 栈</h2><p><strong>底层实现</strong>：数组或链表。</p>
<h3 id="4-1-数组实现"><a href="#4-1-数组实现" class="headerlink" title="4.1 数组实现"></a>4.1 数组实现</h3><h4 id="4-1-1-数据节点封装"><a href="#4-1-1-数据节点封装" class="headerlink" title="4.1.1 数据节点封装"></a>4.1.1 数据节点封装</h4><p>无</p>
<h4 id="4-1-2-抽象数据结构"><a href="#4-1-2-抽象数据结构" class="headerlink" title="4.1.2 抽象数据结构"></a>4.1.2 抽象数据结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*成员变量*/</span></span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*成员方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;  <span class="comment">// 元素入栈</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;  <span class="comment">// 元素出栈</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;  <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;  <span class="comment">// 获取栈中元素的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-部分操作实现"><a href="#4-1-3-部分操作实现" class="headerlink" title="4.1.3 部分操作实现"></a>4.1.3 部分操作实现</h4><p>无</p>
<h3 id="4-2-链表实现"><a href="#4-2-链表实现" class="headerlink" title="4.2 链表实现"></a>4.2 链表实现</h3><h4 id="4-2-1-数据节点封装"><a href="#4-2-1-数据节点封装" class="headerlink" title="4.2.1 数据节点封装"></a>4.2.1 数据节点封装</h4><p>无</p>
<h4 id="4-2-2-抽象数据结构"><a href="#4-2-2-抽象数据结构" class="headerlink" title="4.2.2 抽象数据结构"></a>4.2.2 抽象数据结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*成员变量*/</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*成员方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;  <span class="comment">// 元素入栈</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;  <span class="comment">// 元素出栈</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;  <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;  <span class="comment">// 获取栈中元素的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-部分操作实现"><a href="#4-2-3-部分操作实现" class="headerlink" title="4.2.3 部分操作实现"></a>4.2.3 部分操作实现</h4><p>无</p>
<h3 id="4-3-数组和链表实现的对比"><a href="#4-3-数组和链表实现的对比" class="headerlink" title="4.3 数组和链表实现的对比"></a>4.3 数组和链表实现的对比</h3><p>基本没有算法复杂度上的差异。链表栈需要创建node，数组栈偶尔需要resize。</p>
<h2 id="5-队列"><a href="#5-队列" class="headerlink" title="5 队列"></a>5 队列</h2><p><strong>分类</strong>：普通队列、循环队列、双端队列，随机队列、最大最小队列</p>
<h3 id="5-1-普通队列"><a href="#5-1-普通队列" class="headerlink" title="5.1 普通队列"></a>5.1 普通队列</h3><h4 id="5-1-1-数据节点封装"><a href="#5-1-1-数据节点封装" class="headerlink" title="5.1.1 数据节点封装"></a>5.1.1 数据节点封装</h4><p>无</p>
<h4 id="5-1-2-抽象数据结构"><a href="#5-1-2-抽象数据结构" class="headerlink" title="5.1.2 抽象数据结构"></a>5.1.2 抽象数据结构</h4><p><strong>数组实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*成员变量*/</span></span><br><span class="line">    <span class="keyword">private</span> Array&lt;E&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*成员方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;  <span class="comment">// 向队列中添加一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;  <span class="comment">// 从队列中取出一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;  <span class="comment">// 获取队首的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;  <span class="comment">// 获取队列中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*成员变量*/</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*成员方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;  <span class="comment">// 向队列中添加一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;  <span class="comment">// 从队列中取出一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;  <span class="comment">// 获取队首的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;  <span class="comment">// 获取队列中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-部分操作实现"><a href="#5-1-3-部分操作实现" class="headerlink" title="5.1.3 部分操作实现"></a>5.1.3 部分操作实现</h4><p>无</p>
<h3 id="5-2-循环队列"><a href="#5-2-循环队列" class="headerlink" title="5.2 循环队列"></a>5.2 循环队列</h3><p>基于动态数组实现的队列，元素出队列的时候时间复杂度为O(n)，为此引入了循环队列来解决时间复杂度高的问题。 </p>
<h4 id="5-2-1-数据节点封装"><a href="#5-2-1-数据节点封装" class="headerlink" title="5.2.1 数据节点封装"></a>5.2.1 数据节点封装</h4><p>没有</p>
<h4 id="5-2-2-抽象数据结构"><a href="#5-2-2-抽象数据结构" class="headerlink" title="5.2.2 抽象数据结构"></a>5.2.2 抽象数据结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*成员变量*/</span></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*成员方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;  <span class="comment">// 向队列中添加一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;  <span class="comment">// 从队列中取出一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">getFront</span><span class="params">()</span></span>;  <span class="comment">// 获取队首的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;  <span class="comment">// 获取队列中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  <span class="comment">// 判断栈是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-部分操作实现"><a href="#5-2-3-部分操作实现" class="headerlink" title="5.2.3 部分操作实现"></a>5.2.3 部分操作实现</h4><p>front == tail的时候，表示队列为空<br>front == (tail + 1) % c的时候表示队列为满</p>
<h3 id="5-3-双端队列"><a href="#5-3-双端队列" class="headerlink" title="5.3 双端队列"></a>5.3 双端队列</h3><h3 id="5-4-随机队列"><a href="#5-4-随机队列" class="headerlink" title="5.4 随机队列"></a>5.4 随机队列</h3><h3 id="5-5-最大最小队列"><a href="#5-5-最大最小队列" class="headerlink" title="5.5 最大最小队列"></a>5.5 最大最小队列</h3><h2 id="6-树"><a href="#6-树" class="headerlink" title="6 树"></a>6 树</h2><p>树结构本身是一种天然的组织结构，使用树结构进行查找非常的高效。</p>
<p>树的相关概念：</p>
<ul>
<li>根节点、</li>
<li>叶子节点：左右两个孩子都为空的节点</li>
<li>二叉树：每个节点最多有两个孩子</li>
<li>二叉搜索树：首先是一个二叉树，然后满足每个节点的值大于其左子树的所有节点的值，小于其所有右子树的所有节点的值</li>
<li>完全二叉树：把元素顺序排成树的形状</li>
<li>平衡二叉树：</li>
<li>满二叉树：除了叶子节点之外，每个节点都有两个孩子</li>
<li>树的高度<ul>
<li>假设一个树是满二叉树，那么它的每一层上的节点的个数是<code>2^(h-1)</code>个节点(h为层数), 假设它的高度为h，那么这棵树上总共的节点个数是<code>2^0+ 2^1 + 2^2 + ... + 2^(h-1)</code>该值等于<code>2^h - 1</code>，所以<code>2^h - 1 = n</code>，n为数据总量，得到<code>h = log(n+1)以2为底</code></li>
</ul>
</li>
</ul>
<h3 id="6-1-二叉搜索树"><a href="#6-1-二叉搜索树" class="headerlink" title="6.1 二叉搜索树"></a>6.1 二叉搜索树</h3><p>二叉搜索树中的元素相对而言是有顺序的。</p>
<p><strong>定义</strong>：二叉搜索树中，任意一个节点，如果它的左子树不为空，那么左子树的值都小于根节点的值，如果它的右子树不为空，那么右子树的根都大于根节点。</p>
<p><strong>性质</strong>：二叉树的<strong>前序遍历</strong>又叫做<strong>树的深度优先遍历</strong>；二叉搜索树的<strong>中序遍历</strong>得到的是一个<strong>所有元素排序后的结果</strong>；二叉树的<strong>层序遍历</strong>叫做<strong>树的广度优先遍历</strong></p>
<p><strong>缺点</strong>：二叉搜索树在某些场景下会退化成链表</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p><strong>添加元素</strong>：<code>add(root, e)，root为树的根节点，e为待插入的元素，返回值为插入了新节点的树的根节点</code>：从树的根节点开始，将根节点的值与将待添加的元素的值进行比较，如果待插入的元素的值小于根节点的值，那么就待插入的值应该位于树的根节点的左子树上<code>root.left = add(root.left, e)，add的返回值为以root.left为根节点树的根节点</code>；如果待插入的元素的值大于根节点的值，那么待插入的应该位于树的根节点的右子树上<code>root.right = add(root.right, e)，add的返回值为以root.right为根节点的树的根节点</code>，此过程是递归进行的。</p>
</li>
<li><p><strong>查找元素</strong>：</p>
</li>
<li><p><strong>遍历</strong>：</p>
<ul>
<li>前序遍历、</li>
<li>中序遍历、</li>
<li>后序遍历、</li>
<li>层序遍历: 借助一个队列来实现，首先将根节点入队列，然后循环出队列，同时将出队列的节点的左右子树的根节点依次入队列，直到队列为空结束。</li>
</ul>
</li>
<li><p><strong>删除元素</strong></p>
<ul>
<li><p>删除二分搜索树中的最小值: </p>
<ul>
<li>先找到最小值, 从根节点开始一直向左走，直到走不动就是最小值</li>
<li>删除最小值<ul>
<li>待删除的这个节点没有右子树: 这种情况，直接删除该节点就好. <img src="bst%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%80%BC.png" alt="待删除的节点是叶子节点的情况"></li>
<li>待删除的节点有右子树: 这种情况下，先保存待删除节点的右子树，删除该节点之后，将该节点的右子树作为已删除节点的父节点的左子树。<img src="bst%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%80%BC-%E6%9C%89%E5%8F%B3%E5%AD%90%E6%A0%91.png" alt="待删除的节点有右子树"></li>
</ul>
</li>
</ul>
</li>
<li><p>删除二分搜索树中的最大值: 先找到最大值, 从根节点开始一直向右走，直到走不动就是最大值</p>
</li>
<li><p>删除二分搜索树中的任意值</p>
<ul>
<li>如果要删除的节点只有左孩子: <img src="%E5%88%A0%E9%99%A4%E5%8F%AA%E6%9C%89%E5%B7%A6%E5%AD%90%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除的节点只有左子树"></li>
<li>如果要删除的节点只有右孩子: <img src="%E5%88%A0%E9%99%A4%E5%8F%AA%E6%9C%89%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除的节点只有右子树"></li>
<li>如果眼要删除的节点既有左孩子也有右孩子: <img src="%E5%88%A0%E9%99%A4%E5%8C%85%E5%90%AB%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="删除包含左右子树的节点"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待删除的节点为D，替换D的节点为S</span></span><br><span class="line">S = 查找到的D的右子树中的最小值</span><br><span class="line">S.right = 删除了最小值的D的右子树的根节点</span><br><span class="line">S.left = D的左子树</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>树中节点的定义<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E data;</span><br><span class="line">    Node left, right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>树的定义<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="title">extend</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123; <span class="comment">// 要存储的数据一定是可比较的</span></span><br><span class="line">    <span class="keyword">private</span> Node root; <span class="comment">// 数据根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node size; <span class="comment">// 树中节点的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-2-二叉平衡树AVL"><a href="#6-2-二叉平衡树AVL" class="headerlink" title="6.2 二叉平衡树AVL"></a>6.2 二叉平衡树AVL</h3><p>二叉搜索树存在的问题：如果一组数组是有序的添加到一个二叉搜索树中的，此时二叉搜索树会退化成一个链表。AVL是发明人的首字母的组合。</p>
<ul>
<li>平衡二叉树：对于任意节点，左子树的高度和右子树的高度差不能超过1</li>
<li>平衡因子：每个节点，左右子树的高度差</li>
</ul>
<p>avl树是一种平衡的二叉搜索树，既要满足平衡的性质也要满足二分搜索树的性质。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span> <span class="title">extend</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node left, right;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// avl的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvlTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>添加节点：添加节点之后如何判断该树是否平衡？如何维持树的平衡？</p>
<ul>
<li><p>我们知道在向root为根的树中添加节点的时候，要么添加到root节点的左子树，要么添加到root节点的右子树中，如果树的不平衡是因为添加到了root的左子树中，此时应该怎么处理？如果树的不平衡是因为添加到了root的右子树中，此时怎么处理？</p>
</li>
<li><p>如果不平衡是因为添加到了root的左子树中，进行右旋来维护平衡, 具体步骤：</p>
<ul>
<li>以y为根的树中插入了节点z导致了不平衡，y进行右旋转<br><img src="avl%E6%A0%91%E7%9A%84%E5%8F%B3%E6%97%8B.png" alt="avl树的LL"></li>
<li>以y为根的数中插入了节点z导致了不平衡, 先转为LL(x进行左旋转,得到LL)，然后进行右旋维护平衡<br><img src="avl%E6%A0%91%E7%9A%84LR.png" alt="avl树的LR"></li>
</ul>
</li>
<li><p>如果不平衡是因为添加到了root的右子树中，进行左旋来维护平衡，具体如下：</p>
<ul>
<li>以y为根的树中插入了节点z导致了不平衡，y进行左旋转<br><img src="avl%E6%A0%91%E7%9A%84%E5%B7%A6%E6%97%8B.png" alt="avl树的RR"></li>
<li>以y为根的数中插入了节点z导致了不平衡, 先转为RR(x进行右旋,得到RR)，然后进行右旋维护平衡<br><img src="avl%E6%A0%91%E7%9A%84RL.png" alt="avl树的RL"></li>
</ul>
</li>
</ul>
</li>
<li><p>删除节点：按照二叉搜索树的思路进行删除，然后判断删除了节点的树，是否需要维持平衡</p>
<ul>
<li>如果需要维护平衡，采用和插入时相同的方式进行维护平衡, 左旋，右旋</li>
</ul>
</li>
</ul>
<h3 id="6-3-红黑树"><a href="#6-3-红黑树" class="headerlink" title="6.3 红黑树"></a>6.3 红黑树</h3><p>红黑树是一颗二分搜索树，在二分搜索树的基础上添加了一些其他的性质来保证不会退化成链表。</p>
<h4 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h4><p>在2-3树中有两种类型的节点，一种是存放两个元素的节点（3节点），一种是存放一个元素的节点（2节点）;2-3树是一颗绝对平衡的数：对任意一个节点左右两个子树的高度相等。<br><img src="2-3%E6%A0%91.png" alt="2-3树结构"></p>
<p><strong>2-3树中添加节点</strong></p>
<p>向2-3树中添加节点，不会添加到一个空的位置，将待添加的元素添加到最后找到的叶子节点做融合。<br><img src="2-3%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.png" alt="2-3中添加节点"></p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9.png" alt="2-3树和红黑树节点对应关系"></p>
<ul>
<li>所有的红色节点都是向左倾斜的</li>
<li>根节点是黑色的</li>
<li>每一个叶子节点（最后的空节点）是黑色的</li>
<li>红色节点的两个孩子是黑色的</li>
<li>从任意一个节点到叶子节点，经过的黑色的节点个数是形同的</li>
</ul>
<p>红黑树是一颗保持<strong>黑平衡</strong>的二叉树，所谓的黑平衡就是从根节点开始搜索到叶子节点所经历的黑色的节点是相同的。</p>
<p><strong>红黑树中节点的定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点中数据的保存</span></span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="comment">// 节点颜色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> color; <span class="comment">// 是否是红色</span></span><br><span class="line">    <span class="comment">// 节点的左右孩子</span></span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br></pre></td></tr></table></figure>

<p>基本操作</p>
<ul>
<li><p>添加元素: 向红黑树中添加元素可以分为：向2-3树的2节点中添加元素和向2-3树的3节点中添加元素两种大的情况5个小的情况来分，具体如下图：<br>  <img src="%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.png" alt="红黑树中添加节点的情况"></p>
<ul>
<li><p>向一个空树中添加元素（添加的节点初始的时候都是红色的）, 将节点颜色进行更改，维护红黑树的性质。<br>  <img src="%E5%90%91%E4%B8%80%E9%A2%97%E7%A9%BA%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.png" alt="向空树中添加节点"></p>
</li>
<li><p>第1种情况; 直接添加即可，红黑树的性质不会改变<br>  <img src="%E6%B7%BB%E5%8A%A0%E6%AF%94%E6%A0%B9%E8%8A%82%E7%82%B9%E5%85%83%E7%B4%A0%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="添加的元素比根节点的元素小"></p>
</li>
<li><p>第2种情况(向一个2-3树中的二节点中添加一个元素), <code>左旋转</code>操作来维护红黑树的性质<br>  <img src="%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E6%AF%94%E6%A0%B9%E8%8A%82%E7%82%B9%E5%85%83%E7%B4%A0%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9-%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F.png" alt="左旋转"></p>
</li>
<li><p>第3种情况(相当于向一个2-3树的三节点中添加一个元素), 需要进行<code>右旋转</code>操作, 然后进行<code>颜色翻转</code>来维护红黑树的性质<br>  <img src="%E6%B7%BB%E5%8A%A0%E6%AF%94%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E5%B7%A6%E5%AD%90%E6%A0%91%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B903.png" alt="右旋转"></p>
</li>
<li><p>第4种情况，(向一个2-3树的三节点中添加一个元素)，先左旋转，在右旋转，在颜色翻转<br>  <img src="%E6%B7%BB%E5%8A%A0%E6%AF%94%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E5%B7%A6%E5%AD%90%E6%A0%91%E5%A4%A7%E7%9A%84%E8%8A%82%E7%82%B904.png" alt=""></p>
</li>
<li><p>第5种情况<code>颜色翻转</code>来维护红黑树的性质<br>  <img src="%E6%B7%BB%E5%8A%A0%E6%AF%94%E6%A0%B9%E8%8A%82%E7%82%B9%E5%85%83%E7%B4%A0%E5%A4%A7%E7%9A%84%E8%8A%82%E7%82%B902.png" alt="节点颜色翻转"></p>
<p>从上面5种情况可以知道，对于一个node为了维持红黑树的性质所进行的操作可以得出如下的结论：</p>
<ul>
<li>如果<code>node.left != red and node.right == red</code>, node需要进行左旋转</li>
<li>如果<code>node.left == red and node.left.left == red</code>, node需要进行右旋转</li>
<li>如果<code>node.left == red and node.right == red</code>, node需要进行颜色的翻转</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="红黑树和bst和avl树的比较"><a href="#红黑树和bst和avl树的比较" class="headerlink" title="红黑树和bst和avl树的比较"></a>红黑树和bst和avl树的比较</h4><ul>
<li>如果目标数据是完全随机的数据，普通的二分搜索树不会退化成链表，性能还是不错的</li>
<li>对于查询较多的情况，avl树性能不错, 红黑树牺牲了平衡性2logn的高度</li>
<li>红黑树的综合性能跟高，综合增删改查的所有操作</li>
</ul>
<h3 id="6-4-堆"><a href="#6-4-堆" class="headerlink" title="6.4 堆"></a>6.4 堆</h3><p> 二叉堆是一种完全二叉树，为此可以使用数组表示节点之间的关系。二叉堆中每个节点的值总是不大于其父亲节点的值。</p>
<p> 如果一个节点对应到数组中的下标索引为i，那么它的左孩子对应到数组中的下标是：<code>leftChild=i*2</code>(数组中元素的下标从1开始时，如果从零开始<code>2 * i + 1</code>)，它的右孩子对应到数组中的下标是<code>rightChild=i*2 + 1</code>(下标从0开始时是<code>2*i + 2</code>)，它的父亲节点对应到数组中的下标是：<code>parent=i/2</code>(从0开始时是<code>(i - 1) / 2</code>)。</p>
<h4 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h4><ul>
<li><p>向堆中添加一个元素：直接在数组的末尾添加上元素，然后将这个元素进行sift-up上浮操作以维护最大堆的性质。以最大堆为例进行描述, sift-up操作的具体过程如下：</p>
<ul>
<li>将这个节点的值与它的父亲节点的值进行比较</li>
<li>如果这个值大于父节点的值，就将父节点的值和这个值进行交换</li>
<li>直到这个节点的值小于它的父节点的值或者到达了根节点(数组下标为0的节点)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift_up</span><span class="params">(index, heap)</span>:</span></span><br><span class="line">    parent_index = (i - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> index &gt; <span class="number">0</span> <span class="keyword">and</span> heap[index] &gt; heap[parent_index]:</span><br><span class="line">        swap(heap[index], heap[parent_index])</span><br><span class="line">        index = parent_index <span class="comment"># 获取元素的新的下标</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从堆中取出元素: 先将数组末尾的值与堆顶元素进行交换，随后删除数组末尾的元素，然后将这个堆顶的元素进行sift-down下沉操作以维护最大堆的性质。sift-down的具体过程是：</p>
<ul>
<li>首先下沉堆顶元素, 将堆顶元素和它的左右两个孩子进行比较，如果符合下沉的条件，就交换左右两个孩子中较大的那一个</li>
<li>然后下一个要进行下沉的元素是进行了交换的元素（每次要下沉位置的元素，与它的左右两个孩子中的较大值进行比较），进行了交换的元素是通过数组的下标进行索引得到的; <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(index, heap)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> get_left_index(index) &lt; heap.size:</span><br><span class="line">        <span class="comment"># 左右孩子中的较大值</span></span><br><span class="line">        max_index = max_value_index(get_left_index(index), get_right_index(index)) // 获取左右孩子中较大的值的下标</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> heap[index] &gt; heap[max_idnex]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        swap(index, max_index)</span><br><span class="line">        index = max_index</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>将一个数组初始化成一个堆heapify: 先假定给定的这个数组是一个二叉堆，从最后一个<code>非叶子节点</code>开始从后向前不断的进行sift-down操作；最后一个非叶子结点对应的数组下标是：最后一个节点的父亲节点; 时间复杂度为O(n), 如果适应add的方法将数组中的元素添加到堆中时间复杂度为O(nlogn)</p>
</li>
<li><p>将堆中的最大值进行替换replace: 直接将堆顶元素进行替换，然后将替换后的元素进行sift-down操作</p>
</li>
</ul>
<h3 id="6-5-优先队列"><a href="#6-5-优先队列" class="headerlink" title="6.5 优先队列"></a>6.5 优先队列</h3><p>首先是一个队列，它的<code>优先性</code>体现在出队的顺序上，这个队列中元素的<code>出队的顺序</code>和入队的顺序无关而是和元素的优先级相关。</p>
<h3 id="6-6-线段树"><a href="#6-6-线段树" class="headerlink" title="6.6 线段树"></a>6.6 线段树</h3><p>线段树是平衡二叉树。线段树的每一个节点表示的是一个区间内的相应的信息（依据业务逻辑来决定是什么数据，一个区间的和？差？或是其他？一个区间中的最大值）。线段树可以解决区间相关的问题问题： 更新区间，查询区间</p>
<p><img src="%E7%BA%BF%E6%AE%B5%E6%A0%91.png" alt="线段树"></p>
<p>因为我们研究的一个给定的区间，所以在线段树的操作中不涉及添加的操作。一个有n个元素的区间，如果用线段树来表示的话需要多少个节点？</p>
<ul>
<li>线段树可以看成是一个满二叉树，满二叉树中有几个节点？</li>
<li>如果有h层，那么一共的节点个数是2^h - 1 个节点大约是<code>2^h</code>个节点, 其中最后一层的节点数<code>2^(h-1)</code>大致等于前面层数的所有节点之和<code>2^h</code>。</li>
<li>线段树的表示一个区间的时候，最后一层的节点的个数就是区间中元素的个数n, 有上一条的结论<code>最后一层的节点的个数大致等于所有的节点之和</code>, 所以总的节点树大致为<code>n + n = 2n</code>, 在最坏的情况下，还需要在加一层，总数为<code>2n + 2n = 4n</code></li>
</ul>
<h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p>线段树的实现：线段树使用数组来表示，用一个新的数组来表示给定的数组中的区间的值, 新数组中的元素有两层含义</p>
<ul>
<li>表示的是给定数组的哪个区间</li>
<li>表示的是给定数组的这段区间的相应信息的综合</li>
</ul>
<p>基本操作</p>
<ul>
<li><p>创建线段树: 递归创建; 递归函数：需要计算表示线段树的数组中的每个下标的值，要知道它值首先需要先知道左右孩子的值，</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入待求值的数组下标和这个值对应的是哪个区间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_segment_tree</span><span class="params">(index, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        tree[index] = data[l]</span><br><span class="line"></span><br><span class="line">    mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 求index的左孩子的值</span></span><br><span class="line">    build_segment_tree(left_index, l, mid)</span><br><span class="line">    <span class="comment"># 求index的右孩子的值</span></span><br><span class="line">    build_segment_tree(right_index, mid + <span class="number">1</span>, r)</span><br><span class="line">    <span class="comment"># 求index的值</span></span><br><span class="line">    tree[index] = merge(tree[left_index], tree[right_index])</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询线段树: </p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：需要查询的区间[l, r], 线段树的根节点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(index, l, r)</span>:</span></span><br><span class="line">    <span class="comment"># index根节点的值表示的是哪个区间的值[left, right]</span></span><br><span class="line">    <span class="keyword">if</span> left == l <span class="keyword">and</span> right == r:  <span class="comment"># 此时的节点中的值，就是查询的区间的值</span></span><br><span class="line">        <span class="keyword">return</span> tree[index]</span><br><span class="line">    </span><br><span class="line">    mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># index左孩子对应的区间是[left, mid]</span></span><br><span class="line">    <span class="comment"># index右孩子对应的区间是[mid + 1, right]</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= mid + <span class="number">1</span>:  <span class="comment"># 此时说明查询的区间全部在右孩子对应的区间中</span></span><br><span class="line">        <span class="keyword">return</span> query(right_index, l, r) </span><br><span class="line">    <span class="keyword">elif</span> r &lt;= mid:  <span class="comment"># 此时说明查询的区间全部在左孩子对应的区间中</span></span><br><span class="line">        <span class="keyword">return</span> query(left_index, l, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此时，说明查询的区间在index的左右两个孩子的区间中都有</span></span><br><span class="line">    left_result = query(left_index, l, mid)  <span class="comment"># 查询左孩子中的部分</span></span><br><span class="line">    right_result = query(right_index, mid + <span class="number">1</span>, r)  <span class="comment"># 查询右孩子中的部分</span></span><br><span class="line">    <span class="keyword">return</span> merge(left_result, right_result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新线段树</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(root, index, e)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left == right:  <span class="comment"># left, right 表示root节点对应的区间</span></span><br><span class="line">        tree[root] = e</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    mid = left + (right - left) // <span class="number">2</span> </span><br><span class="line">    <span class="keyword">if</span> index &lt;= mid:</span><br><span class="line">        update(left_index, left, mid, index, e)  <span class="comment"># left_index表示root节点的左孩子，它对应的区间是[left, mid]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        update(right_index, mid+<span class="number">1</span>, right, index, e)  <span class="comment"># right_index表示root节点的右孩子，它对应的区间是[mid+1, right]</span></span><br><span class="line">    </span><br><span class="line">    tree[root] = merge(tree[left_index], tree[right_index])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-7-字典树"><a href="#6-7-字典树" class="headerlink" title="6.7 字典树"></a>6.7 字典树</h3><p>字典树是一个多叉树, 专门用来对字符串进行处理的数据结构。</p>
<p><img src="%E5%AD%97%E5%85%B8%E6%A0%91.png" alt="字典树结构"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每个节点的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span></span></span><br><span class="line">        self.is_word = False  # 用来表示从根节点到这个节点是不是一个单词</span><br><span class="line">        self.next_node = &#123;&#125;  <span class="comment"># 用来保存，当前节点的查询到下一个孩子节点的key和value(下一个孩子节点)的映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># trie</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = Node() <span class="comment"># trie的根</span></span><br><span class="line">        self.size = <span class="number">0</span>  <span class="comment"># trie中单词的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本操作</p>
<ul>
<li><p>向字典树中添加一个单词: 将单词中的字符一个个的，添加到字典树中；从根节点开始，判断根节点的<code>next.get(ch)</code>是否为空，如果为空，说明该节点中还没有该字符的映射</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, word)</span>:</span></span><br><span class="line">    cur = self.root</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> cur.next_node.get(c) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cur.next_node[c] = Node()</span><br><span class="line">        cur = cur.next_node[c]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cur.is_word:</span><br><span class="line">        cur.is_word = <span class="literal">True</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断一个单词是否在trie中</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contains</span><span class="params">(self, word)</span>:</span></span><br><span class="line">    cur = self.root</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> cur.next_node.get(c) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = cur.next_node[c]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur.is_word</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断trie中是否有以prefix为前缀的单词</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prefix</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">   cur = self.root</span><br><span class="line">   <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">       <span class="keyword">if</span> cur.next_node.get(c) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">       cur = cur.next_node[c]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-8-并查集"><a href="#6-8-并查集" class="headerlink" title="6.8 并查集"></a>6.8 并查集</h3><p>并查集用来解决连接问题，判断网络节点中的连通问题。</p>
<p>并查集的实现：</p>
<ul>
<li><p>使用数组实现：并查集的实现使用<code>数组</code>：数组的下标用来标识<code>数据的编号</code>，数组的值表示研究的<code>数据所属的集合编号</code></p>
<p>  基本操作</p>
<ul>
<li><p>判断两个元素是否属于同一个集合: 比较两个元素的集合的编号是否相同就可以</p>
</li>
<li><p>合并两个元素的集合：先获取元素p的集合编号s1，在获取元素q的集合编号s2，然后将数组中所有集合编号为s2的所有元素的集合编号改为s1</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># union_find为并查集[]</span></span><br><span class="line"><span class="comment"># 时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(p, q)</span>:</span></span><br><span class="line">    s1 = union_find[p]</span><br><span class="line">    s2 = union_find[q]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, s <span class="keyword">in</span> enumerate(union_find):</span><br><span class="line">        <span class="keyword">if</span> s == s2:</span><br><span class="line">            union_find[i] = s1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用树实现并查集: 这个树中，孩子节点指向父亲节点。这个树的实现可以使用数组：数组的下标表示每个节点的编号，数组中的值表示该节点的父节点的数组下标值。<br>  <img src="%E5%B9%B6%E6%9F%A5%E9%9B%86.png" alt="并查集"><br>  基本操作</p>
<ul>
<li><p>合并两个p和q元素所在的集合：找到p的根节点，找到q的根节点，然后将q的根节点指向p的根节点（可否p的根节点执行q的根节点? 存在优化的空间: 将树中节点个数小的那个树指向节点多的那个树，降低树的高度, 使用一个数组来记录以i为根的树中节点的个数）<br>  <img src="%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88.png" alt="合并两个集合"></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度为O(h)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(p, q)</span>:</span></span><br><span class="line">    root1 = find(p)</span><br><span class="line">    root2 = find(q)</span><br><span class="line"></span><br><span class="line">    union_find[root1] = root2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> p != union_find[p]:</span><br><span class="line">        p = union_find[p]</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断两个元素是否在一个集合中：找到p的根，找到q的根，判断他们的根是否相等，如果相等说是同一个</p>
</li>
</ul>
</li>
</ul>
<p>并查集的优化: 合并的时候，应该将哪个根指向哪个根？</p>
<ul>
<li>基于size的优化</li>
<li>基于rank的优化： 使用一个数组记录以i为根的树的高度, 将高度高树的根指向高度低的树的根</li>
<li>路径压缩：在find的时候维护，<code>parent[p] = parent[parent[0]]</code></li>
</ul>
<h3 id="6-9-B树"><a href="#6-9-B树" class="headerlink" title="6.9 B树"></a>6.9 B树</h3><h2 id="7-集合"><a href="#7-集合" class="headerlink" title="7 集合"></a>7 集合</h2><p>集合中是没有重复元素的。它的实现可以使用数组、链表、二叉树、哈希表基础的数据结构实现。其中集合可以分为有序集合和无序集合，使用用搜索树可以实现有序结合，使用链表、数组、哈希表等实现无序集合</p>
<h2 id="8-映射"><a href="#8-映射" class="headerlink" title="8 映射"></a>8 映射</h2><p>映射定义了key和value。可以使用数组、链表、二叉树这些基础的数据结构实现</p>
<h2 id="9-哈希表"><a href="#9-哈希表" class="headerlink" title="9 哈希表"></a>9 哈希表</h2><p>将key使用hash函数将key转为一个索引，然后将value存储在和索引相同的数组下标对应的数组中 。哈希表示时间和空间之间的平衡。假设有无限的空间，我们可以O(1)的时间复杂度操作，假设只有一个空间，O(N)的时间复杂度操作。</p>
<p>使用hash表的时候，根据数据的规模在初始的时候开辟一个定长的数组(数组的大小，根据数据规模选择一个素数)。但是一般情况下，我们并不能提前知道数据的规模，为此可以使用一个动态数组，必要的时候对动态数组进行扩容和缩容。</p>
<ul>
<li>什么时候进行扩容，平均每个地址放置的元素多到一定程度，即<code>N/M &gt;= 一个值</code> (N为元素的个数，M为数组的大小)</li>
<li>什么时候进行缩容，平均每个地址放置的元素少于一定程度，即<code>N/M &lt;= 一个值</code> (N为元素的个数，M为数组的大小)</li>
<li>扩容和缩容的大小是多少，从一个素数表中选择扩容的大小</li>
</ul>
<h3 id="9-1-哈希函数设计"><a href="#9-1-哈希函数设计" class="headerlink" title="9.1 哈希函数设计"></a>9.1 哈希函数设计</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index &#x3D; hash(key)</span><br></pre></td></tr></table></figure>

<p>key使用的hash函数得到的index分布的越均匀越好。根据key类型的不同，我们可以选择不同的hash函数。</p>
<ul>
<li>key为整数<ul>
<li>小范围的正整数: 直接使用<code>index = key</code></li>
<li>小范围的负整数: 进行偏移<code>index = key + b</code></li>
<li>大整数，如身份证号: <code>index = key % M</code> 对key进行取模<ul>
<li>M的值对hash函数的影响比较大</li>
<li>一般b选择一个素数，这个素数怎么选择？参考</li>
</ul>
</li>
</ul>
</li>
<li>key为浮点数: 转为整数处理，一个浮点数使用的32位或者64位来表示的，将这个32位或者64位转为整数 </li>
<li>key为字符串: 转成大整数处理，可以将字符串（只有小写字母）理解成使用26进制表示的数值，将26进制的数转成10进制的数来表示, 以字符串”hello”为例  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index &#x3D; (h * B^4 + e * B^3 + l * B^2 + l * B^1 + o * B^0) % M  (此处B&#x3D;26)</span><br><span class="line"></span><br><span class="line">可以转换成如下的式子：</span><br><span class="line"></span><br><span class="line">index &#x3D; (((((h % M)*B + e) % M * B + l) % M * B + l) % M * B + o) % M</span><br></pre></td></tr></table></figure></li>
<li>key为复合类型: 转成大整数处理</li>
</ul>
<p><strong>哈希函数设计的原则</strong></p>
<ul>
<li>一致性，同一个值hash之后得到的值相同</li>
<li>高效性</li>
<li>均匀性：哈希值均匀分布</li>
</ul>
<h3 id="9-2-哈希冲突的解决"><a href="#9-2-哈希冲突的解决" class="headerlink" title="9.2 哈希冲突的解决"></a>9.2 哈希冲突的解决</h3><p>不同的key，经过hash函数计算之后得到的索引值可能相同</p>
<h4 id="hash冲突的解决方法"><a href="#hash冲突的解决方法" class="headerlink" title="hash冲突的解决方法"></a>hash冲突的解决方法</h4><p><strong>链地址法</strong></p>
<p>数组中的每个元素是一个查找表（链表、红黑树等）</p>
<p>**</p>
<h2 id="10-图"><a href="#10-图" class="headerlink" title="10 图"></a>10 图</h2><p><strong>基本概念</strong></p>
<ul>
<li>顶点Vertex: 将实际的数据和顶点做映射</li>
<li>边Edge：节点间的关系通过边来表示</li>
<li>自环边</li>
<li>平行边</li>
<li>简单图：没有自环边也没有平行边的图</li>
<li>联通分量<br><img src="%E8%BF%9E%E9%80%9A%E5%9B%BE.png" alt="具有两个联通分量的图"></li>
<li>有环图</li>
<li>无环图, 其实树是一种无环图<br><img src="%E6%97%A0%E7%8E%AF%E5%9B%BE.png" alt="无环图"></li>
<li>联通图的生成树：这个树包含图的所有的顶点但是不是所有的边 <code>v - 1</code>条边<br><img src="%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91.png" alt="联通图的生成树"></li>
<li>度：对于无向图来说一个顶点的度就是这个顶点相邻的边数</li>
<li>稀疏图和稠密图</li>
</ul>
<p><strong>图的分类</strong></p>
<p>根据节点间的边是否有方向，将图分成：</p>
<ul>
<li>无向图 </li>
<li>有向图</li>
</ul>
<p>根据节点间边是否有权重，将图分成：</p>
<ul>
<li>有权图</li>
<li>无权图</li>
</ul>
<p>基于图数据结构相关的算法.</p>
<h3 id="9-1-图的表示"><a href="#9-1-图的表示" class="headerlink" title="9.1 图的表示"></a>9.1 图的表示</h3><p>使用图结构来存储数据的时候，并不是存储我们原始的研究对象中的数据，我们只是把每个数据节点抽象成图中的一个节点，将实际的数据值和节点做一个映射；<strong>实际使用图存储的是: <code>节点的编号</code>和<code>节点间连接的关系</code></strong></p>
<p>邻接矩阵表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// 图中节点的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> E; <span class="comment">// 图中边的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] adj; <span class="comment">// 使用数组的下标，表示节点的编号，使用数组中元素的值表示节点间的关系</span></span><br></pre></td></tr></table></figure>
<p>邻接表表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表表示的图</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// 图中节点的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> E; <span class="comment">// 图中边的个数</span></span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;Integer&gt;[] adj; <span class="comment">// 使用数组的下标，表示节点的编号，使用数组中元素的值表示与之相连的节点编号</span></span><br></pre></td></tr></table></figure>
<p>使用邻接矩阵表示一个图：空间复杂度为<code>O(v*v)</code>，<br>使用邻接表表示一个图：空间复杂度为 <code>O(v + e)</code>, 邻接表表示的图在判断两个点是否相邻的时候，使用数组或者链表时间复杂度过高，此时可以使用<code>红黑树</code>或者<code>hash表</code>加快查找，但是使用<code>红黑树</code>可以保证节点的顺序性</p>
<h3 id="9-2-图的遍历"><a href="#9-2-图的遍历" class="headerlink" title="9.2 图的遍历"></a>9.2 图的遍历</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><h4 id="广度优先的遍历"><a href="#广度优先的遍历" class="headerlink" title="广度优先的遍历"></a>广度优先的遍历</h4><h4 id="图的遍历的应用"><a href="#图的遍历的应用" class="headerlink" title="图的遍历的应用"></a>图的遍历的应用</h4><h3 id="9-3-图相关的算法"><a href="#9-3-图相关的算法" class="headerlink" title="9.3 图相关的算法"></a>9.3 图相关的算法</h3>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>rust编程入门</title>
    <url>/2019/12/19/rust%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本文简单的记录了一些rust语言的基础知识。</p>
<a id="more"></a>

<h1 id="rust编程基础"><a href="#rust编程基础" class="headerlink" title="rust编程基础"></a>rust编程基础</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1 变量"></a>1 变量</h2><h3 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h3><h4 id="1-1-1-struct结构"><a href="#1-1-1-struct结构" class="headerlink" title="1.1.1 struct结构"></a>1.1.1 struct结构</h4><p><strong>结构体的定义</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例化结构体</strong></p>
<p>方法1：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法2：字段初始化简写语法，当参数名与字段名都完全相同</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法3：结构体更新语法，从其他结构体中创建实例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    active: user1.active,</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    ..user1 <span class="comment">// .. 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>注意：Rust并不允许只将结构体某个字段标记为可变</em> </p>
<p><strong>元组结构体</strong></p>
<p>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>类单元结构体</strong></p>
<p>没有任何字段的结构体被称为<strong>类单元结构体</strong>。</p>
<h3 id="1-2-创建"><a href="#1-2-创建" class="headerlink" title="1.2 创建"></a>1.2 创建</h3><h3 id="1-3-作用域"><a href="#1-3-作用域" class="headerlink" title="1.3 作用域"></a>1.3 作用域</h3><h2 id="2-逻辑控制"><a href="#2-逻辑控制" class="headerlink" title="2 逻辑控制"></a>2 逻辑控制</h2><h3 id="2-1-循环控制"><a href="#2-1-循环控制" class="headerlink" title="2.1 循环控制"></a>2.1 循环控制</h3><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><h3 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1 创建"></a>3.1 创建</h3><h3 id="3-2-调用"><a href="#3-2-调用" class="headerlink" title="3.2 调用"></a>3.2 调用</h3><h3 id="3-3-其他"><a href="#3-3-其他" class="headerlink" title="3.3 其他"></a>3.3 其他</h3><h4 id="3-3-1-闭包"><a href="#3-3-1-闭包" class="headerlink" title="3.3.1 闭包"></a>3.3.1 闭包</h4><p><strong>什么是闭包</strong></p>
<p>在rust中闭包是匿名函数。</p>
<p><strong>闭包的定义</strong></p>
<p>闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数；之所以选择这个语法是因为它与 Smalltalk 和 Ruby 的闭包定义类似。这个闭包有一个参数 num；如果有多于一个参数，可以使用逗号分隔，比如 |param1, param2|。参数之后是存放闭包体的大括号 —— 如果闭包体只有一行则大括号是可以省略的。大括号之后闭包的结尾，需要用于 let 语句的分号。因为闭包体的最后一行没有分号（正如函数体一样），所以闭包体（num）最后一行的返回值作为调用闭包时的返回值 。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> expensive_closure = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中：闭包定义是 expensive_closure 赋值的 = 之后的部分</p>
<p><strong>闭包与函数的区别</strong></p>
<p>闭包不要求像 fn 函数那样在参数和返回值上注明类型。函数中需要类型注解是因为他们是暴露给用户的显式接口的一部分。严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的。但是闭包并不用于这样暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用。闭包通常很短并只与对应相对任意的场景较小的上下文中。在这些有限制的上下文中，编译器能可靠的推断参数和返回值的类型，类似于它是如何能够推断大部分变量的类型一样。但是也可以选择增加类型注解：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> expensive_closure = |num: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面的定义具有相同的作用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> add_one_v2 = |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v3 = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> add_one_v4 = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>

<p><strong>move关键字</strong></p>
<p>你希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用<code>move</code>关键字。在将闭包传递给新线程以便将数据移动到新线程中时最为实用。</p>
<h2 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4 面向对象"></a>4 面向对象</h2><h3 id="4-1-类的定义"><a href="#4-1-类的定义" class="headerlink" title="4.1 类的定义"></a>4.1 类的定义</h3><h4 id="4-1-1-属性和方法的权限控制"><a href="#4-1-1-属性和方法的权限控制" class="headerlink" title="4.1.1 属性和方法的权限控制"></a>4.1.1 属性和方法的权限控制</h4><h3 id="4-2-接口的定义"><a href="#4-2-接口的定义" class="headerlink" title="4.2 接口的定义"></a>4.2 接口的定义</h3><h3 id="4-3-对象的创建"><a href="#4-3-对象的创建" class="headerlink" title="4.3 对象的创建"></a>4.3 对象的创建</h3><h2 id="5-错误及异常处理"><a href="#5-错误及异常处理" class="headerlink" title="5 错误及异常处理"></a>5 错误及异常处理</h2><h3 id="5-1-不可恢复的错误处理"><a href="#5-1-不可恢复的错误处理" class="headerlink" title="5.1 不可恢复的错误处理"></a>5.1 不可恢复的错误处理</h3><p>由于某些我们没有预料到的问题导致程序终止执行，或者在不满足某些条件的时候我们希望终止程序的执行。在大部分的编程语言中，出现错误的时候程序会直接崩掉，并打印出程序错误时的堆栈信息，也可以在不满足某些情况的时候直接抛出一下我们自定义的异常。在Rust中，处理程序中的错误是通过<code>panic!</code>这一宏来实现的。对于程序终止时的输出内容有两种选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 对程序出现错误的地方进行栈展开</span><br><span class="line">2. 对程序出现错误直接终止程序的执行</span><br></pre></td></tr></table></figure>

<p><em>最佳实践：如果实在release版本中，我们希望项目最终的二进制文件越小越好，此时可以在Cargo.toml文件中增加panic=‘abort’，可以有展开切换为终止</em></p>
<h3 id="5-2-可以恢复的错误处理"><a href="#5-2-可以恢复的错误处理" class="headerlink" title="5.2 可以恢复的错误处理"></a>5.2 可以恢复的错误处理</h3><p>首先，我们应该知道，在rust中有些函数的返回值是Result类型，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code>代表成功时返回的Ok成员中的数据类型，<code>E</code>代表失败时返回的<code>Err</code>成员中的错误的类型。</p>
<p>并不是所有的错误，我们都想要让程序终止执行。此时，我们选择可以匹配这个错误，然后执行一些我们需要执行的动作。可以使用<code>match</code>语句来进行匹配，也可以使用<code>unwrap</code>和<code>expect</code>来简写<code>match</code>匹配。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unwrap</code>: 如果<code>Resut</code>中的成员是<code>Ok</code>，<code>unwrap</code>会返回<code>Ok</code>中的值，如果<code>Result</code>中的成员是<code>Err</code>，<code>unwrap</code>会调用<code>panic!</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>except</code>: 该方法能够允许我们自定义<code>panic!</code>时的错误信息。</p>
<h3 id="5-3-错误的传递"><a href="#5-3-错误的传递" class="headerlink" title="5.3 错误的传递"></a>5.3 错误的传递</h3><p>有时候，我们并不希望在函数中处理错误，而是将错误返回给函数的调用者。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.read_to_string(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(_) =&gt; <span class="literal">Ok</span>(s),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的错误的传播太过于复杂，在rust中可以使用<code>?</code>运算符来简写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-包和模块"><a href="#6-包和模块" class="headerlink" title="6 包和模块"></a>6 包和模块</h2><p>在我们平时开发中创建的项目要么是提供给别人使用的lib库文件，要么是最后编译之后可以执行文件。<br>rust中的包叫做crate，每个包装箱(crate)有一个隐含的根模块（root module）包含了该包装箱的代码. rust中的模块是模块树结构，Cargo 遵循的一个约定：src/main.rs 就是一个与包同名的二进制 crate 的 crate 根。同样的，Cargo 知道如果包目录中包含 src/lib.rs，则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根。 如果一个包同时含有 src/main.rs 和 src/lib.rs，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 src/bin 目录下，一个包可以享有多个二进制 crate：每个文件都是一个分离出来的二进制 crate。</p>
<h3 id="6-1-创建和导入"><a href="#6-1-创建和导入" class="headerlink" title="6.1 创建和导入"></a>6.1 创建和导入</h3><h4 id="6-1-1-包的创建"><a href="#6-1-1-包的创建" class="headerlink" title="6.1.1 包的创建"></a>6.1.1 包的创建</h4><p><code>cargo new my-project</code></p>
<h4 id="6-1-2-模块的创建"><a href="#6-1-2-模块的创建" class="headerlink" title="6.1.2 模块的创建"></a>6.1.2 模块的创建</h4><p>使用<code>mod</code>关键字来定义模块。定义的方式有两种：</p>
<p>定义方式1：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> english &#123;</span><br><span class="line">    <span class="comment">// Contents of our module go here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义方式2：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> english;</span><br></pre></td></tr></table></figure>
<p>使用第二种方式定义：表示Rust会期望能找到一个包含我们模块内容的english.rs文件，或者包含我们模块内容的english/mod.rs文件</p>
<h4 id="6-1-3-模块的引用"><a href="#6-1-3-模块的引用" class="headerlink" title="6.1.3 模块的引用"></a>6.1.3 模块的引用</h4><p>模块的使用就是，引用模块树中的项。在Rust 如何在模块树中找到一个项的位置，使用路径的方式，就像在文件系统使用路径一样。如果我们想要调用一个函数，我们需要知道它的路径。路径有两种形式：相对路径和绝对路径。使用<code>use</code>关键字使用模块中的函数。</p>
<h3 id="6-2-访问权限控制"><a href="#6-2-访问权限控制" class="headerlink" title="6.2 访问权限控制"></a>6.2 访问权限控制</h3><p>在Rust中默认所有的模块和模块内的函数都是私有的。可以使用<code>pub</code>关键字将模块或者模块内的函数导出。但是在私有模块中的函数都必须是私有的，在公有模块中的函数可以是私有的也可以是公开的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> a_public_module &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">a_public_function</span></span>() &#123;</span><br><span class="line">        <span class="comment">// 公有的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">a_private_function</span></span>() &#123;</span><br><span class="line">        <span class="comment">// 私有的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> a_private_module &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">a_private_function</span></span>() &#123;</span><br><span class="line">        <span class="comment">// 私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-第三方库的管理和下载"><a href="#6-3-第三方库的管理和下载" class="headerlink" title="6.3 第三方库的管理和下载"></a>6.3 第三方库的管理和下载</h3><p>在rust中如果使用别人的crate需要在Cargo.toml文件中将依赖添加进去：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">"0.5.5"</span></span><br></pre></td></tr></table></figure>
<p>在 Cargo.toml 中加入 rand 依赖告诉了 Cargo 要从 crates.io 下载 rand 和其依赖，并使其可在项目代码中使用</p>
<h3 id="6-4-常用的标准库"><a href="#6-4-常用的标准库" class="headerlink" title="6.4 常用的标准库"></a>6.4 常用的标准库</h3><h2 id="7-并发编程"><a href="#7-并发编程" class="headerlink" title="7 并发编程"></a>7 并发编程</h2><h3 id="7-1-进程"><a href="#7-1-进程" class="headerlink" title="7.1 进程"></a>7.1 进程</h3><h3 id="7-2-线程"><a href="#7-2-线程" class="headerlink" title="7.2 线程"></a>7.2 线程</h3><h3 id="7-3-协程"><a href="#7-3-协程" class="headerlink" title="7.3 协程"></a>7.3 协程</h3><h2 id="8-语言特性"><a href="#8-语言特性" class="headerlink" title="8 语言特性"></a>8 语言特性</h2><h3 id="8-1-rust所有权"><a href="#8-1-rust所有权" class="headerlink" title="8.1 rust所有权"></a>8.1 rust所有权</h3><h4 id="8-1-1-所有权的概念"><a href="#8-1-1-所有权的概念" class="headerlink" title="8.1.1 所有权的概念"></a>8.1.1 所有权的概念</h4><p>所有权所说的是：程序中的<strong>值</strong>，每个值都有一个被称为其所有者的变量，并且有且仅有唯一的所有者。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> var = <span class="string">"hello world"</span>  <span class="comment">// "hello world"这个值的所有者是 var</span></span><br></pre></td></tr></table></figure>

<h4 id="8-1-2-所有权的借用"><a href="#8-1-2-所有权的借用" class="headerlink" title="8.1.2 所有权的借用"></a>8.1.2 所有权的借用</h4><p>在rust中的引用是允许使用值但是不获取所有权，这种操作被称为<strong>所有权借用</strong></p>
<h3 id="8-2-模式匹配"><a href="#8-2-模式匹配" class="headerlink" title="8.2 模式匹配"></a>8.2 模式匹配</h3><p>match表达式</p>
<h2 id="9-最佳实践"><a href="#9-最佳实践" class="headerlink" title="9 最佳实践"></a>9 最佳实践</h2><blockquote>
<p>参考</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MjAzNDI1MA==&mid=2648210254&idx=1&sn=08124b76f639aec44e7446e43a15ac1f&chksm=f1c536ebc6b2bffdcfa23cd3f434570d9c88d3a698da1b1adc8ffca846d2004b8449672eecc3&mpshare=1&scene=1&srcid=&sharer_sharetime=1576727581650&sharer_shareid=bd726766a074fa81de1978890c5213aa%23rd" target="_blank" rel="noopener">如何理解rust中的可变与不可变</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn" target="_blank" rel="noopener">Rust程序语言设计</a></li>
</ol>
</blockquote>
<h1 id="rust网络编程"><a href="#rust网络编程" class="headerlink" title="rust网络编程"></a>rust网络编程</h1><h2 id="1-基础套接字"><a href="#1-基础套接字" class="headerlink" title="1 基础套接字"></a>1 基础套接字</h2><h2 id="2-异步网络编程s"><a href="#2-异步网络编程s" class="headerlink" title="2 异步网络编程s"></a>2 异步网络编程s</h2>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2019/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>本文简单的记录了常用的设计原则和设计模式。</p>
<a id="more"></a>
<h2 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1 设计原则"></a>1 设计原则</h2><h3 id="1-1-单一职责"><a href="#1-1-单一职责" class="headerlink" title="1.1 单一职责"></a>1.1 单一职责</h3><h3 id="1-2-里氏代换"><a href="#1-2-里氏代换" class="headerlink" title="1.2 里氏代换"></a>1.2 里氏代换</h3><h3 id="1-3-依赖倒转"><a href="#1-3-依赖倒转" class="headerlink" title="1.3 依赖倒转"></a>1.3 依赖倒转</h3><h3 id="1-4-接口隔离"><a href="#1-4-接口隔离" class="headerlink" title="1.4 接口隔离"></a>1.4 接口隔离</h3><h3 id="1-5-迪米特法则"><a href="#1-5-迪米特法则" class="headerlink" title="1.5 迪米特法则"></a>1.5 迪米特法则</h3><h3 id="1-6-开闭原则"><a href="#1-6-开闭原则" class="headerlink" title="1.6 开闭原则"></a>1.6 开闭原则</h3><h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2 设计模式"></a>2 设计模式</h2><h3 id="2-1-单例模式"><a href="#2-1-单例模式" class="headerlink" title="2.1 单例模式"></a>2.1 单例模式</h3><p>一个类只能实例化一个对象。类的构造函数私有，将这个实例设置为类的属性，并对外提供一个获取该实例的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只能实例化一个类对象</span></span><br><span class="line"><span class="comment">     * 将构造函数设置为私有的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo singletonDemo = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonDemo instance = SingletonDemo.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        SingletonDemo instance2 = SingletonDemo.getInstance();</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-工厂模式"><a href="#2-2-工厂模式" class="headerlink" title="2.2 工厂模式"></a>2.2 工厂模式</h3>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用总结</title>
    <url>/2019/12/16/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-常用的技巧整理"><a href="#1-常用的技巧整理" class="headerlink" title="1. 常用的技巧整理"></a>1. 常用的技巧整理</h2><h3 id="1-1-合并指定的commit到指定的分支"><a href="#1-1-合并指定的commit到指定的分支" class="headerlink" title="1.1 合并指定的commit到指定的分支"></a>1.1 合并指定的commit到指定的分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout dev  <span class="comment"># 切换到指定的分支</span></span><br><span class="line">git cherry-pick commit-id  <span class="comment"># 合并commit-id的提交到分支</span></span><br></pre></td></tr></table></figure>


<h2 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3 最佳实践"></a>3 最佳实践</h2><h3 id="3-1-提交"><a href="#3-1-提交" class="headerlink" title="3.1 提交"></a>3.1 提交</h3><p>使每一次的commit都是一个有效的commit。提交的粒度最好做到一个功能点或者一个bug fix做一次提交。对于每一次commit不一定要进行push，可以等commit次数多了的时候在进行push操作。</p>
<h3 id="3-2-分支管理"><a href="#3-2-分支管理" class="headerlink" title="3.2 分支管理"></a>3.2 分支管理</h3><p>一个好的分支管理，可以使得每次上线省心，如果没有一个好的分支管理策略是真心的累。可以使用Git Flow来进行分支的管理。</p>
<p>常用的分支及功能说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master - 该分支是随时可以发布的代码</span><br><span class="line">develop - 功能最新最全的分支</span><br><span class="line">hotfix - 修复线上的bug，多个人修复多个bug的时候，可以有多个该分支</span><br><span class="line">feature - 开发某个功能的分支，如果有多个人在开发多个功能可以有多个分支</span><br><span class="line">release - 发布定期要上线的功能</span><br></pre></td></tr></table></figure>

<p><strong>使用Git Flow的基本工作流程</strong> </p>
<p>以张三开发一个新的功能为例，流程如下：</p>
<ol>
<li>张三基于develop分支创建一个对应的myfeature分支： </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b myfeature develop  <span class="comment"># 创建myfeature分支并切换到该分支</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>张三在myfeature分支上进行日常开发：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add file.py  <span class="comment"># 添加文件</span></span><br><span class="line">git commit -m <span class="string">"my commit"</span>  <span class="comment"># 提交commit</span></span><br><span class="line">git push  <span class="comment"># 推送分支</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>三天之后张三完成了新功能的开发，需要进行测试了</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout development  <span class="comment"># 切换到develp分支</span></span><br><span class="line">git pull  <span class="comment"># 更新develop分支代码到最新</span></span><br><span class="line">git merge --no-ff myfeature  <span class="comment"># 将myfeature分支合并到develop分支上</span></span><br><span class="line">git branch -d myfeature  <span class="comment"># 删除myfeature分支</span></span><br><span class="line">git push origin develop  <span class="comment"># 将dev分支推送到远端</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试人员李四要对张三开发的功能进行测试了</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b release-1.2 develop  <span class="comment"># 李四创建一个release-1.2分支，然后将该分支部署到测试环境</span></span><br></pre></td></tr></table></figure>
<p>李四发现了一个bug，告诉了张三。</p>
<ol start="5">
<li>张三修复bug</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull release-1.2  <span class="comment"># 张三拉取release-1.2分支</span></span><br><span class="line">git commit -m <span class="string">"fix bug 111"</span>  <span class="comment"># 张三修复bug</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>李四完成了测试，王五进行上线</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release-1.2</span><br><span class="line">git tag -a 1.2</span><br><span class="line"></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release-1.2</span><br><span class="line">git branch -d release-1.2</span><br></pre></td></tr></table></figure>

<p>王五上线 tag 1.2 </p>
<ol start="7">
<li>功能上线之后，发现了一个线上的bug，张三开始修复线上的bug</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b hotfix-1.2.1 master  <span class="comment"># 张三创建一个hotfix分支</span></span><br><span class="line">git commit -m <span class="string">"Fixed severe production problem"</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>李四进行测试，然后王五上线</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff hotfix-1.2.1</span><br><span class="line">git tag -a 1.2.1</span><br><span class="line"></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff hotfix-1.2.1</span><br><span class="line">git branch -d hotfix-1.2.1</span><br></pre></td></tr></table></figure>

<p>参考</p>
<blockquote>
<p><a href="https://wangchujiang.com/linux-command/c/git.html" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/c/git.html</a><br><a href="https://opensource.com/article/18/4/git-tips" target="_blank" rel="noopener">https://opensource.com/article/18/4/git-tips</a><br><a href="https://github.com/twtrubiks/Git-Tutorials" target="_blank" rel="noopener">https://github.com/twtrubiks/Git-Tutorials</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwMjk5Mjk3Mw==&mid=2247487043&idx=2&sn=1824a77f2fc2657dcefd97a4bcb8f169&chksm=9ac0b061adb73977fe4e6538cae71ebbeb4e46ce6db3543b26c9248e3d3fcb29d3debf762354&mpshare=1&scene=1&srcid=0101VuPUEx2NJgjPzMHJAGgn&sharer_sharetime=1577855337261&sharer_shareid=bd726766a074fa81de1978890c5213aa%23rd" target="_blank" rel="noopener">团队开发中 Git 最佳实践，不给队友拖后腿</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript编程</title>
    <url>/2019/12/15/TypeScript%E7%BC%96%E7%A8%8B-md/</url>
    <content><![CDATA[<p>本文简单记录TypeScript中的最基本的知识点</p>
<a id="more"></a>

<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1 变量"></a>1 变量</h2><h3 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h3><h3 id="1-2-创建"><a href="#1-2-创建" class="headerlink" title="1.2 创建"></a>1.2 创建</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  <span class="comment">// 使用 var 定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>  <span class="comment">// 使用 let 定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>  <span class="comment">// 使用const声明常量</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-作用域"><a href="#1-3-作用域" class="headerlink" title="1.3 作用域"></a>1.3 作用域</h3><h2 id="2-逻辑控制"><a href="#2-逻辑控制" class="headerlink" title="2 逻辑控制"></a>2 逻辑控制</h2><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h2><h3 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1 创建"></a>3.1 创建</h3><h3 id="3-2-调用"><a href="#3-2-调用" class="headerlink" title="3.2 调用"></a>3.2 调用</h3><h3 id="3-3-其他"><a href="#3-3-其他" class="headerlink" title="3.3 其他"></a>3.3 其他</h3><h2 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4 面向对象"></a>4 面向对象</h2><h3 id="4-1-类的定义"><a href="#4-1-类的定义" class="headerlink" title="4.1 类的定义"></a>4.1 类的定义</h3><p><code>类本身</code>和<code>类的实例</code>两个概念。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    move(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"animal move"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-属性和方法的权限控制"><a href="#4-1-1-属性和方法的权限控制" class="headerlink" title="4.1.1 属性和方法的权限控制"></a>4.1.1 属性和方法的权限控制</h4><p>在ts中，成员变量和成员方法默认是public的</p>
<h3 id="4-2-接口的定义"><a href="#4-2-接口的定义" class="headerlink" title="4.2 接口的定义"></a>4.2 接口的定义</h3><h3 id="4-3-对象的创建"><a href="#4-3-对象的创建" class="headerlink" title="4.3 对象的创建"></a>4.3 对象的创建</h3><h2 id="5-异常处理"><a href="#5-异常处理" class="headerlink" title="5 异常处理"></a>5 异常处理</h2><h2 id="6-包和模块"><a href="#6-包和模块" class="headerlink" title="6 包和模块"></a>6 包和模块</h2><h3 id="6-1-创建和导入"><a href="#6-1-创建和导入" class="headerlink" title="6.1 创建和导入"></a>6.1 创建和导入</h3><h3 id="6-2-访问权限控制"><a href="#6-2-访问权限控制" class="headerlink" title="6.2 访问权限控制"></a>6.2 访问权限控制</h3><h3 id="6-3-第三方库的管理和下载"><a href="#6-3-第三方库的管理和下载" class="headerlink" title="6.3 第三方库的管理和下载"></a>6.3 第三方库的管理和下载</h3><h3 id="6-4-常用的标准库"><a href="#6-4-常用的标准库" class="headerlink" title="6.4 常用的标准库"></a>6.4 常用的标准库</h3><h2 id="7-并发编程"><a href="#7-并发编程" class="headerlink" title="7 并发编程"></a>7 并发编程</h2><h3 id="7-1-进程"><a href="#7-1-进程" class="headerlink" title="7.1 进程"></a>7.1 进程</h3><h3 id="7-2-线程"><a href="#7-2-线程" class="headerlink" title="7.2 线程"></a>7.2 线程</h3><h3 id="7-3-协程"><a href="#7-3-协程" class="headerlink" title="7.3 协程"></a>7.3 协程</h3><h2 id="8-语言特性"><a href="#8-语言特性" class="headerlink" title="8 语言特性"></a>8 语言特性</h2><h2 id="9-最佳实践"><a href="#9-最佳实践" class="headerlink" title="9 最佳实践"></a>9 最佳实践</h2>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode使用</title>
    <url>/2019/12/07/vscode%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文主要介绍了在Mac上使用vscode开发的一些常用的快捷键以及插件</p>
<a id="more"></a>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>code命令</strong></p>
<ol>
<li>将该命令添加到环境变量，可以直接使用命令启动vscode</li>
<li><code>code .</code> 可以直接打开当前所在的文件夹</li>
<li><code>code filename</code> 可以快速的打开指定的文件</li>
</ol>
<p><strong>恢复默认设置</strong></p>
<p>删除以下两个文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Users&#x2F;用户名&#x2F;.vscode</span><br><span class="line">&#x2F;Users&#x2F;用户名&#x2F;Library&#x2F;Application Support&#x2F;Code</span><br></pre></td></tr></table></figure>

<h2 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h2><p><strong>command + shift + p</strong>：这个快捷键是最常用的</p>
<p><strong>command + p</strong>: 该快捷键也是万能的，在弹出的框中输入<code>&gt;</code>可以达到和<code>command + shift +p</code>同样的效果</p>
<p><strong>F5</strong>: 进行调试</p>
<h2 id="常用的插件介绍"><a href="#常用的插件介绍" class="headerlink" title="常用的插件介绍"></a>常用的插件介绍</h2><ol>
<li>docker: 可以方便的管理本地安装的docker相关的东西</li>
<li>coderuner: 可以方便的运行该代码</li>
<li>Project Manager: 可以方便的将打开的项目进行保存，方便下次直接打开</li>
<li>GitHub Pull Request: 方便使用GitHub</li>
<li>Gitlens: 可以方便查看代码的修改、提交记录</li>
<li>根据开发的语言的不同可以选择对应语言开发相关的插件</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>erlang编程</title>
    <url>/2019/12/07/erlang%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>curl工具使用</title>
    <url>/2019/11/17/curl%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl www.baidu.com  # 直接使用</span><br><span class="line">curl -v www.baidu.com  # 可以查看详细的整个http通信过程</span><br></pre></td></tr></table></figure>

<h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="在请求头中添加参数"><a href="#在请求头中添加参数" class="headerlink" title="在请求头中添加参数"></a><strong>在请求头中添加参数</strong></h3><p>使用<code>-H</code>指定参数，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H "Content-Type:application/json" -H "requestid:1111"</span><br></pre></td></tr></table></figure>
<p>每一个参数都要使用<code>-H</code>进行指定</p>
<h3 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a><strong>发送post请求</strong></h3><h4 id="请求头中添加参数"><a href="#请求头中添加参数" class="headerlink" title="请求头中添加参数"></a>请求头中添加参数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d “username=xiao&amp;passwd=1234” url</span><br></pre></td></tr></table></figure>
<h4 id="请求体中发送json数据"><a href="#请求体中发送json数据" class="headerlink" title="请求体中发送json数据"></a>请求体中发送json数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d '&#123;"student_id": "1233253535", "work_id": "2019007350001"&#125;'</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>算法专题</title>
    <url>/2019/08/21/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>本文总结了常用的算法思想、常用的算法以及常见的算法技巧。</p>
<a id="more"></a>

<h2 id="0-绪论"><a href="#0-绪论" class="headerlink" title="0 绪论"></a>0 绪论</h2><p>常用的<strong>算法设计及优化思想</strong>：暴力穷举、分治、贪心、动态规划、线性规划、回溯；掌握了常用的算法思想我们可以设计算法。<br>算法的实现方法：递归与迭代，顺序、并行与分布式<br>常用的<strong>经典</strong>算法：排序问题相关的算法、查找问题相关的算法、字符串匹配问题相关的算法、图相关的算法；</p>
<p>常用的<strong>算法技巧</strong>：</p>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol>
<li>算法的时间复杂度分析</li>
<li>算法的优化</li>
<li>算法的设计</li>
</ol>
<h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1 时间复杂度"></a>1 时间复杂度</h2><p>最坏时间复杂度<br>平均时间复杂度<br>最优时间复杂度<br>均摊复杂度</p>
<p>O(1) &gt; O(logn) &gt; O(n) &gt; O(nlogn) &gt; O(n^2)</p>
<p><strong>递归方程</strong></p>
<p>T(n) = O(1)             if n = 1<br>T(n) = aT(n/b) + f(n)   if n &gt; 1</p>
<p>master定理求解T(n)</p>
<h2 id="2-算法设计模式"><a href="#2-算法设计模式" class="headerlink" title="2 算法设计模式"></a>2 算法设计模式</h2><h3 id="2-1-暴力搜索"><a href="#2-1-暴力搜索" class="headerlink" title="2.1 暴力搜索"></a>2.1 暴力搜索</h3><h3 id="2-2-分治"><a href="#2-2-分治" class="headerlink" title="2.2 分治"></a>2.2 分治</h3><p>分为三个阶段：</p>
<ul>
<li>划分：整个问题划分成多个子问题</li>
<li>求解：求解各子问题，递归的调用正在设计的算法</li>
<li>合并：合并子问题的解，形成原始问题的解</li>
</ul>
<h3 id="2-3-图的搜索"><a href="#2-3-图的搜索" class="headerlink" title="2.3 图的搜索"></a>2.3 图的搜索</h3><h3 id="2-4-动态规划"><a href="#2-4-动态规划" class="headerlink" title="2.4 动态规划"></a>2.4 动态规划</h3><h3 id="2-5-贪心"><a href="#2-5-贪心" class="headerlink" title="2.5 贪心"></a>2.5 贪心</h3><h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3 算法实现"></a>3 算法实现</h2><h3 id="3-1-递归与迭代"><a href="#3-1-递归与迭代" class="headerlink" title="3.1 递归与迭代"></a>3.1 递归与迭代</h3><p>有关树，链表的等相关问题是天然递归的一类问题。递归算法最重要的一点就是实现<strong>递归函数</strong>。关于递归函数我们要从宏观层面去思考：</p>
<ul>
<li>这个递归函数是干什么的</li>
<li>这个递归函数的输入是什么</li>
<li>这个递归函数的输出是什么</li>
</ul>
<p>递归函数可以理解成，在一个函数中需要调用另一个函数，只是刚好另一个函数的函数签名和自己相同。</p>
<h4 id="2-1-1-树的递归"><a href="#2-1-1-树的递归" class="headerlink" title="2.1.1 树的递归"></a>2.1.1 树的递归</h4><p>树相关的递归函数的定义：</p>
<ul>
<li>输入：其中必有一个参数为子树的根</li>
<li>输出：输出经过处理了之后的子树的根</li>
</ul>
<h4 id="2-1-2-链表的递归"><a href="#2-1-2-链表的递归" class="headerlink" title="2.1.2 链表的递归"></a>2.1.2 链表的递归</h4><p>链表相关的递归函数的定义</p>
<ul>
<li>输入：子链表的头节点</li>
<li>输出：经过了处理之后的子链表的头</li>
</ul>
<h3 id="3-2-顺序、并行与分布式"><a href="#3-2-顺序、并行与分布式" class="headerlink" title="3.2 顺序、并行与分布式"></a>3.2 顺序、并行与分布式</h3><h2 id="4-经典算法"><a href="#4-经典算法" class="headerlink" title="4 经典算法"></a>4 经典算法</h2><h3 id="3-1-排序算法"><a href="#3-1-排序算法" class="headerlink" title="3.1 排序算法"></a>3.1 排序算法</h3><p>常见的排序算法有：</p>
<ul>
<li>冒泡排序：O(n^2)</li>
<li>选择排序：O(n^2)</li>
<li>插入排序：O(n^2), 对于一个近乎有序的数据，因为插入排序能够提前终止，它的效率是非常的高的，甚至比nlogn的排序算法效率高；是一个稳定的排序</li>
<li>归并排序：O(nlogn)，归并排序可以分成logn层级，每一层级用n复杂度的方法处理；也是一个稳定的排序</li>
<li>快速排序：O(nlogn), 不稳定</li>
<li>堆排序：O(nlogn)，不稳定</li>
</ul>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>基本思路</strong></p>
<p>对数组中的元素进行遍历，每一次的遍历都找到从当前位置到末尾的元素中的最大值，然后将当前位置的元素和最大值位置的元素进行交换</p>
<p><strong>伪代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(array, n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        max_index = find_max(array[i+<span class="number">1</span>:])  <span class="comment"># find_max查找[i+1, n)区间的最大值的index</span></span><br><span class="line">        swap(array[i], array[max_index])  <span class="comment"># 交换最大值和i位置的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>基本思路</strong></p>
<p>对数组中的元素进行遍历，每一个元素遍历到的时候，都将该元素和该元素之前的元素从后向前进行比较进而找到这个元素应该插入到的位置</p>
<p><strong>伪代码实现</strong></p>
<p>版本1: 每一次比较的时候都进行交换来确定元素应该插入的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(array, n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> array[j] &gt; array[j - <span class="number">1</span>]:</span><br><span class="line">                swap(array[j], array[j - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>版本2: 先找到应该插入的位置，然后将元素直接插入到应该插入的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(array, n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        d = array[i]  <span class="comment"># 当前待插入的元素</span></span><br><span class="line">        index = find_index(array)  <span class="comment"># 查找d应该放置的位置</span></span><br><span class="line">        array[index] = d</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>基本思路</strong></p>
<p>自顶向下的归并排序：将数组递归的进行分解，直到一个元素单独的是一个数组，然后使用一个辅助数组，将分解的数组进行合并。</p>
<p>自底向上的归并排序：将数组中的每个元素看成一个独立的数组，从底向上的进行合并; 可以对链表进行nlogn的排序</p>
<p><strong>伪代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:  <span class="comment"># 此处可以对归并排序进行优化：当数据量较小的时候，可以使用插入排序进行优化</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = (r + l) // <span class="number">2</span></span><br><span class="line">    merge_sort(arr, l, mid)</span><br><span class="line">    merge_sort(arr, mid+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> arr[mid] &lt; arr[mid+<span class="number">1</span>]:  <span class="comment"># 对于近乎有序的数组，归并排序进行优化</span></span><br><span class="line">        merge(arr, l, mid, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [l...mid]数组和[mid+1...r]的数组进行合并</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arr, l, mid, r)</span>:</span></span><br><span class="line">    aux = []</span><br><span class="line"></span><br><span class="line">    i = l</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        <span class="keyword">if</span> i &gt; mid:</span><br><span class="line">            aux[k] = arr[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> j &gt; r:</span><br><span class="line">            aux[k] = arr[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[i] &gt; arr[j]:</span><br><span class="line">            aux[k] = arr[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            aux[k] = arr[j]</span><br><span class="line">            j += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>基本思路</strong></p>
<ol>
<li>设置两个变量i，j，排序开始的时候i=0；j=n-1；</li>
<li>以第一个数组元素作为关键数据，赋值给key，即key=a[0]；</li>
<li>从j开始向前搜索，即由后开始向前搜索（j—），找到第一个小于key的值，两者交换；</li>
<li>从i开始向后搜索，即由前开始向后搜索（i++），找到第一个大于key的值，两者交换；</li>
<li>重复第3、4步，直到i=j；此时将key赋值给a[i]；</li>
</ol>
<p><strong>伪代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:  <span class="comment"># 优化：当数据规模小的时候使用插入排序实现</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    p = partition(arr, l, r)</span><br><span class="line">    quick_sort(arr, l, p<span class="number">-1</span>)</span><br><span class="line">    quick_sort(arr, p+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, l, r)</span>:</span></span><br><span class="line">    swap(arr[l], arr[random])  <span class="comment"># 优化：可以避免近乎有序的数组退化成n^2的时间复杂度</span></span><br><span class="line">    pivot = arr[l]</span><br><span class="line">    i = l</span><br><span class="line">    j = r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> arr[j] &gt; pivot <span class="keyword">and</span> i &lt; j:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; j:</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> arr[i] &lt; pivot <span class="keyword">and</span> i &lt; j:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; j:</span><br><span class="line">            arr[j] = arr[i]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>

<p>快速排序和归并排序的比较：</p>
<p>快速排序和归并排序都是生成一个递归树，但是由于归并排序分解的两个子树是同等规模的所以树的高度是logn，而快速排序分解的两个子树的规模不一定是相同的，所以树的高度相对于归并排序是高的；当一个近乎有序的数组排序时，如果使用数组的第一个元素作为基准数，快速排序会退化成O(n^2)的算法, 此时的优化方法是基准数随机的选择。</p>
<p>进一步的优化：三路快速排序，大于基准数，等于基准数，小于基准数三部分。当有大量重复元素的时候，这种方式可以很好的避免对重复元素的排序。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>基本思路</strong></p>
<p>将待排序的数组进行heapify操作，然后从最大堆中依次提取出最大值即可，此外还有原地堆排序；将heapiy的数组的最大值和最后一个元素交换位置，然后将[0, n-1]的数组进行第一个元素siftDown操作</p>
<h3 id="3-2-查找算法"><a href="#3-2-查找算法" class="headerlink" title="3.2 查找算法"></a>3.2 查找算法</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找只能用在一个有序的数组中。</p>
<p><strong>伪代码</strong></p>
<h4 id="基于树的查找"><a href="#基于树的查找" class="headerlink" title="基于树的查找"></a>基于树的查找</h4><h3 id="3-3-字符串匹配算法"><a href="#3-3-字符串匹配算法" class="headerlink" title="3.3 字符串匹配算法"></a>3.3 字符串匹配算法</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>子串：</strong>字符串中任一连续的片段，称作其子串（substring）</p>
<p><strong>两种特殊的子串</strong>：起始于位置0、长度为k的子串称为<strong>前缀</strong>；而终止于位置n - 1、 长度为k的子串称为<strong>后缀</strong>（suffix）</p>
<h4 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h4><p>时间复杂度为：O(n * m) </p>
<p>V1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(p, t)</span>:</span></span><br><span class="line">  n = len(p)</span><br><span class="line">  m = len(t)</span><br><span class="line">  i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">    	<span class="keyword">if</span> p[i] == t[j]:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">        i = i - j + <span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">  <span class="keyword">return</span> i - j</span><br></pre></td></tr></table></figure>

<p>V2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(p, t)</span>:</span></span><br><span class="line">  n, m = len(p), len(t)</span><br><span class="line">  i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n-m+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">      <span class="keyword">if</span> t[i+j] != p[j]:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> j &gt;= m:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>基本的思路：当有不匹配的时候，使字符串的移动大幅度的</p>
<p><img src="kmp%E7%AE%97%E6%B3%95.png" alt="kmp基本思路"></p>
<p>如何确定上图中的p大跨度右移的时候的跨度？这里需要引入一个前缀表的概念。如何计算p的前缀表？</p>
<p>以<code>p = abcdabd</code>为例：</p>
<ul>
<li><p>先求出p的所有的前缀</p>
<ul>
<li>a、ab、abc、abcd、abcda、abcdab、abcdabd</li>
</ul>
</li>
<li><p>求出每个前缀的，前缀”和”后缀”的最长的共有元素的长度</p>
<table>
<thead>
<tr>
<th align="left">p的前缀</th>
<th align="center">最长的公共元素的长度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">ab</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">abc</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">abcd</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">abcda</td>
<td align="center">1</td>
</tr>
<tr>
<td align="left">abcdab</td>
<td align="center">2</td>
</tr>
<tr>
<td align="left">abcdabd</td>
<td align="center">0</td>
</tr>
</tbody></table>
</li>
<li><p>前缀表</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>a</th>
<th>b</th>
<th>d</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
</li>
<li><p>最后计算右移的最大跨度：<code>移动位数 = 已匹配的字符数 - 对应的值</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_next</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="comment"># 已知前一个字符串的，最长前缀和后缀公共长度，怎么求后一个呢？</span></span><br><span class="line">    <span class="comment"># 已知abcd=0,怎么求abcda？只需要判断新添加的字符a是否和第一个字符相等，如果相等就对前面的值+1</span></span><br><span class="line">    <span class="comment"># 已知abcda=1,怎么求abcdab？只要判断新添加的字符b是否和第二个字符b相等，如果相等就+1</span></span><br><span class="line">    next = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p)):</span><br><span class="line">        next.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, len(p)):</span><br><span class="line">        c = p[index]</span><br><span class="line">        <span class="keyword">if</span> c == p[<span class="number">0</span>:index][next[index - <span class="number">1</span>]]:</span><br><span class="line">            next[index] = next[index - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next[index] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> next</span><br></pre></td></tr></table></figure>

<h3 id="3-4-图相关的算法"><a href="#3-4-图相关的算法" class="headerlink" title="3.4 图相关的算法"></a>3.4 图相关的算法</h3><p>参考数据结构, 图论章节</p>
<h2 id="5-算法技巧"><a href="#5-算法技巧" class="headerlink" title="5 算法技巧"></a>5 算法技巧</h2>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd</title>
    <url>/2019/08/19/etcd/</url>
    <content><![CDATA[<p>etcd是一个高可用的键值存储系统，通过raft算法处理日志复制以保证强一致性。</p>
<p><img src="etcd%E6%9E%B6%E6%9E%84.png" alt="etcd架构图"></p>
<ul>
<li>httpserver: 用于处理用户发送的API请求，以及其他的etcd节点的同步与心跳信息请求。</li>
<li>Store: 用于处理etcd支持的各类功能的事务</li>
<li>Raft: 强一致算法的具体实现。</li>
<li>WAL: write ahead log是etcd的数据存储方式。由日志存储和快照存储两部分组成，其中Entry负责存储具体的日志内容，而snapshot负责在日志内容发生变化的时候保存raft的状态。</li>
</ul>
<p>通常对于一个请求，会先由httpserver转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给raft模块进行状态的变更、日志记录，然后在同步给其他的Etcd节点以确认数据提交，最后进行数据的提交、再次同步。</p>
<p>etcd集群是一个分布式系统，多个节点相互通信构成整体对外提供服务，每个节点都存储完整的数据，并通过raft协议保证每个节点的数据是一致的。</p>
<p>在任意时刻，集群中的每台机器只可能处于Leader、Follower、Candidate三种状态；处于正常状态时，集群中只会存在一个Leader，其余的服务器都是Follower。所有的 Follower 节点都是被动的，它们不会主动发出任何的请求，只会响应 Leader 和 Candidate 发出的请求，对于每一个用户的可变操作，都会被路由给 Leader 节点进行处理，除了 Leader 和 Follower 节点之外，Candidate 节点其实只是集群运行过程中的一个临时状态。</p>
<h2 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h2><p>Raft 协议分成三个子问题：节点选举、日志复制以及安全性</p>
<h3 id="节点选举"><a href="#节点选举" class="headerlink" title="节点选举"></a>节点选举</h3><p>所有节点一开始都被初始化为 Follower 状态</p>
<ul>
<li>当Follower在一定时间内没有收到来自主节点的心跳，会将自己角色改变为Candidate，并发起一次选主投票；当收到包括自己在内超过半数节点赞成后，选举成功；当收到票数不足半数选举失败，或者选举超时。若本轮未选出主节点，将进行下一轮选举（出现这种情况，是由于多个节点同时选举，所有节点均为获得过半选票）。<br>Candidate节点收到来自主节点的信息后，会立即终止选举过程，进入Follower角色。</li>
</ul>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>所谓日志复制，是指主节点将每次操作形成日志条目，并持久化到本地磁盘，然后通过网络IO发送给其他节点。其他节点根据日志的逻辑时钟(TERM，每次选主都会形成一个唯一的TERM编号，相当于逻辑时钟。每一条日志都有全局唯一的编号)和日志编号(INDEX)来判断是否将该日志记录持久化到本地。当主节点收到包括自己在内超过半数节点成功返回，那么认为该日志是可提交的(committed），并将日志输入到状态机，将结果返回给客户端。</p>
<p>主节点通过网络IO向其他节点追加日志。若某节点收到日志追加的消息，首先判断该日志的TERM是否过期，以及该日志条目的INDEX是否比当前以及提交的日志的INDEX跟早。若已过期，或者比提交的日志更早，那么就拒绝追加，并返回该节点当前的已提交的日志的编号。否则，将日志追加，并返回成功。</p>
<p>当主节点收到其他节点关于日志追加的回复后，若发现有拒绝，则根据该节点返回的已提交日志编号，发生其编号下一条日志。</p>
<p>主节点像其他节点同步日志，还作了拥塞控制。具体地说，主节点发现日志复制的目标节点拒绝了某次日志追加消息，将进入日志探测阶段，一条一条发送日志，直到目标节点接受日志，然后进入快速复制阶段，可进行批量日志追加。</p>
<p>按照日志复制的逻辑，我们可以看到，集群中慢节点不影响整个集群的性能。另外一个特点是，数据只从主节点复制到Follower节点，这样大大简化了逻辑流程。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Raft解决的办法是，在选主逻辑中，对能够成为主的节点加以限制，确保选出的节点已定包含了集群已经提交的所有日志。如果新选出的主节点已经包含了集群所有提交的日志，那就不需要从和其他节点比对数据了。简化了流程，缩短了集群恢复服务的时间。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://draveness.me/etcd-introduction" target="_blank" rel="noopener">https://draveness.me/etcd-introduction</a><br><a href="https://www.ipcpu.com/2017/09/etcd-start/" target="_blank" rel="noopener">https://www.ipcpu.com/2017/09/etcd-start/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>cobra包的使用</title>
    <url>/2019/08/19/cobra%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>使用该包可以创建命令行程序. 在cobra中有几个重要的概念command、argument、flag，其中command代表的是命令、argument表示命令行参数、flag为参数选项</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>lantern代理终端</title>
    <url>/2019/08/19/lantern%E4%BB%A3%E7%90%86%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<p>查看latern代理的本地端口，然后使用如下命令设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=127.0.0.1:54818</span><br><span class="line">export https_proxy=127.0.0.1:54818</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>lantern</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes使用及原理</title>
    <url>/2019/08/19/kubernetes%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>k8s和swarm一样是一个容器编排的工具, 本文记录了k8s的基本使用及其原理。</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="kubernetesarchitecture.jpg" alt="k8s架构图"></p>
<p>k8s可以自动化、容器化应用程序的部署、扩展和管理。通常结合docker进行工作。核心组件：</p>
<ul>
<li>etcd：保存整个集群的状态</li>
<li>apiserver：提供了资源操作的唯一入口，并提供认真、授权、访问控制、api机制和发现等机制</li>
<li>controller manager：维护集群的状态，比如故障检测、自动扩展、滚动更新等</li>
<li>scheduler：负责资源的调度，按照预期的调度策略将Pod调度到相应的node机器上</li>
<li>kubelet：负责维护容器的声明周期，同时也负责VOLUME和网络的管理</li>
<li>container runtime：负责镜像管理及pod和容器的真正运行</li>
<li>kube-proxy：为service提供cluster内部的服务发现和负载均衡</li>
</ul>
<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><p>minikube使用<br>参考: <a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">https://github.com/kubernetes/minikube</a><br>MacOS安装命令: <code>brew cask install minikube</code>, 之后执行<code>minikube start</code>命令来创建</p>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><p><strong>角色</strong>： manager + node<br><strong>pod</strong>： pod是k8s调度的最小单位，在k8s中是不直接对container进行直接操作的，一个pod中可能包含一个或者多个container。在一个pod中的container共享同一个namespace。</p>
<h2 id="3-pod详解"><a href="#3-pod详解" class="headerlink" title="3 pod详解"></a>3 pod详解</h2><p>每个pod中包含一个或者多个container容器。每个pod中都有一个pause容器，该容器保存所有容器的状态，通过管理pause容器可以实现管理pod中所有容器的效果。Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个）容器（例如 Docker 容器），这些容器共享存储、网络、以及怎样运行这些容器的声明。Pod中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。Pod所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器，这些容器是相对紧密的耦合在一起 — 在容器出现之前，在相同的物理机或虚拟机上运行意味着在相同的逻辑主机上运行。</p>
<p>Pod的共享上下文是一组 Linux命名空间、cgroups、以及其他潜在的资源隔离相关的因素。</p>
<p>Pod中的所有容器共享一个IP地址和端口空间，并且可以通过localhost互相发现。他们也能通过标准的进程间通信（如 SystemV 信号量或 POSIX 共享内存）方式进行互相通信。不同Pod中的容器的IP地址互不相同，没有特殊配置 就不能使用IPC进行通信。这些容器之间经常通过Pod IP地址进行通信。</p>
<p>Pod中的应用也能访问共享卷，共享卷是Pod定义的一部分，可被用来挂载到每个应用的文件系统上。Pod中的容器可以访问共同的数据卷来实现荣期间数据的共享，k8s中的数据卷是Pod级别的。</p>
<p>一般来说，Pod 不会消失，直到人为销毁他们。这可能是一个人或控制器。这个规则的唯一例外是成功或失败的 phase 超过一段时间（由 master 确定）的Pod将过期并被自动销毁。</p>
<p>Pod可以通过创建副本实现动态的伸缩。可以是手动的进行设置，也可以自动的进行伸缩（需要依靠监控平台）。</p>
<h3 id="3-1-Pod的基本操作"><a href="#3-1-Pod的基本操作" class="headerlink" title="3.1 Pod的基本操作"></a>3.1 Pod的基本操作</h3><h4 id="定义Pod"><a href="#定义Pod" class="headerlink" title="定义Pod"></a>定义Pod</h4><p>pod的定义是通过yaml文件来实现的。参考：<a href="https://www.kubernetes.org.cn/doc-25" target="_blank" rel="noopener"></a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>            <span class="string">//</span> <span class="string">k8s的api版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                 <span class="string">//</span> <span class="string">API对象的类型，这里是Pod</span></span><br><span class="line"><span class="attr">metadata:</span>                 <span class="string">//</span> <span class="string">Pod的元数据</span></span><br><span class="line">    <span class="attr">name:</span>  <span class="string">string</span>         <span class="string">//</span> <span class="string">pod的名字，namespace内唯一</span></span><br><span class="line">    <span class="attr">namespace:</span>  <span class="string">string</span>    <span class="string">//</span> <span class="string">pod的命名空间</span></span><br><span class="line">    <span class="attr">labels:</span>               <span class="string">//</span> <span class="string">标签列表</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>    <span class="string">//</span> <span class="string">标签的名字</span></span><br><span class="line">    <span class="attr">spec:</span>                 <span class="string">//</span> <span class="string">pod的具体定义</span></span><br><span class="line">        <span class="attr">containers:</span>       <span class="string">//</span> <span class="string">Pod中容器列表</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>    <span class="string">//</span> <span class="string">容器的名称，pod内唯一</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">string</span>   <span class="string">//</span> <span class="string">容器中的镜像</span></span><br><span class="line">          <span class="attr">command:</span>        <span class="string">//</span> <span class="string">设置容器的启动命令</span></span><br><span class="line">          <span class="attr">imagesPullPolicy:</span> <span class="string">[Always|Never|IfNotPresent]</span>  <span class="string">//</span> <span class="string">获取镜像的策略，默认值为Always，每次都尝试下载镜像</span></span><br><span class="line">          <span class="attr">ports:</span>          <span class="string">//</span> <span class="string">设置容器的端口</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span>     <span class="string">//</span> <span class="string">设置端口名称，Pod内唯一</span></span><br><span class="line">            <span class="attr">containerPort:</span> <span class="number">80</span> <span class="string">//</span> <span class="string">设置容器内的端口</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span>  <span class="string">//</span> <span class="string">设置端口的协议，默认是TCP</span></span><br><span class="line">            <span class="attr">hostIP:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="string">//</span> <span class="string">设置在宿主机上的IP，默认绑定到所有可用的IP接口上，即0.0.0.0</span></span><br><span class="line">            <span class="attr">hostPort:</span> <span class="number">80</span>  <span class="string">//</span> <span class="string">设置在宿主机上的端口</span></span><br><span class="line">          <span class="attr">volumeMounts:</span>  <span class="string">//</span> <span class="string">将数据卷挂载到容器中的路径</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">        <span class="attr">volumes:</span>           <span class="string">//</span> <span class="string">使用宿主机的/tmp路径挂载Pod中的data路径</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/tmp</span></span><br><span class="line">        <span class="attr">hostNetwork:</span> <span class="literal">true</span>  <span class="string">//</span> <span class="literal">true</span><span class="string">表示直接使用宿主机的网络</span></span><br><span class="line">        <span class="attr">restartPolicy:</span>    <span class="string">//</span> <span class="string">设置pod的重启策略，Always，默认策略，当容器终止退出后，总是重启容器。OnFailure，Never</span></span><br><span class="line">    <span class="attr">env:</span>                  <span class="string">//</span> <span class="string">设置运行时的环境变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">parameter_1</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">value_1</span></span><br></pre></td></tr></table></figure>

<h4 id="创建Pod"><a href="#创建Pod" class="headerlink" title="创建Pod"></a>创建Pod</h4><p><code>kubectl create -f xxx.yaml</code> 使用create命令来创建一个Pod</p>
<h4 id="查询Pod"><a href="#查询Pod" class="headerlink" title="查询Pod"></a>查询Pod</h4><p><code>kubectl get pod pod-name</code>该命令，用来查询，获取Pod的简要信息。输出的结果中：</p>
<ul>
<li>NAME：Pod的名称</li>
<li>READY：Pod的准备状况，右边的数字表示Pod包含的容器的总数，左边的数字是准备就绪的容器数目。所谓的准备状况是指是否准备接收请求，它的准备状态取决于容器，即所有的容器都准备就绪了，Pod才准备就绪了。</li>
<li>STATUS：Pod的状态</li>
<li>RESTARTS：Pod的重启次数</li>
<li>AGE：Pod的运行时间</li>
</ul>
<p>可以使用<code>kubectl get pod pod-name --output json</code>命令来查看详细的信息。</p>
<p>查看Pod的状态和生命周期：<code>kubectl describe pod pod-name</code></p>
<h4 id="删除Pod"><a href="#删除Pod" class="headerlink" title="删除Pod"></a>删除Pod</h4><p><code>kubectl delete pod pod-name</code>删除指定的Pod，使用<code>kubectl delete pod -all</code> 删除全部的Pod</p>
<h4 id="更新Pod"><a href="#更新Pod" class="headerlink" title="更新Pod"></a>更新Pod</h4><p><code>kubectl replace xxx.yaml</code> 使用该命令进行更新</p>
<h3 id="3-2-Pod的网络"><a href="#3-2-Pod的网络" class="headerlink" title="3.2 Pod的网络"></a>3.2 Pod的网络</h3><p>Pod中的所有容器网络是共享的。每个Pod都拥有一个扁平化共享网络命名空间的IP，称为PodIP. 在Pod运行后使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 可以查看PodIP</span><br><span class="line">kubectl get pod pod-name --template&#x3D;&#123;&#123;.status.podIP&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Pod的状态和生命周期"><a href="#3-3-Pod的状态和生命周期" class="headerlink" title="3.3 Pod的状态和生命周期"></a>3.3 Pod的状态和生命周期</h3><p>Pod的本质是一组容器。Pod的状态是通过容器的状态来体现的，容器的状态变化会影响Pod的状态变化，触发Pod的声明周期转换。k8s中对于pod中的容器进行了状态的记录，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- waiting: 容器正在等待创建</span><br><span class="line">- Running： 容器正在运行</span><br><span class="line">- Terminated：容器终止退出</span><br></pre></td></tr></table></figure>

<p>使用<code>kubectl describe pod pod-name</code>可以查看Pod中容器的运行状态。</p>
<p>Pod的生命周期：</p>
<ul>
<li>pending：Pod已经被创建，但是其中的一个或者多个容器还没有创建。</li>
<li>Running：Pod被调度到了Node，所有的容器已经被创建</li>
<li>Succeeded：Pod中所有的容器正常退出</li>
<li>Failed：Pod中的所有容器退出，至少一个容器是一次退出的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 该命令查看Pod的处于生命周期的哪个阶段。</span><br><span class="line">kubectl get pods pod-name --template&#x3D;&quot;&#123;&#123;.status.phase&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>Pod被创建成功之后，首先会进入Pending阶段，然后被调度到Node后运行，进入running阶段。</p>
<h3 id="3-4-Pod的调度"><a href="#3-4-Pod的调度" class="headerlink" title="3.4 Pod的调度"></a>3.4 Pod的调度</h3><p>所谓的Pod的调度，就是Pod被创建之后，被分配到集群中的哪个Node上。k8s中的调度算法分为两步：</p>
<ol>
<li>筛选出符合条件的Node：通过一系列的过滤函数，主要是对Node的cpu、内存资源，端口的使用等筛选。</li>
<li>选择最优的Node：通过一系列的优先级函数来评估出最优的Node。</li>
</ol>
<p>有时需要将Pod调度到指定的Node上，此时使用Node Selector来完成。通过<code>kubectl get node</code>命令可以获取集群中的所有的Node，使用<code>kubectl label nodes hostname 标签</code>命令来为Node添加标签, 在定义Pod的时候使用Node Selector来选择Node。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">env:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">nodeSelector:</span></span><br><span class="line">      <span class="attr">env:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<p>此外还可以直接使用：nodeName进行指定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">kube-node-1</span></span><br></pre></td></tr></table></figure>



<h3 id="3-5-问题定位"><a href="#3-5-问题定位" class="headerlink" title="3.5 问题定位"></a>3.5 问题定位</h3><p>使用<code>kubectl logs</code>命令查询Pod容器的日志。</p>
<p>连接远程的容器：<code>kubectl attach</code>和<code>kubectl exec pod-name</code>两个命令都可以。</p>
<h2 id="4-service"><a href="#4-service" class="headerlink" title="4 service"></a>4 service</h2><p>service与Pod的关联是通过Label来实现的。service会为访问者提供一个固定的访问地址，用于在访问时重定向到相应的后端。</p>
<p>创建service的时候，指定要关联的Pod的标签，当该service创建之后作为代理服务器，当作Pod的访问入口。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>   <span class="string">//</span> <span class="string">k8s的API版本</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>    <span class="string">//</span> <span class="string">API对象的类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx</span> <span class="string">//</span> <span class="string">指定service的名称</span></span><br><span class="line"><span class="attr">spec:</span>            <span class="string">//</span> <span class="string">配置service的具体规格</span></span><br><span class="line">  <span class="attr">selector:</span>      <span class="string">//</span> <span class="string">指定service的Label</span> <span class="string">Selector来匹配Pod的Label</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span>         <span class="string">//</span> <span class="string">设置service的端口转发规则</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<h2 id="5-数据持久化"><a href="#5-数据持久化" class="headerlink" title="5 数据持久化"></a>5 数据持久化</h2><p>在k8s系统中，需要对Pod数据进行持久化。</p>
<p>k8s中的数据卷可以分为：</p>
<ul>
<li>本地数据卷: <ul>
<li>EmptyDir: 如果配置了此数据卷，在Pod被分配到Node上的时候，会在Node上创建EmptyDir数据卷，并挂载到Pod的容器中。但是Pod的生命周期结束，EmptyDir数据卷会被删除。</li>
<li>HostPath: 允许将宿主机上的文件系统挂载到Pod中。</li>
</ul>
</li>
<li>网络数据卷: 每次Pod创建的时候都会将存储系统的远端文件目录挂载到容器中。<ul>
<li>NFS等</li>
</ul>
</li>
<li>信息数据卷: 主要用来给容器传递配置信息<ul>
<li></li>
</ul>
</li>
</ul>
<h2 id="6-kubernetes网络"><a href="#6-kubernetes网络" class="headerlink" title="6 kubernetes网络"></a>6 kubernetes网络</h2><p><img src="kubenetes%E7%BD%91%E7%BB%9C.png" alt="k8s网络"><br>Pod中所有的容器都是互通的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《kubernets实战》</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd源码分析-环境搭建</title>
    <url>/2019/08/15/etcd%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-编译"><a href="#1-编译" class="headerlink" title="1. 编译"></a>1. 编译</h2><ul>
<li><p>源码下载：git clone <a href="https://github.com/etcd-io/etcd.git" target="_blank" rel="noopener">https://github.com/etcd-io/etcd.git</a></p>
</li>
<li><p>源码的编译：cd etcd源码目录，执行make，直接对项目进行编译。ectd的编译使用Makefile和shell的方式完成。通过执行make命令，调用shell脚本来完成编译的工作</p>
</li>
</ul>
<p>makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">    GO_BUILD_FLAGS=<span class="string">"-v"</span> ./build</span><br><span class="line">    ./bin/etcd --version</span><br><span class="line">    ./bin/etcdctl version</span><br></pre></td></tr></table></figure>

<p>build文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">etcd_build() &#123;</span><br><span class="line">	out="bin"</span><br><span class="line">	if [[ -n "$&#123;BINDIR&#125;" ]]; then out="$&#123;BINDIR&#125;"; fi</span><br><span class="line"><span class="meta">	#</span><span class="bash"> Static compilation is useful when etcd is run <span class="keyword">in</span> a container. <span class="variable">$GO_BUILD_FLAGS</span> is OK</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> shellcheck <span class="built_in">disable</span>=SC2086</span></span><br><span class="line">	CGO_ENABLED=0 go build -v -installsuffix cgo -ldflags "$GO_LDFLAGS" -o "$&#123;out&#125;/etcd" $&#123;REPO_PATH&#125; || return</span><br><span class="line"><span class="meta">	#</span><span class="bash"> shellcheck <span class="built_in">disable</span>=SC2086</span></span><br><span class="line">	CGO_ENABLED=0 go build $GO_BUILD_FLAGS -installsuffix cgo -ldflags "$GO_LDFLAGS" -o "$&#123;out&#125;/etcdctl" $&#123;REPO_PATH&#125;/etcdctl || return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>go build命令参数：</p>
<ul>
<li><p>如果一个项目没有依赖GOPATH下的任何的包，那么直接<code>go build</code>命令就可以实现编译。此时会自动搜索当前目录下的源码。</p>
</li>
<li><p>可以给go build指定编译的源码：<code>go buid main.go file1.go file2.go</code>，此时会默认使用第一个文件名作为编译输出的可执行文件名</p>
</li>
<li><p><code>go build -o main package</code>，包名是相对于GOPATH下的src目录开始的，-o 指定输出的可执行文件的名字</p>
</li>
<li><p>其他的参数：</p>
<ul>
<li>-v : 编译时显示包名</li>
<li>-ldflags：指定传递给链接器的参数。</li>
<li>-gcflags: 指定传递给编译器的参数</li>
<li>-x: 查看并执行编译命令</li>
<li>-a: 强制重新编译所有依赖包</li>
<li>-installsuffix： 为了使当前的输出目录与默认的编译输出目录分离，可以使用这个标记。此标记的值会作为结果文件的父目录名称的后缀。其实，如果使用了<code>-race</code>标记，这个标记会被自动追加且其值会为<code>race</code>。如果我们同时使用了<code>-race</code>标记和<code>-installsuffix</code>，那么在<code>-installsuffix</code>标记的值的后面会再被追加<code>_race</code>，并以此来作为实际使用的后缀。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-docker部署"><a href="#2-docker部署" class="headerlink" title="2. docker部署"></a>2. docker部署</h2><p><strong>单机部署</strong></p>
<p>docker部署：<code>docker run -d --name etcd -p 2379:2379 -p 2380:2380 -e ALLOW_NONE_AUTHENTICATION=yes bitnami/etcd</code></p>
<p><strong>集群部署</strong></p>
<ul>
<li>创建docker-compose.yml文件，内容如下：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">etcd1:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">bitnami/etcd</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">etcd1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">6000</span><span class="string">:2379</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ALLOW_NONE_AUTHENTICATION=yes</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_NAME=etcd1</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_ADVERTISE_PEER_URLS=http://etcd1:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_ADVERTISE_CLIENT_URLS=http://etcd1:2379</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER=etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER_STATE=new</span></span><br><span class="line">    <span class="attr">etcd2:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">bitnami/etcd</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">etcd2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">6001</span><span class="string">:2379</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ALLOW_NONE_AUTHENTICATION=yes</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_NAME=etcd2</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_ADVERTISE_PEER_URLS=http://etcd2:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_ADVERTISE_CLIENT_URLS=http://etcd2:2379</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER=etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER_STATE=new</span></span><br><span class="line">    <span class="attr">etcd3:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">bitnami/etcd</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">etcd3</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">6002</span><span class="string">:2379</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ALLOW_NONE_AUTHENTICATION=yes</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_NAME=etcd3</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_ADVERTISE_PEER_URLS=http://etcd3:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_ADVERTISE_CLIENT_URLS=http://etcd3:2379</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER=etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ETCD_INITIAL_CLUSTER_STATE=new</span></span><br></pre></td></tr></table></figure></li>
<li>启动: <code>docker-compose up -d</code></li>
</ul>
<h2 id="3-调试"><a href="#3-调试" class="headerlink" title="3. 调试"></a>3. 调试</h2><ol>
<li><p>安装调试器：go get -u github.com/go-delve/delve/cmd/dlv</p>
</li>
<li><p>如何使用呢？</p>
<p><strong>直接使用debug命令运行编译好的可执行文件</strong>：<code>dlv --listen=:2345 --headless=true --api-version=2 exec bin/etcd</code>，会得到如下的输出：<img src="debug_show.jpg" alt="开启调试"></p>
</li>
<li><p>然后使用IDEA或者goland添加远程调试配置</p>
<p><img src="go_remote_debug.jpg" alt="IDEA配置远端调试-图1"><br><img src="go_remote_debug_2.jpg" alt="IDEA配置远端调试-图2"></p>
<p>配置完成之后，即可连接上调试器在IDEA中进行调试。</p>
</li>
</ol>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><h3 id="3-1-架构图"><a href="#3-1-架构图" class="headerlink" title="3.1 架构图"></a>3.1 架构图</h3><h3 id="3-2-模块组成"><a href="#3-2-模块组成" class="headerlink" title="3.2 模块组成"></a>3.2 模块组成</h3><ul>
<li>http模块: 对外提供http访问接口</li>
<li>raft模块: 实现了完整的raft协议</li>
<li>存储模块：<ul>
<li>wal日志存储模块: 持久化存储日志条目</li>
<li>kv数据存储模块: kv数据的存储引擎</li>
</ul>
</li>
</ul>
<p><img src="etcd_module_arch.jpg" alt="模块划分"></p>
<p>从以下方面去分析：</p>
<ul>
<li>启动流程是怎么样的？</li>
<li>读写请求的处理流程是怎样的？</li>
<li>集群中的节点之间进行通信的?</li>
</ul>
<blockquote>
<p>参考文章：<br>1.<a href="http://c.biancheng.net/view/120.html" target="_blank" rel="noopener">http://c.biancheng.net/view/120.html</a><br>2.<a href="https://blog.csdn.net/happyanger6/article/details/78724594/" target="_blank" rel="noopener">https://blog.csdn.net/happyanger6/article/details/78724594/</a><br>3.<a href="https://blog.csdn.net/mayongze321/article/details/88972748" target="_blank" rel="noopener">https://blog.csdn.net/mayongze321/article/details/88972748</a></p>
</blockquote>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>go包管理</title>
    <url>/2019/08/14/go%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>在go1.11之前可以使用govendor来进行包管理，在go1.11之后可以使用go mod工来进行包管理。</p>
<h2 id="1-govendor包管理"><a href="#1-govendor包管理" class="headerlink" title="1. govendor包管理"></a>1. govendor包管理</h2><p><strong>创建的项目必须在GOPATH下</strong></p>
<p>基本的使用思路：进入项目的目录，然后对项目进行初始化，之后使用命令将该项目所依赖的包进行管理。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>要使用govendor必须安装，安装的命令：<code>go get -u github.com/kardianos/govendor</code>，为了使用的方便可以将使用<code>export PATH=$GOPATH/bin</code> 添加到环境变量中。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>govendor --help</code>  查看帮助文档，写的非常的详细。</p>
<h2 id="2-go-mod包管理工具"><a href="#2-go-mod包管理工具" class="headerlink" title="2. go mod包管理工具"></a>2. go mod包管理工具</h2><p>创建的项目不一定在GOPATH下。可以在任何的位置创建自己的项目。</p>
<p>有了module的概念，根模块</p>
<p>基本的使用思路：</p>
<ul>
<li>创建项目目录</li>
<li>进入项目目录，使用<code>go mod init module-name</code>命令进行初始化项目。在项目的目录下会生成一个go.mod文件</li>
<li>使用go mod相关的命令来进行本地包和依赖包的管理和版本控制。</li>
</ul>
<blockquote>
<p>参考</p>
<ol>
<li><a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc原理及其使用</title>
    <url>/2019/08/14/grpc%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>定义一个函数，可以在远程对该函数进行调用。grpc使用protobuf作为IDL。</p>
<h2 id="1-1-protobuf"><a href="#1-1-protobuf" class="headerlink" title="1.1 protobuf"></a>1.1 protobuf</h2><p>使用步骤如下：</p>
<ul>
<li>Define message formats in a .proto file.</li>
<li>Use the protocol buffer compiler.</li>
<li>Use the Go protocol buffer API to write and read messages.</li>
</ul>
<p>protobuf是一个描述服务的idl。使用的时候，先定义proto文件，然后使用protoc工具将proto文件生成代码。</p>
<blockquote>
<p>tip，Mac安装<br>protocbuf编译器的安装：brew install protobuf</p>
</blockquote>
<p>protobuf文件定义。文件名为.proto，定义函数使用service，定义消息使用message，如下示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> greeting = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloResponse</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>protoc --go_out=./ test.proto</code> 执行该命令，生成go代码。<br>如果是使用grpc：<code>protoc --go_out=plugins=grpc:./ helloworld.proto</code></p>
<blockquote>
<p>说明，如果想要在go中使用，需要安装go的protobuf 的插件，执行如下的命令进行安装：<br><code>go get -u github.com/golang/protobuf/protoc-gen-go</code></p>
</blockquote>
<h2 id="1-2-安装grpc"><a href="#1-2-安装grpc" class="headerlink" title="1.2 安装grpc"></a>1.2 安装grpc</h2><p>执行入下的脚本，安装go开发grpc需要的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;  <span class="comment"># 安装proto和protoc-gen-go包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装grpc包，因为无法科学上网，所以曲线救国，采用如下方式安装grpc包</span></span><br><span class="line">(如果可以科学上网可以采用该命令：`go get google.golang.org/grpc`)</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/grpc/grpc-go.git <span class="variable">$GOPATH</span>/src/google.golang.org/grpc  <span class="comment"># 下载grpc包</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/net.git <span class="variable">$GOPATH</span>/src/golang.org/x/net  <span class="comment"># 下载grcp依赖包net</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/golang/text.git <span class="variable">$GOPATH</span>/src/golang.org/x/text  <span class="comment"># 下载grcp依赖包text</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/google/go-genproto.git <span class="variable">$GOPATH</span>/src/google.golang.org/genproto  <span class="comment"># 下载grpc依赖包</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/</span><br><span class="line">go install google.golang.org/grpc   <span class="comment"># 安装grc包</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-go开发grpc示例demo"><a href="#1-3-go开发grpc示例demo" class="headerlink" title="1.3 go开发grpc示例demo"></a>1.3 go开发grpc示例demo</h2><p>step1：创建<code>helloworld.proto</code>文件，内容如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloResponse)&#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">    string greeting = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloResponse</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> reply = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>step2：使用protoc编译文件，执行命令<code>protoc --go_out=plugins=grpc:./ helloworld.proto</code></p>
<p>step3：使用helloworld.proto文件编译生成的代码，实现server和client</p>
<p>server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	pb <span class="string">"grpc-demo/test"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ser *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, request *pb.HelloRequest)</span> <span class="params">(*pb.HelloResponse, error)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"Received: %v"</span>, request.Greeting)</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloResponse&#123;Reply: <span class="string">"ok: "</span> + request.Greeting&#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":9999"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterHelloServiceServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(listen); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	pb <span class="string">"grpc-demo/test"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">"localhost:9999"</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	c := pb.NewHelloServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Greeting: <span class="string">"hello test"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(r)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:基本的使用流程</strong> </p>
<p>服务端</p>
<ol>
<li>创建proto文件</li>
<li>使用protoc生成grpc go代码</li>
<li>实现服务端<ul>
<li>创建一个tcp服务器：<code>listen, err := net.Listen(&quot;tcp&quot;, &quot;:9999&quot;)</code></li>
<li>创建一个grpc服务：<code>s := grpc.NewServer()</code></li>
<li>将grcp注册到服务的server上：<code>pb.RegisterXXXServer(s, &amp;routeGuideServer{})</code></li>
<li>将服务的server和tcp服务器绑定：<code>err := s.Serve(listen)</code></li>
</ul>
</li>
</ol>
<p>客户端</p>
<ol>
<li>连接grpc服务：<code>conn, err := grpc.Dial(&quot;localhost:9999&quot;, grpc.WithInsecure())</code></li>
<li>创建一个client：<code>c := pb.NewHelloServiceClient(conn)</code></li>
<li>调用函数：<code>c.Function(ctx, parameters)</code></li>
</ol>
<p>rpc框架：超时控制、鉴权</p>
<p>grpc中的超时怎么实现的？在etcd中的grpc怎么使用的？</p>
<blockquote>
<p>参考</p>
<ol>
<li><a href="https://www.grpc.io/docs/quickstart/go/" target="_blank" rel="noopener">https://www.grpc.io/docs/quickstart/go/</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>grcp</tag>
      </tags>
  </entry>
  <entry>
    <title>go并发编程</title>
    <url>/2019/08/13/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>内核线程：<br>绿色线程：由某种语言运行时管理的线程。</p>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>goroutine是和go语言的运行时库紧密联系的。go语言的runtime会观察goroutine运行时的状态，当goroutine阻塞的时候会挂起该协程，当不阻塞的时候自动的运行它们。</p>
<p>Go’s mechanism for hosting goroutines is an implementation of what’s called an <em>M:Nscheduler</em>, which means it maps M green threads to N OS threads.Goroutines are then scheduled onto the green threads. When we have more goroutines than green threads available, the scheduler handles the distribution of the goroutines across the available threads and ensures that when these goroutines become blocked, other goroutines can be run.</p>
<h3 id="3-channel"><a href="#3-channel" class="headerlink" title="3. channel"></a>3. channel</h3><p><strong>channel的特点</strong></p>
<p>写channel和读channel都会使goroutine阻塞。但是对于带缓冲的channel，在channel没有写满之前是不会阻塞的，当写满了之后，这时候如果在向里面写就会出现阻塞</p>
<p><strong>channel的类型</strong></p>
<ul>
<li>不带缓冲的</li>
<li>带缓冲的</li>
</ul>
<p><strong>怎么定义channel</strong></p>
<p>两种定义channel的方法：</p>
<ul>
<li><code>var ch chan int</code></li>
<li><code>ch := make(chan ints)</code></li>
</ul>
<p><strong>怎么使用channel进行goroutine通信</strong></p>
<p>在主goroutine中创建一个channel，然后一个goroutine去向这个channel中写入通信的消息，另一个goroutine从该channel中获取消息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mytest</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"mytest ..........."</span>)</span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	fmt.Println(<span class="string">"1 end..........."</span>)</span><br><span class="line"></span><br><span class="line">	ch &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"2 end ............."</span>)</span><br><span class="line"></span><br><span class="line">	ch &lt;- <span class="number">3</span></span><br><span class="line">	fmt.Println(<span class="string">"3 end ..............."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"begin ................."</span>)</span><br><span class="line">	<span class="keyword">go</span> mytest(ch)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> value := <span class="keyword">range</span> ch &#123;</span><br><span class="line">			fmt.Println(value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"finished ................."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-waitgroup"><a href="#4-waitgroup" class="headerlink" title="4. waitgroup"></a>4. waitgroup</h3><p>​                    main</p>
<p>​                        |</p>
<p>​                        |– fork –&gt; child</p>
<p>​                        |                     |</p>
<p>​                        |                     |</p>
<p>   join point    | &lt;—-join — |</p>
<p>​                        |                     |</p>
<p>​                    main              child</p>
<p>运行模型如上图，可以通过创建一个join point来阻塞main等待child的执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"https://google.com"</span>,</span><br><span class="line">    <span class="string">"https://tutorialedge.net"</span>,</span><br><span class="line">    <span class="string">"https://twitter.com"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="keyword">string</span>, wg *sync.WaitGroup)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">    fmt.Println(resp.Status)</span><br><span class="line">    <span class="keyword">return</span> resp.Status, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homePage</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"HomePage Endpoint Hit"</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> fetch(url, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"Returning Response"</span>)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Responses"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRequests</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, homePage)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8081"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handleRequests()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-mutex"><a href="#5-mutex" class="headerlink" title="5. mutex"></a>5. mutex</h4><p>如果两个goroutine操作两个相同的变量，可能会出现问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mutex   sync.Mutex</span><br><span class="line">    balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    balance = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(value <span class="keyword">int</span>, done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    fmt.Printf(<span class="string">"Depositing %d to account with balance: %d\n"</span>, value, balance)</span><br><span class="line">    balance += value</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withdraw</span><span class="params">(value <span class="keyword">int</span>, done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    fmt.Printf(<span class="string">"Withdrawing %d from account with balance: %d\n"</span>, value, balance)</span><br><span class="line">    balance -= value</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Go Mutex Example"</span>)</span><br><span class="line"></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> withdraw(<span class="number">700</span>, done)</span><br><span class="line">    <span class="keyword">go</span> deposit(<span class="number">500</span>, done)</span><br><span class="line">    &lt;-done</span><br><span class="line">    &lt;-done</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"New Balance %d\n"</span>, balance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p><strong>what&amp;&amp;why</strong></p>
<p>Context like a timeout or deadline or a channel to indicate stop working and return.When a request is canceled or times out, all the goroutines working on that request should exit quickly so the system can reclaim any resources they are using.</p>
<p>在Go服务器程序中，每个请求都会有一个goroutine去处理。然而，处理程序往往还需要创建额外的goroutine去访问后端资源，比如数据库、RPC服务等。由于这些goroutine都是在处理同一个请求，所以它们往往需要访问一些共享的资源，比如用户身份信息、认证token、请求截止时间等。而且如果请求超时或者被取消后，所有的goroutine都应该马上退出并且释放相关的资源。这种情况也需要用Context来为我们取消掉所有goroutine。</p>
<p>比如一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文。</p>
<p><strong>code</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure>

<p><strong>example</strong></p>
<p>demo1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">				time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，context.Background() 返回一个空的Context，这个空的Context一般用于整个Context树的根节点。<strong>然后我们使用context.WithCancel(parent)函数，创建一个可取消的子Context，然后当作参数传给goroutine使用，这样就可以使用这个子Context跟踪这个goroutine</strong>。</p>
<p>demo2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> key <span class="keyword">string</span>=<span class="string">"name"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">//附加值</span></span><br><span class="line">	valueCtx:=context.WithValue(ctx,key,<span class="string">"【监控1】"</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(valueCtx)</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="comment">//取出值</span></span><br><span class="line">			fmt.Println(ctx.Value(key),<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//取出值</span></span><br><span class="line">			fmt.Println(ctx.Value(key),<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo3</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeoutWatch</span><span class="params">(ctx context.Context, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"finished ............."</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"running .............."</span>)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> timeoutWatch(ctx, &amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	cancel()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/05/12/go-in-action-go-context.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile编写</title>
    <url>/2019/08/12/makefile%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Makefile是一个文件，在这个文件里面记录了我们编译代码的步骤。Makefile是由很多的规则组的，很多的规则组成一起就成了Makefile文件。</p>
<p><strong>文件的结构：</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">规则1</span><br><span class="line">规则2</span><br><span class="line">规则3</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p><strong>Makefile文件的命名规则：</strong></p>
<p>makeflie 或者 Makefile。</p>
<p><strong>Makefile文件的规则：</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: dependency</span></span><br><span class="line">	command   <span class="comment"># command前面必须有一个缩进</span></span><br></pre></td></tr></table></figure>
<h2 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><ul>
<li>终极目标：文件中第一个规则中的目标为终极目标</li>
<li>子目标：除了终极目标，其他的目标都是子目标</li>
<li>伪目标：这种目标没有依赖，我们称这种目标为伪目标</li>
</ul>
<h3 id="2-目标的生成规则"><a href="#2-目标的生成规则" class="headerlink" title="2. 目标的生成规则"></a>2. 目标的生成规则</h3><p>如果直接执行<code>make</code>命令，那么生成的是终极目标。如果想要生成指定的子目标那么，需要使用<code>make 子目标名</code>，例如：<code>make clean</code>命令</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员自我修养笔记</title>
    <url>/2019/08/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-编译和链接"><a href="#1-编译和链接" class="headerlink" title="1. 编译和链接"></a>1. 编译和链接</h2><p>过程：<br><code>预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接</code></p>
<h3 id="1-1-预处理"><a href="#1-1-预处理" class="headerlink" title="1.1 预处理"></a>1.1 预处理</h3><p><strong>在这个过程中做什么事情呢</strong></p>
<p>在这个过程中主要是处理一些预编译指令。比如：#include 、#define等。主要规则如下：</p>
<ul>
<li>将所有的#define删除，并且展开所有的宏定义</li>
<li>处理所有的条件预编译指令，比如：#ifndef、#if、#elif等</li>
<li>处理#include，将包含的文件插入到预编译指令的位置，这个过程是递归进行的</li>
<li>删除所有的注释</li>
<li>保留所有的#pragma编译器指令，因为编译器需要使用它们</li>
</ul>
<h3 id="1-2-编译阶段"><a href="#1-2-编译阶段" class="headerlink" title="1.2 编译阶段"></a>1.2 编译阶段</h3><p>该阶段就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件</p>
<h3 id="1-3-汇编"><a href="#1-3-汇编" class="headerlink" title="1.3 汇编"></a>1.3 汇编</h3><p>该阶段是将汇编代码转换成机器可以执行的指令。</p>
<h3 id="1-4-链接"><a href="#1-4-链接" class="headerlink" title="1.4 链接"></a>1.4 链接</h3><p>把各个模块之间的相互引用的部分处理好，使得各个模块之间能够正确的衔接。</p>
]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>shell编程</title>
    <url>/2019/08/11/shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>该命令可以用来判断某个条件是否成立</p>
<p>if 条件 -h参数</p>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><h4 id="1-文件属性测试"><a href="#1-文件属性测试" class="headerlink" title="1. 文件属性测试"></a>1. 文件属性测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -h </span></span><br><span class="line"><span class="comment"># 如果file存在且是一个符号连接则为真 </span></span><br><span class="line"><span class="keyword">if</span> [ -h file ]; <span class="keyword">then</span></span><br><span class="line">	ehco <span class="string">"hello world"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="2-字符串测试"><a href="#2-字符串测试" class="headerlink" title="2. 字符串测试"></a>2. 字符串测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-z string  <span class="comment"># 如果字符串长度为0 为真</span></span><br><span class="line">-n string  <span class="comment"># 字符串长度不为0 为真</span></span><br></pre></td></tr></table></figure>



<h3 id="command命令"><a href="#command命令" class="headerlink" title="command命令"></a>command命令</h3><p>该命令是bash内置的命令，无视shell脚本中的”同名函数”，执行特定的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断某个命令是否存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span> -v <span class="built_in">pwd</span> &gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"command has found"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"command not found"</span></span><br></pre></td></tr></table></figure>

<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p><code>&gt;</code>等价于<code>1&gt;</code>，1是系统默认的标准输出，可以省略。<br><code>&amp;</code>表示等同的意思：<code>2&gt;&amp;1</code>表示2的输出重定向和1的输出重定向一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">1&gt;</span><span class="bash">/dev/null 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>

<p>上述语句：</p>
<ul>
<li>1&gt;/dev/null : 表示将标准输出重定向到空设备文件</li>
<li>2&gt;&amp;1 : 将标准错误的输出重定向和标准输出一样，标准输出重定向到哪里，标准错误就重定向到哪里</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake使用</title>
    <url>/2019/08/10/cmake%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>cmake是一个构建工具，使用该工具可以用来构建C/C++项目的时候使用cmake命令可以自动生成Makefile文件，然后使用make工具进行项目的编译。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本使用规范"><a href="#基本使用规范" class="headerlink" title="基本使用规范"></a>基本使用规范</h3><p>cmake构建系统是通过多个目标文件组织在一起生成一个二进制可执行文件的，每一个目标对应一个可执行文件或者库文件。</p>
<h4 id="1-可执行目标文件"><a href="#1-可执行目标文件" class="headerlink" title="1. 可执行目标文件"></a>1. 可执行目标文件</h4><p>通过<code>add_executable(target dependency1 dependency2 ....)</code>命令来实现添加希望生成的可执行文件</p>
<h4 id="2-库文件"><a href="#2-库文件" class="headerlink" title="2. 库文件"></a>2. 库文件</h4><p>通过<code>add_library(lib dependency1 dependency2 ...)</code>命令来实现添加生成目标文件。</p>
<p><strong>怎么指定是生成动态库还是静态库呢？</strong></p>
<blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(archive SHARED archive.cpp zip.cpp lzma.cpp)  <span class="comment"># 生成动态库</span></span><br><span class="line"><span class="keyword">add_library</span>(archive STATIC archive.cpp zip.cpp lzma.cpp)  <span class="comment"># 生成静态库，默认是静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(archive MODULE <span class="number">7</span>z.cpp) </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-给目标文件添加文件目录"><a href="#3-给目标文件添加文件目录" class="headerlink" title="3. 给目标文件添加文件目录"></a>3. 给目标文件添加文件目录</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">target</span> directory)</span><br></pre></td></tr></table></figure>

<p>该命令是用来在生成目标文件时指定生成目标文件依赖的源代码的目录。</p>
<h4 id="4-file命令"><a href="#4-file命令" class="headerlink" title="4. file命令"></a>4. file命令</h4><p>这是一个文件操作命令。通过该命令可以有如下的操作：</p>
<ul>
<li>从文件中读</li>
<li>向文件中追加内容，重写内容</li>
</ul>
<p>常用的命令有如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(READ &lt;filename&gt; &lt;variable&gt; [OFFSET &lt;offset&gt;] [LIMIT &lt;max-in&gt;] [HEX])  <span class="comment"># 从文件中读取内容，并且保存到变量里，可以选择开始读取文件的偏移量和读取的最长字节数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(STRINGS &lt;filename&gt; &lt;variable&gt; [&lt;options&gt;...])  <span class="comment"># 按行文件中读取内容，保存在变量中。可以通过option参数对读取到的行进行过滤，只有满足参数条件的字符串才能够被命中保存到变量中，具体的参数值可以参考:https://cmake.org/cmake/help/v3.7/command/file.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(WRITE &lt;filename&gt; &lt;content&gt;...)  <span class="comment"># 将content写入到filename文件中。如果文件不存在就创建，如果文件存在，WRITE模式就会覆盖原文件的内容，APPEND模式就会追加到文件中</span></span><br></pre></td></tr></table></figure>

<h4 id="5-字符串操作命令"><a href="#5-字符串操作命令" class="headerlink" title="5. 字符串操作命令"></a>5. 字符串操作命令</h4><p>cmake提供了对字符串进行操作的命令，可以通过这写命令来对输入的字符串进行查找，过滤、正则匹配等操作。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(FIND &lt;<span class="keyword">string</span>&gt; &lt;substring&gt; &lt;output variable&gt; [REVERSE])  <span class="comment"># 将子串在字符串中的位置赋值给变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>(REPLACE &lt;match_string&gt; &lt;replace_string&gt; &lt;output variable&gt; &lt;input&gt; [&lt;input&gt;...])  <span class="comment"># 使用replace_string来替换所有匹配input中的的match_string，然后将结果保存在变量中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>(REGEX MATCH &lt;regular_expression&gt; &lt;output variable&gt; &lt;input&gt; [&lt;input&gt;...])  <span class="comment"># 使用正则进行处理字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="6-set命令"><a href="#6-set命令" class="headerlink" title="6. set命令"></a>6. set命令</h4><p>使用该命令来对变量值进行设置。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE])  <span class="comment"># 将value值设置到variable上，如果value是多个的话，那么变量就是一个list，可选参数[PARENT_SOCPE]用来限定设置哪个范围的变量</span></span><br></pre></td></tr></table></figure>

<h4 id="7-project命令"><a href="#7-project命令" class="headerlink" title="7. project命令"></a>7. project命令</h4><p>使用改命令来设置项目的信息，项目的名称，版本</p>
<h4 id="8-option命令"><a href="#8-option命令" class="headerlink" title="8. option命令"></a>8. option命令</h4><p>该命令用来与用户进行交互</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(&lt;option_variable&gt; <span class="string">"help string describing option"</span> [initial value])  <span class="comment"># 如果没有设置init value默认使用false</span></span><br></pre></td></tr></table></figure>
<h4 id="9-link-libraires"><a href="#9-link-libraires" class="headerlink" title="9. link_libraires"></a>9. link_libraires</h4><p>该命令是用来给最后生成的app指定以来的库。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">link_libraires(item1 item2 ...)  <span class="comment"># item为依赖的库名</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>该命令和target_link_libraries命令.</p>
<ul>
<li>link_libraries* is used to supply a list of libraries (object archives) to the linker. If the linked item is a cmake target, with specified include directories, they don’t need to be specified separately with.</li>
<li>The target_* versions apply only to the target that is given as an operand. The non-target versions apply to all targets in the directory. The target_* versions should be used whenever possible (i.e. pretty much always).</li>
</ul>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<ol>
<li><a href="https://cmake.org/cmake/help/v3.7" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.7</a></li>
<li><a href="https://stackoverflow.com/questions/56565665/difference-between-target-link-libraries-and-target-include-directories" target="_blank" rel="noopener">https://stackoverflow.com/questions/56565665/difference-between-target-link-libraries-and-target-include-directories</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的基础架构</title>
    <url>/2019/07/27/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在项目部署的时候，如果业务量不大，单台机器能够抗住业务量的需求，此时采用最简单的架构就可以解决需求。直接将数据库和服务部署到一台机器上。随着业务量的增大，单机的可能无法满足需求，</p>
<p>架构的选型，只有合适与不合适。</p>
<h3 id="1-单体架构"><a href="#1-单体架构" class="headerlink" title="1 单体架构"></a>1 单体架构</h3><p>当业务量不大的时候，使用此种架构可以快速的开发产品。</p>
<p>此种架构将所有的代码都放在一个里面。</p>
<p><strong>优点</strong>：容易开发和测试，本地启动一个服务可以测试所有的接口；</p>
<ul>
<li>易于开发</li>
<li>易于部署</li>
<li>易于扩展</li>
</ul>
<p><strong>缺点</strong>：如果有一个地方进行了修改，整个的服务都要重新进行部署。</p>
<h3 id="2-垂直架构"><a href="#2-垂直架构" class="headerlink" title="2 垂直架构"></a>2 垂直架构</h3><p>不同的业务模块分开，是一种模块化的开发思想</p>
<h3 id="3-soa架构"><a href="#3-soa架构" class="headerlink" title="3 soa架构"></a>3 soa架构</h3><p>面向服务的架构。所有的服务通过企业服务总线ESB进行通信。</p>
<h3 id="4-微服务架构"><a href="#4-微服务架构" class="headerlink" title="4 微服务架构"></a>4 微服务架构</h3><p>将每一个具体的业务拆分出来做成一个服务。</p>
<p><strong>优点</strong></p>
<p><strong>缺点</strong></p>
<ul>
<li>服务过多会导致服务治理的成本增加</li>
<li>系统的复杂性增加，定位问题会更加的复杂</li>
</ul>
<h4 id="问题思考："><a href="#问题思考：" class="headerlink" title="问题思考："></a>问题思考：</h4><p><img src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png" alt="服务架构"></p>
<p><strong>说明：</strong></p>
<ul>
<li>服务端：<ul>
<li>service-1和service-2服务部署在主机-A上</li>
<li>service-3服务部署在主机-B上</li>
<li>service-4服务部署在主机-C上</li>
<li>service-5服务部署在了主机-D、主机-E、主机-F上，后期由于业务量的加大service-5服务添加了主机G</li>
</ul>
</li>
<li>网关：<ul>
<li>接口A调用service-1、service-2、service-3三个服务</li>
<li>接口B调用service-3、service-4、service-5三个服务</li>
</ul>
</li>
</ul>
<p><strong>问题1：</strong>接口A的压力过大的时候，可能导致什么问题？</p>
<ul>
<li>service-1服务压力过大，导致服务挂掉</li>
<li>主机-A宕机，service-2服务无法提供服务：解决方案服务隔离</li>
</ul>
<ul>
<li>service-3挂掉，service-3也无法为接口B提供服务</li>
</ul>
<p><strong>问题2：</strong>接口B在调用service-5的时候，怎么确定调用哪个主机上的服务</p>
<p><strong>问题3：</strong>service-5由于压力过大，添加新的机器的时候，接口B怎么知道有新的机器添加了进来，进而能够调用到它？</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>基础架构</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/2019/04/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="0-安装docker"><a href="#0-安装docker" class="headerlink" title="0. 安装docker"></a>0. 安装docker</h1><p>ubuntu环境下安装：<code>sudo apt install docker-io</code><br>centos上安装：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a> 参考官方文档完成安装即可</p>
<p><strong>将用户添加到docker用户组：<code>gpasswd -M mxiaole docker  将mxiaole用户添加到docker组</code></strong></p>
<blockquote>
<p>vagrant + virtualbox使用：借助该工具可以直接在virtualbox中创建虚拟机</p>
<ul>
<li>首先安装virtualbox和vagrant：下载地址<a href="https://www.vagrantup.com/downloads.html和https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.vagrantup.com/downloads.html和https://www.virtualbox.org/wiki/Downloads</a></li>
<li>使用vagrant快速的创建Linux虚拟机：<ul>
<li>创建一个目录centos，然后cd到该目录，执行<code>vagrant init centos/7</code>命令，会生成一个Vagrantfile文件</li>
<li>然后运行<code>vagrant up</code>命令，之后就会创建好了一个虚拟机</li>
<li>连接到生成的虚拟机：<code>vagrant ssh</code></li>
</ul>
</li>
<li>vagrant的其他命令：vagrant status、vagrant halt、vagrant destroy</li>
</ul>
</blockquote>
<h1 id="1-docker-machine使用"><a href="#1-docker-machine使用" class="headerlink" title="1. docker-machine使用"></a>1. docker-machine使用</h1><p>这个工具可以用来创建远端的docker server，但是要有相关的驱动，然后在本地使用docker-machine命令就可以在virtual-box, vm-ware, aws，aliyun上使用相应的驱动创建安装了docker的虚拟机。</p>
<p>使用virtualbox驱动直接创建一个安装了docker的虚拟机：<code>docker-machine create 虚拟机的名字</code><br>直接进入创建好的虚拟机：<code>docker-machine ssh 虚拟机的名字</code><br>docker-machine 的其他命令，使用docker-manchine –help 查看</p>
<blockquote>
<p>tips<br>可以使用mac上的client 连接docker-machine创建的安装了docker的虚拟机，在终端执行如下的两条命令：<br><code>docker-machine env 虚拟机的名字</code>  ,  <code>eval ($docker-machine env 虚拟机的名字)</code><br>撤销使用的命令： <code>docker-machine env --unset</code>, <code>eval $(docker-machine env --unset)</code></p>
</blockquote>
<p>dockerplayground可以随意的玩</p>
<h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" alt="docker架构图"></p>
<p>共享宿主机的kernel</p>
<h2 id="docker使用的底层技术主要有："><a href="#docker使用的底层技术主要有：" class="headerlink" title="docker使用的底层技术主要有："></a>docker使用的底层技术主要有：</h2><ul>
<li>namespace实现隔离. <a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">详细了解参考</a></li>
<li>cgroup实现资源限制</li>
<li>union file systems实现container和image分层</li>
</ul>
<p>这些技术都是Linux上自带的。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><strong>镜像image</strong>: 在docker中，所有的应用程序都被制作成了镜像</li>
<li><strong>容器container</strong>: 每一个基于镜像的应用程序都必须在容器中才能执行</li>
<li><strong>宿主机</strong>: 运行docker这个应用程序的机器称为宿主机</li>
</ul>
<p>镜像的分层概念。</p>
<h1 id="3-image"><a href="#3-image" class="headerlink" title="3. image"></a>3. image</h1><h2 id="3-1-是什么"><a href="#3-1-是什么" class="headerlink" title="3.1 是什么"></a>3.1 是什么</h2><ul>
<li>是文件和meta data的集合。</li>
<li>分层，每一层都可以添加删除改变文件，称为一个新的image</li>
<li>不同的image可以共享相同的layer</li>
<li>image本身是只读的</li>
</ul>
<h2 id="3-2-怎么操作"><a href="#3-2-怎么操作" class="headerlink" title="3.2 怎么操作"></a>3.2 怎么操作</h2><p><strong>1. 获取image</strong></p>
<p>有三种获取image的方法：</p>
<ul>
<li>自己创建dockerfile文件，进行构建image: docker build -t imagename:tag .</li>
<li>基于container创建一个image: docker container commit (不推荐使用)</li>
<li>直接从镜像仓库中获取: docker pull imagename</li>
</ul>
<p><strong>2. 发布image</strong></p>
<p><strong>发布到dockerhub</strong></p>
<ul>
<li><p>创建一个docker hub账号，被push的image的name必须是<code>dockerhubID/imagename[:tag]</code></p>
</li>
<li><p>在发布之前必须先登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker image push mxiaole/hello-world:latest</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>推荐的做法是将dockerhub和github进行关联，在github上发布dockerfile，然后dockerhub会自动的根据dockerfile创建image</p>
<p><strong>发布到私有的dockerhub</strong></p>
<ul>
<li>使用docker创建一个私有的dockerhub: <code>docker run -d -p 5000:5000 --restart always --name registry registry:2</code></li>
<li>向本地私有仓库提交image的时候，镜像的名字必须是<code>10.10.10.2:8888/hello</code>, registry的IP:端口，开头</li>
<li>然后，使用命令<code>dockr push 10.10.2:888/hello</code>向本地仓库push镜像，但是这个时候可能会出错，<ul>
<li>在/etc/docker/目录下创建一个文件:daemon.json，添加内容<code>{&quot;insecure-registries&quot;: [&quot;10.0.2.15:500&quot;]}</code></li>
<li>同时在/lib/systemd/system/docker.service文件中添加一行: <code>EnvironmenFile=-/etc/docker/daemon.json</code></li>
<li>最后重启docker：<code>sudo service docker restart</code></li>
</ul>
</li>
<li>验证镜像是否成功的push： <code>curl localhost:5000/v2/_catlog</code> 查看</li>
</ul>
<h1 id="4-创建image"><a href="#4-创建image" class="headerlink" title="4. 创建image"></a>4. 创建image</h1><h2 id="4-1-基于container创建image"><a href="#4-1-基于container创建image" class="headerlink" title="4.1 基于container创建image"></a>4.1 基于container创建image</h2><p><code>docker commit containername newimage</code> 使用上述的命令能够基于已经存在的container创建一个新的image</p>
<h2 id="4-2-使用Dockerfile创建image"><a href="#4-2-使用Dockerfile创建image" class="headerlink" title="4.2 使用Dockerfile创建image"></a>4.2 使用Dockerfile创建image</h2><p>Dockerfile常用的命令：</p>
<ul>
<li><p>FROM: 指定创建image的base image是什么 ; 尽量使用官方的image作为baseimage</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br></pre></td></tr></table></figure></li>
<li><p>LABEL: </p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"mxiaole"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">"this is description"</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>RUN:  创建镜像时执行的命令，每运行一次该命令，就会生成新的一层; 将多条命令放在一行，如果需要换行使用\</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install vim &amp;&amp; yum install git &amp;&amp; yum install gcc</span></span><br></pre></td></tr></table></figure>
<p><strong>命令有两种格式，cmd和entrypoint命令也是如此</strong></p>
<ul>
<li>shell格式<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt install -y vim</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span></span></span><br></pre></td></tr></table></figure></li>
<li>exec格式<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"apt"</span>, <span class="string">"install"</span>, <span class="string">"-y"</span>, <span class="string">"vim"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"hello world"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"hello world"</span>]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CMD: 设置容器启动之后默认执行的命令和参数, 如果在docker run的时候执行了其他的命令，那么cmd命令会被忽略；如果定义了多个cmd命令，只有最后一个会被执行。</p>
</li>
<li><p>ENTRYPOINT: 设置容器启动时执行的命令；让容器以应用程序或者服务的形式运行；该命令不会被忽略,docker run 指定的启动命令作为参数传递给它设置的命令；最好是写一个shell脚本作为entrypoint</p>
</li>
<li><p>WORKDIR: 用来设定当前的工作目录; 尽量是用绝对路径，不要使用相对路径</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> demo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span>  <span class="comment"># 输出结果应该是/root/demo</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>ADD &amp;&amp; COPY: 这两个命令都是将本地的文件，添加到docker image中<br><strong>两者的区别</strong>:</p>
<ul>
<li>ADD命令还可以进行解压: ADD xxx.tar.gz /</li>
<li>大部分的情况优先使用COPY</li>
</ul>
</li>
<li><p>ENV: 用来设定环境变量</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MYSQL_VERSION <span class="number">5.7</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install mysql=<span class="variable">$&#123;MYSQL_VERSION&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>VOLUME: 指定当前容器中要备份的文件路径，会将docker container中该路径下的文件挂载到宿主机上的某个位置。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /var/lib/mysql</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-3-demo"><a href="#4-3-demo" class="headerlink" title="4.3 demo"></a>4.3 demo</h2><p><strong>demo1: 创建一个Python的flask应用</strong></p>
<ul>
<li>创建dockerfile<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"mxiale"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install flask</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> main.py /app/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"main.py"</span>]</span></span><br></pre></td></tr></table></figure></li>
<li>build镜像文件 : <code>docker build -t mxiaole/flask-demo .</code></li>
<li>运行创建的镜像：<code>docker run -d mxiaole/flask-demo</code></li>
</ul>
<p><strong>使用dockerfile创建image时的debug</strong><br>因为在build的时候，每一层都会生成一个镜像，可以通过运行这些中间生成的镜像来进行debug</p>
<p><strong>demo2: 创建一个命令行工具</strong></p>
<ul>
<li>创建dockerfile<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update &amp;&amp; apt install stress</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/bin/stress/"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> []</span></span><br></pre></td></tr></table></figure></li>
<li>创建镜像：<code>docker build -t mxiaole/ubuntu-stress .</code></li>
<li>使用: <code>docker run -it mxiaole/ubuntu-stress --help</code> 可以直接指定stress的命令参数</li>
</ul>
<h1 id="5-container操作"><a href="#5-container操作" class="headerlink" title="5. container操作"></a>5. container操作</h1><h2 id="5-1-启动容器"><a href="#5-1-启动容器" class="headerlink" title="5.1 启动容器"></a>5.1 启动容器</h2><p>最简单的启动方式就是：<code>docker run image</code>。容器的生命周期：运行时，运行结束后退出。</p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul>
<li>exec命令: <code>docker exec -it conainerid /bin/bash</code> 进入一个运行的容器</li>
<li>inspect: <code>docker inspect conainerid</code> 检测一个container的信息</li>
<li>logs: <code>docker logs containerid</code> 查看container的输出日志</li>
</ul>
<blockquote>
<p>tips: 快速清除多个container<br>docker container ls -aq  # 查看容器的ID<br>docker rm $(docker container ls -aq)  # 可以实现快速的删除多个container<br>docker container ls -f “status=exited” -q  # 查看所有的已经退出的container<br>docker rm $(docker container ls -f “status=exited” -q)  # 快速的清除所有已经退出的container</p>
</blockquote>
<h1 id="6-网络管理"><a href="#6-网络管理" class="headerlink" title="6. 网络管理"></a>6. 网络管理</h1><p><img src="docker%E7%BD%91%E7%BB%9C.png" alt="docker网络"></p>
<p>Docker使用Linux桥接，在宿主机上虚拟一个Docker网桥。Docker在启动一个容器时会根据Docker网桥的网段分配容器的IP，同时Docker网桥是每个容器的默认网关。</p>
<p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络无法寻址到，如果希望容器能够被外部网络访问到，就需要通过映射容器端口到宿主机的端口</p>
<h1 id="7-数据持久化"><a href="#7-数据持久化" class="headerlink" title="7. 数据持久化"></a>7. 数据持久化</h1><p>Docker中的数据持久化：使用Docker数据卷将宿主机上的文件或者目录挂载到容器中。</p>
<p><strong>如果使用容器，启动一个myql，当这个container销毁后，如果MySQL中的数据保存在container中，那么MySQL中的数据也会消失；这时候应该怎么处理呢？</strong></p>
<p>将宿主机上的目录或者文件挂载到容器中，即使容器销毁，数据卷中的数据仍然保留在宿主机上，下次启动的时候可以使用。</p>
<p>共有两种 Volume 类型。每种 Volume 都是宿主机上的的一个目录对应到container内的一个目录，其不同只在于主机上的位置。</p>
<p>第 1 种叫绑定挂载的 Volume (bind mount volume)：用户<strong>指定将主机上的某个目录</strong>挂载到<strong>容器中的某个目录</strong>。(-v参数指定，宿主机的目录：container的目录， 这两个目录是一一对应的)， 在运行container的时候，直接使用-v参数指定。</p>
<p>第 2 种叫受管理的 Volume (managed volume)：所使用的主机上的位置是由 Docker daemon 创建并管理的，这些位置称为 Docker managed space, 在dockerfile文件中使用VOLUME指令指定volume的路径，然后使用-v参数给这个volume起个名字, 这个volume对应的宿主机的位置不是用户指定的，是docker运行时自动指定的。</p>
<p>例如：创建一个MySQL container: <code>docker run -d --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql</code>, 这时候查看一下<code>docker volume ls</code>会看到生成了一个volume，使用<code>docker volume inspect volumenameid</code>命令可以查看详情</p>
<p>上面的命令创建的container生成的volumeID不方便使用，可以使用<code>docker run -d -v mysql:/var/lib/mysql --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql</code>创建（-v参数指定volume的名字），当把创建的MySQL container销毁之后，下一次启动一个新的container(<code>docker run -d -v mysql:/var/lib/mysql --name mysql2 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql</code>)的时候可以继续通过volume的名字指定使用销毁的container的volume。</p>
<p>上述命令中的<code>-v</code>参数：指定生成的volume名字，前面的参数是volume名字:后面的是容器中备份文件的路径，</p>
<p><strong>demo: bind mount使用</strong></p>
<p>考虑这样一个场景：假如我们只有mac环境，但是我们在Mac上安装了docker。我们想要使用Mac的pycharm ide开发了一个Flask项目，我们可以创建一个Dockerfile，然后将这个项目创建一个镜像，然后运行这个镜像到container中。但是突然发现我们还有一个功能没有开发，这时候会频繁的修改Flask项目中的文件，如果我们每做一次修改就要重新build创建一个镜像，然后运行，实在是太麻烦了，这个时候我们可以考虑使用这个bind mount神器。具体操作如下：</p>
<ul>
<li>将初次的项目，创建一个镜像，然后运行的时候使用-v参数：<code>docker run -p 5000:5000 -d --name flask -v $(pwd):/root/flask mxiaole/myflask</code></li>
<li>之后，可以在Mac上修改项目文件，这些文件或自动的同步到container中</li>
</ul>
<p><strong>demo2: wordpress搭建</strong></p>
<ul>
<li>docker run -d –name mysql -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=wordpress mysql:5.7</li>
<li>docker run -d -e WORDPRESS_DB_HOST=mysql:3306 –link mysql -p 8080:80 wordpress</li>
</ul>
<h1 id="8-docker-compose"><a href="#8-docker-compose" class="headerlink" title="8. docker-compose"></a>8. docker-compose</h1><p>如果我们想要创建一个Python项目，这个Python项目依赖MySQL和Redis和Nginx，这时候需要手动的创建这些container，为了减少复杂度，我们可以将这些container创建成一个组，将这些容器进行统一的启动，删除等操作。docker-compose就是为了解决这个问题的。</p>
<p>注意：该方式不适合在生产环境使用</p>
<h2 id="8-1-使用"><a href="#8-1-使用" class="headerlink" title="8.1 使用"></a>8.1 使用</h2><p>基本的使用流程：创建一个docker-compose.yaml文件，然后使用docker-compose进行操作。</p>
<p><strong>命令</strong></p>
<ul>
<li>docker-compose up</li>
<li>docker-compose images</li>
<li>docker-compose ps</li>
<li>docker-compose exec </li>
</ul>
<h2 id="8-2-docker-compose-yml文件"><a href="#8-2-docker-compose-yml文件" class="headerlink" title="8.2 docker-compose.yml文件"></a>8.2 docker-compose.yml文件</h2><p>可以直接指定镜像启动，也可以通过在compose文件中使用build命令在文件中先build镜像，然后在启动镜像。</p>
<p>docker-compose.yaml文件, 该文件主要有三个基本的概念：service，networks，volumes.</p>
<p><strong>services</strong>：一个service代表一个container，可以给service指定network和volume</p>
<p>水平扩展：<code>docker-compose up --scale web=3  -d</code>, 该命令只能实现单机上的扩容，无法实现多个物理机器上的扩容，如果想要扩容还需要使用swarm</p>
<h1 id="9-swarm容器编排"><a href="#9-swarm容器编排" class="headerlink" title="9. swarm容器编排"></a>9. swarm容器编排</h1><p>在集群中管理docker镜像</p>
<h2 id="9-1-基础"><a href="#9-1-基础" class="headerlink" title="9.1 基础"></a>9.1 基础</h2><p>物理机两个角色：manager 和 worker。swarm集群的初始化：<code>docker swarm init --advertise-addr=想要做manager的节点ip</code>，初始化manager节点</p>
<p>集群相关的命令：<code>docker node</code></p>
<p>在docker swarm集群中创建service不在使用<code>docker run</code>命令，而是使用<code>docker service create</code>命令.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create      Create a new service  # 创建一个服务</span><br><span class="line">inspect     Display detailed information on one or more services</span><br><span class="line">logs        Fetch the logs of a service or task</span><br><span class="line">ls          List services</span><br><span class="line">ps          List the tasks of one or more services</span><br><span class="line">rm          Remove one or more services</span><br><span class="line">rollback    Revert changes to a service's configuration</span><br><span class="line">scale       Scale one or multiple replicated services  # 横向扩展服务</span><br><span class="line">update      Update a service</span><br></pre></td></tr></table></figure>

<h2 id="9-2-swarm中的docker-compose"><a href="#9-2-swarm中的docker-compose" class="headerlink" title="9.2 swarm中的docker-compose"></a>9.2 swarm中的docker-compose</h2><p>首先创建docker-compose文件，然后使用命令<code>docker stack</code>命令来部署服务</p>
<h2 id="9-2-实践"><a href="#9-2-实践" class="headerlink" title="9.2 实践"></a>9.2 实践</h2><p>使用docker-machine命令创建三个安装了docker的虚拟机.<br>1.前提条件：</p>
<ul>
<li>安装了docker-machine工具</li>
<li>安装了virtual-box驱动</li>
</ul>
<p>2.安装</p>
<p>依次执行命令：<code>docker-machine create swarm-manager</code>, <code>docker-machine create swarm-worker1</code>, <code>docker-machine create swarm-worker2</code></p>
<p>3.初始化</p>
<ul>
<li>登录要作为manager的主机：<code>docker-machine ssh swarm-manager</code>, 然后执行命令: <code>docker swarm init --advertise-addr=192.168.99.101</code>，之后会得到<code>docker swarm join --token SWMTKN-1-0etbagd0a455sx2b7bu0va69qhdqzti8bc7hhqohi7rzm29lus-ekf933f62naxe37s52bk64umq 192.168.99.101:2377</code></li>
<li>登录worker机器：分别执行上面的命令输出的命令<code>docker swarm join --token SWMTKN-1-0etbagd0a455sx2b7bu0va69qhdqzti8bc7hhqohi7rzm29lus-ekf933f62naxe37s52bk64umq 192.168.99.101:2377</code></li>
<li>检查集群的状态：登录manager节点，执行<code>docker node ls</code>命令</li>
</ul>
<p>4.部署wordpress服务</p>
<ul>
<li>在manager节点上创建一个overlay驱动的网络: <code>docker network create -d overlay demo</code></li>
<li>在manager节点上创建MySQL服务: <code>docker service create --name mysql --env MYSQL_ROOT_PASSWORD=root --env MYSQL_DATABASE=wordpress --network demo --mount type=volume,source=mysql-data,destination=/var/lib/mysql mysql:5.7</code></li>
<li>在manager节点上创建wordpress服务：<code>docker service create --name wordpress -p 80:80 --env WORDPRESS_DB_PASSWORD=root --env WORDPRESS_DB_HOST=mysql --network demo wordpress</code></li>
</ul>
<h2 id="9-3-swarm中的密码管理Dockersecret"><a href="#9-3-swarm中的密码管理Dockersecret" class="headerlink" title="9.3 swarm中的密码管理Dockersecret"></a>9.3 swarm中的密码管理Dockersecret</h2><p><strong>创建</strong><br>使用<code>docker secret create</code>命令来创建secret，可以从标准输入来创建，也可以从文件来创建。</p>
<ul>
<li><code>docker secret create secret名字  文件名</code></li>
<li><code>echo &quot;*****&quot; | docker secret create secretname  -</code>  </li>
</ul>
<p><strong>使用</strong></p>
<ul>
<li><p>在命令行中使用：在创建container的时候通过–secret参数来指定secret, 然后会被保存在container上的/run/secrets目录下。例如使用MySQL密码使用：在创建container的时候可以使用如下的命令：<br><code>docker service create --name mysql --secret secretname -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/secretname mysql:5.7</code></p>
</li>
<li><p>在docker-compose文件中使用: 可以使用secret标签先创建然后使用, 也可以先手动创建然后service中直接使用。推荐采用后者。<br>方式1：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">aaa:</span></span><br><span class="line">    <span class="string">xxxxx</span> </span><br><span class="line">  </span><br><span class="line">  <span class="attr">secrect:</span></span><br><span class="line">    <span class="attr">my-pwd:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">./password</span></span><br></pre></td></tr></table></figure>
<p>方式2：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-pwd</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="9-4-docker-swarm-service的更新"><a href="#9-4-docker-swarm-service的更新" class="headerlink" title="9.4 docker swarm service的更新"></a>9.4 docker swarm service的更新</h2><p>在不停服的情况下对server进行更新：首先将service进行水平扩展<code>docker service scale server_container_name=2</code>, 然后使用命令<code>docker service update --image new_image_name server_container_name</code></p>
<p>通过端口更新, 这样会导致业务的中断：<code>docker service update --publish-rm 8080:5050 --publish-add 9999:5050 container-name</code></p>
<p>对于通过docker-compose文件创建的service的更新，需要直接修改docker-compose文件，然后重新执行docker stack deploy。</p>
<blockquote>
<p>参考文章<br>1.<a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/cli/</a><br>2.《Docker进阶与实战》<br>3.<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka权威指南笔记</title>
    <url>/2019/04/25/kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><ul>
<li>消息：kafka的数据单元</li>
<li>主题：kafka中的每个消息都属于一个<code>主题</code></li>
<li>分区：分区是消息存储的物理单元，一个主题中的消息，通过<code>分区器</code>的作用存储在不同的分区中。<code>同一个主题的多个分区，可能分布在不同的机器上</code>。</li>
<li>生产者：将一个消息发送到某个主题的分区中</li>
<li>消费者：消费者消费分区中的消息，通过<code>偏移量</code>来保证顺序消费某个分区中的消息。</li>
<li>消费者群组：消费者是以消费者群组的形式存在的，消费者群组中有一个或者多个消费者，一个指定的消费者群组会订阅一个主题。群组保证每个分区只能被一个消费者使用。</li>
<li>broker：一个部署了kafka服务的服务器被称为一个broker。每个集群中都会有一个充当集群控制器的broker。在集群中一个分区从属于一个broker，该broker被称为分区的<code>首领</code>。一个分区可以分配给多个broker。</li>
<li>保留消息：kfka通过某种策略来对消息进行保留。</li>
</ul>
<h4 id="2-kafka的特性"><a href="#2-kafka的特性" class="headerlink" title="2 kafka的特性"></a>2 kafka的特性</h4><ul>
<li>多个消费者：与其他的消息队列不同，消息一旦被一个客户端读取，其他的客户端就无法在读取它。kafka的消息可以被多个消费者读取。</li>
<li>基于磁盘的数据存储：kafka允许消费者，非实时的进行消息的读取。消息被提交到磁盘，根据设置的保留规则进行保存。每个主题都可以设置单独的保留规则</li>
</ul>
<h4 id="3-安装和部署"><a href="#3-安装和部署" class="headerlink" title="3 安装和部署"></a>3 安装和部署</h4><p>kakfa使用zookeeper来保存集群的<code>元数据</code>信息和消费者消息。<br>使用进行安装部署，docker-compose.yml文件内容入如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/zookeeper</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"2181"</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"9092"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span>  <span class="number">192.168</span><span class="number">.2</span><span class="number">.10</span> <span class="comment">#宿主机的ip地址</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper:2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure>

<h4 id="4-kafka生产者"><a href="#4-kafka生产者" class="headerlink" title="4 kafka生产者"></a>4 kafka生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCallBack</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者, 向kafka集群中发送message</span></span><br><span class="line"><span class="comment">     * produce向集群push消息</span></span><br><span class="line"><span class="comment">     * 可以同步的向集群发送消息，也可以异步的发送消息</span></span><br><span class="line"><span class="comment">     * 怎么确定将消息发送到哪个partition上呢？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"127.0.0.1:32796, 127.0.0.1:32797, 127.0.0.1:32798"</span>);  <span class="comment">// consumer连接到broker集群</span></span><br><span class="line">        properties.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);  <span class="comment">// 指定消息发送的模式，all</span></span><br><span class="line">        properties.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line">        properties.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line">        properties.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line">        properties.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                String msg = <span class="string">"Message "</span> + i;</span><br><span class="line">                <span class="comment">/*指定发送的topic*/</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"test1"</span>, msg), <span class="keyword">new</span> DemoCallBack());  <span class="comment">// 指定要发送的topic和消息体</span></span><br><span class="line">                System.out.println(<span class="string">"Sent:"</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-kafka消费者"><a href="#5-kafka消费者" class="headerlink" title="5 kafka消费者"></a>5 kafka消费者</h4><p><img src="kafka_jiagou.jpg" alt="kafka架构简图"></p>
<blockquote>
<p>参考文章</p>
<ol>
<li><a href="https://tomoyadeng.github.io/blog/2018/06/02/kafka-cluster-in-docker/index.html" target="_blank" rel="noopener">https://tomoyadeng.github.io/blog/2018/06/02/kafka-cluster-in-docker/index.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>kakfa</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2019/04/21/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h4 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h4><p>使用ubuntu搭建dvwa1.9进行SQL注入测试, 安全级别设置为low。</p>
<h4 id="1-SQL注入原理"><a href="#1-SQL注入原理" class="headerlink" title="1 SQL注入原理"></a>1 SQL注入原理</h4><p>首先，我们应该清楚我们进行SQL注入的目的是什么，怎么通过SQL注入来达到我们的目的。另外，了解常见的SQL注入常用的方式，手动注入和使用工具如SQLmap进行自动注入。SQL注入的危害主要有如下：</p>
<ul>
<li>猜解后台数据库，就是通过常用的SQL注入语句，一点点的将数据库中存在的数据库，表，表中的字段给破解，获取数据库的详细信息</li>
<li>绕过认证，没有用户名和密码的情况下能够直接登录网站</li>
<li>可以借助数据库的存储过程进行提权</li>
</ul>
<h4 id="2-实战-猜解后台数据库"><a href="#2-实战-猜解后台数据库" class="headerlink" title="2 实战-猜解后台数据库"></a>2 实战-猜解后台数据库</h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><ul>
<li><p>判断目标是否存在SQL注入漏洞，如果存在注入，那么注入是字符型还是数字型</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通常存在SQL注入的url一般具有特定的格式，如：http:&#x2F;&#x2F;xxx.xxx.xxx&#x2F;abcd.php?id&#x3D;XX，在如php，jsp，asp动态网页中且此网页访问了数据库常存在SQL注入。</span><br><span class="line">常用单引号的方法来判断是否存在SQL注入，因为单引号会造成数据库单引号个数不匹配的异常。</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆解SQL查询语句中的字段数</p>
</li>
<li><p>确定显示的字段顺序</p>
</li>
<li><p>获取当前数据库</p>
</li>
<li><p>获取数据库中的表</p>
</li>
<li><p>获取表中的字段名</p>
</li>
<li><p>下载数据</p>
</li>
</ul>
<h4 id="实战详解"><a href="#实战详解" class="headerlink" title="实战详解"></a>实战详解</h4><blockquote>
<p>参考：<br><a href="https://www.jianshu.com/p/078df7a35671" target="_blank" rel="noopener">https://www.jianshu.com/p/078df7a35671</a></p>
</blockquote>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch学习</title>
    <url>/2019/04/20/es%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="1-入门基础"><a href="#1-入门基础" class="headerlink" title="1. 入门基础"></a>1. 入门基础</h4><h5 id="1-1-安装部署"><a href="#1-1-安装部署" class="headerlink" title="1.1 安装部署"></a>1.1 安装部署</h5><p>在物理机上部署：官网下载es，然后直接解压，执行bin/elasticsearch，通过指定-d参数可以实现后台启动。<br>也可以采用docker进行部署，<a href="https://www.jianshu.com/p/fdfead5acc23" target="_blank" rel="noopener">参考地址</a></p>
<h5 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h5><p>es中存储的是文档，这些文档是使用json进行序列化的。<code>文档</code>可以理解为关系型数据库中的<code>行记录</code>，es中的<code>索引</code>可以理解为关系型数据库中的<code>数据库</code>，<code>类型</code>可以理解为关系型数据库中的<code>表</code>。</p>
<h4 id="2-es-restful-api简单操作"><a href="#2-es-restful-api简单操作" class="headerlink" title="2. es restful api简单操作"></a>2. es restful api简单操作</h4><ul>
<li><p>创建索引: <code>curl -X PUT &quot;localhost:9200/索引名字&quot;</code></p>
</li>
<li><p>删除索引：<code>curl -X DELETE &#39;localhost:9200/索引的名字&#39;</code></p>
</li>
<li><p>查看es中的所有索引: <code>curl -XGET &#39;localhost:9200/_cat/indices?v&amp;pretty&#39;</code></p>
</li>
<li><p>插入文档</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl -X PUT 'localhost:9200/accounts/person/1' -d '</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: <span class="string">"张三"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"工程师"</span>,</span><br><span class="line">    <span class="attr">"desc"</span>: <span class="string">"数据库管理"</span></span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>

<p>  上述api中: accounts表示索引的名字，person表示类型的名字，1表示带插入的文档的id。也可以不指定id但是要使用post发送请求，如下</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl -X POST 'localhost:9200/accounts/person' -d '</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>: <span class="string">"李四"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"工程师"</span>,</span><br><span class="line">    <span class="attr">"desc"</span>: <span class="string">"系统管理"</span></span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定索引中的指定类型的某个id的文档数据</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl 'localhost:9200/accounts/person/1?pretty=true'</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定索引的指定类型的所有的文档数据</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl 'localhost:9200/accounts/person/_search?pretty=true'</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定id的文档</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl -X DELETE 'localhost:9200/accounts/person/1'</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新文档</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl -X PUT 'localhost:9200/accounts/person/1' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "user" : "张三",</span><br><span class="line">    "title" : "工程师",</span><br><span class="line">    "desc" : "数据库管理，软件开发"</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-查询详解"><a href="#3-查询详解" class="headerlink" title="3 查询详解"></a>3 查询详解</h4><h5 id="查询字符串搜索"><a href="#查询字符串搜索" class="headerlink" title="查询字符串搜索"></a>查询字符串搜索</h5><p>就是在查询的语句中使用q进行参数传递</p>
<h5 id="DSL搜索"><a href="#DSL搜索" class="headerlink" title="DSL搜索"></a>DSL搜索</h5><h4 id="2-java-api"><a href="#2-java-api" class="headerlink" title="2. java api"></a>2. java api</h4><h4 id="3-python-api"><a href="#3-python-api" class="headerlink" title="3. python api"></a>3. python api</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ESManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    elasticsearch操作类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hosts)</span>:</span></span><br><span class="line">        self.client = Elasticsearch(hosts=hosts)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, index, body=None)</span>:</span></span><br><span class="line">        res = self.client.search(index, body)</span><br><span class="line">        hits = res[<span class="string">"hits"</span>][<span class="string">"hits"</span>]</span><br><span class="line">        <span class="keyword">return</span> json.dumps(hits, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_one_by_id</span><span class="params">(self, index, id, _type)</span>:</span></span><br><span class="line">        res = self.client.get(index, id, _type)</span><br><span class="line">        source = res[<span class="string">"_source"</span>]</span><br><span class="line">        <span class="keyword">return</span> source</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_many_by_ids</span><span class="params">(self, ids: list, doc_type: str, index: str)</span> -&gt; iter:</span></span><br><span class="line">        body = &#123;<span class="string">"ids"</span>: ids&#125;</span><br><span class="line">        res = self.client.mget(body, doc_type, index)</span><br><span class="line">        docs = res[<span class="string">"docs"</span>]</span><br><span class="line">        <span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">            source = doc[<span class="string">"_source"</span>]</span><br><span class="line">            <span class="keyword">yield</span> json.dumps(source, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    node = [<span class="string">"localhost:9200"</span>]</span><br><span class="line"></span><br><span class="line">    client = ESManager(node)</span><br><span class="line">    body = &#123;</span><br><span class="line">        <span class="string">"query"</span>: &#123;</span><br><span class="line">            <span class="string">"bool"</span>: &#123;</span><br><span class="line">                <span class="string">"must"</span>: [</span><br><span class="line">                    &#123;<span class="string">"match"</span>: &#123;<span class="string">"title"</span>: <span class="string">"Search"</span>&#125;&#125;,</span><br><span class="line">                    &#123;<span class="string">"match"</span>: &#123;<span class="string">"content"</span>: <span class="string">"Elasticsearch"</span>&#125;&#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"filter"</span>: [</span><br><span class="line">                    &#123;<span class="string">"term"</span>: &#123;<span class="string">"status"</span>: <span class="string">"published"</span>&#125;&#125;,</span><br><span class="line">                    &#123;<span class="string">"range"</span>: &#123;<span class="string">"publish_date"</span>: &#123;<span class="string">"gte"</span>: <span class="string">"2015-01-01"</span>&#125;&#125;&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询多条</span></span><br><span class="line">    res = client.search(<span class="string">"books"</span>, body)</span><br><span class="line">    res = client.search(<span class="string">"books"</span>)</span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="comment"># 根据id查询</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">    res = client.query_one_by_id(<span class="string">"books"</span>, <span class="string">"Cx1nCWQB-ZDs_wiUraqf"</span>, <span class="string">"novel"</span>)</span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    id_list = [<span class="string">"Cx1nCWQB-ZDs_wiUraqf"</span>, <span class="string">"BB1nCWQB-ZDs_wiUraqL"</span>, <span class="string">"FB1nCWQB-ZDs_wiUraq3"</span>]</span><br><span class="line">    a = time.time()</span><br><span class="line">    res = client.query_many_by_ids(id_list, <span class="string">"novel"</span>, <span class="string">"books"</span>)</span><br><span class="line">    print(time.time() - a)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">        print(r)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考文章<br><a href="https://blog.csdn.net/ax8785r8C32nef593/article/details/78988443" target="_blank" rel="noopener">https://blog.csdn.net/ax8785r8C32nef593/article/details/78988443</a></p>
</blockquote>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>lua编程</title>
    <url>/2019/04/20/lua%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://github.com/andycai/luaprimer/blob/master/01.md" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>python深入理解</title>
    <url>/2019/04/18/python%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="1-python的编译结果"><a href="#1-python的编译结果" class="headerlink" title="1. python的编译结果"></a>1. python的编译结果</h4><h5 id="1-1-python程序的执行程"><a href="#1-1-python程序的执行程" class="headerlink" title="1.1 python程序的执行程"></a>1.1 python程序的执行程</h5><p>python文件的执行是通过<code>解释器</code>来执行的。当敲入python命令的时候，目的就是为了激活解释器，在真正开始执行之前，python解释器要首先编译.py文件，通过编译得到python的<code>字节码.pyc</code>文件，然后将编译的字节码<code>.pyc</code>文件交给python<code>虚拟机</code>，虚拟机按<br>照顺序一条条的执行字节码。在.py文件进行编译之后除了产生.pyc文件，还会产生其他的一些信息。<br>在.pyc文件中保存的是.py源代码中出现的一切有用的<code>静态信息</code>，在python运行期间这些静态信息会被存储在一个<code>运行时的对象</code>中。<strong>当python运行结束后，这个运行对象中包含的信息会存储在pyc文件中</strong>。这个运行时的对象就是<code>PyCodeObject</code>。</p>
<blockquote>
<p>在程序运行期间，编译结果存在于内存的PyCodeObject对象中，而python运行结束后，编译结果保存在pyc文件中。当下一次运行相同的程序时，python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，不用在对源文件进行编译了。</p>
</blockquote>
<h5 id="PyCodeObject对象"><a href="#PyCodeObject对象" class="headerlink" title="PyCodeObject对象"></a>PyCodeObject对象</h5><p><strong>对于源代码中的一个<code>code block</code>，python编译器在对源代码进行编译的时候就会创建一个<code>PyCodeObject对象</code>与这个代码块进行对应。</strong> 那么一个code block是多少代码呢？当进入一个新的名字或者作用域时，就算是进入了一个新的code block。如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>上述的代码会产生三个PyCodeObject对象：一个对应demo.py文件，一个对应class A代表的code block，最后一个是fun所对应的code block。</p>
<h5 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h5><p>名字空间是符号的上下文环境，名字空间可以一个套一个形成一个<code>名字空间链</code>。python虚拟机在执行的时候，会有很大一部分时间消耗在从这条名字空间链中确定一个<code>符号所应该对应的对象</code>是什么。在python中，类、函数、module都对应着一个独立的名字空间。名字空间实际上式维护这变量名和变量值之间关系的PyDictObject。</p>
<h4 id="1-2-pyc文件"><a href="#1-2-pyc文件" class="headerlink" title="1.2 pyc文件"></a>1.2 pyc文件</h4><p>每一个PyCodeObject对象中，都包含每一个code block中所有的python源代码经过编译后得到的byte code序列。</p>
<h5 id="import机制与pyc文件生成"><a href="#import机制与pyc文件生成" class="headerlink" title="import机制与pyc文件生成"></a>import机制与pyc文件生成</h5><p>python中的import会触发pyc文件的生成。python在运行的时候，碰到import abc这样的语句，那么python将到设定好的path中国寻找abc.pyc文件，如果没有找到，而只是找到了abc.py文件，那么python首先将abc.py编译成PyCodeObjct中间结果，然后创建abc.pyc文件，并将中间结果写入该文件。之后才会对abc.pyc文件执行import动作。</p>
<h5 id="pyc文件的内容"><a href="#pyc文件的内容" class="headerlink" title="pyc文件的内容"></a>pyc文件的内容</h5><p>pyc文件主要包含了三部分独立的信息：</p>
<ul>
<li>python的magic number，该信息是用来保证python的兼容性的。python在加载pyc文件的时候，会首先检查这个值，如果python自身的magic number与待加载的pyc文件中记录的该值不一致，就会拒绝加载该文件。</li>
<li>pyc文件的创建时间信息，如果我们修改了生成pyc文件的原文件，那么python在加载的时候会发现pyc文件时间早于py文件的时间，于是会重新编译pyc文件的原文件，生成新的pyc文件</li>
<li>PyCodeObject对象</li>
</ul>
<h5 id="python字节码指令"><a href="#python字节码指令" class="headerlink" title="python字节码指令"></a>python字节码指令</h5><p>使用dis标准库来解析code对象，查看code对象里的字节码指令信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = open(<span class="string">"aa.py"</span>).read()</span><br><span class="line">co = compile(s, <span class="string">"aa.py"</span>, <span class="string">"exec"</span>)</span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(co)</span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>执行如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = open(<span class="string">"test.py"</span>).read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co = compile(s, <span class="string">"test.py"</span>, <span class="string">"exec"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(co)</span><br><span class="line"> <span class="number">18</span>    <span class="number">0</span> LOAD_CONST     <span class="number">0</span> (<span class="string">'\n@Time : 2018/1/11 09:17\n'</span>)  </span><br><span class="line">       <span class="number">2</span> STORE_NAME     <span class="number">0</span> (__doc__)</span><br><span class="line"> <span class="number">20</span>    <span class="number">4</span> SETUP_LOOP     <span class="number">28</span> (to <span class="number">34</span>)</span><br><span class="line">       <span class="number">6</span> LOAD_NAME      <span class="number">1</span> (range)</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure>

<p>其中的，最左边的一列表示的是在源文件中的行号，第二列显示当前的字节码指令的偏移位置，第三列显示的是当前字节码指令，最后一列显示的是当前字节码指令的参数</p>
<h4 id="2-python虚拟机框架"><a href="#2-python虚拟机框架" class="headerlink" title="2 python虚拟机框架"></a>2 python虚拟机框架</h4><p>python字节码虚拟机的执行原理：python的虚拟机会从编译得到的PyCodeObject对象中依次读取每一条字节码指令，并在当前的上下文环境中执行这条字节码指令。python虚拟机实际上是模拟操作系统运行可执行文件的过程，即函数栈帧执行原理（对一个函数而言所有的局部变量的操作都是在<code>自己的栈帧</code>中完成的，而函数之间的调用则通过<code>创建新的栈帧</code>来完成），从而完成了python字节码指令序列的执行。</p>
<p>举例说明执行过程，有如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">"Python"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">9999</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure>

<p>上述代码的执行过程，可以描述如下：在运行第一条表达式的时候，python已经建立了一个<code>执行环境A</code>，所有的字节码指令都会在这个函数中执行，python可以从这个环境中获取变量的值，也可以根据字节码的指令修改执行环境中某个变量的值，以影响后序字节码指令，这个过程会一直执行下去，直到发生了函数调用，当函数在执行环境中调用f的字节码指令时，会在当前环境之外重新创建一个新的执行环境B。这个执行环境就是PyFrameObject对象。</p>
<p>在python实际的执行中会产生很多的PyFrameObject对象，这些对象是被链接起来的，形成一条执行环境链表。</p>
<p>在python中访问PyFrameObject对象：python中的 fram Object是对python源码中PyFrameObject结构体的包装。可以通过sys模块中的_getframe方法来获得当前处于活动状态的frame object。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">value = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    frame = sys._getframe()</span><br><span class="line">    <span class="comment"># get current function name</span></span><br><span class="line">    print(<span class="string">"current function is "</span>, frame.f_code.co_name)</span><br><span class="line">    caller = frame.f_back</span><br><span class="line">    print(<span class="string">"caller function is "</span>, caller.f_code.co_name)</span><br><span class="line">    print(<span class="string">"caller's local namespace"</span>, caller.f_locals)</span><br><span class="line">    print(<span class="string">"caller's global namespace"</span>, caller.f_globals.keys())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    g()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    f()</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#39;current function is &#39;, &#39;g&#39;)</span><br><span class="line">(&#39;caller function is &#39;, &#39;f&#39;)</span><br><span class="line">(&quot;caller&#39;s local namespace&quot;, &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;)</span><br><span class="line">(&quot;caller&#39;s global namespace&quot;, [&#39;g&#39;, &#39;f&#39;, &#39;__builtins__&#39;, &#39;__file__&#39;, &#39;show&#39;, &#39;value&#39;, &#39;__package__&#39;, &#39;sys&#39;,&#39;__name__&#39;, &#39;__doc__&#39;])</span><br></pre></td></tr></table></figure>

<h4 id="3-python运行环境初始化"><a href="#3-python运行环境初始化" class="headerlink" title="3 python运行环境初始化"></a>3 python运行环境初始化</h4><h4 id="3-1-线程环境初始化"><a href="#3-1-线程环境初始化" class="headerlink" title="3.1 线程环境初始化"></a>3.1 线程环境初始化</h4><ul>
<li>在python启动的时候，会依次创建代表进程和线程的c结构体，并在他们之间建立联系;</li>
<li>之后，开始设置系统的module, 其中第一个被创建的module是<strong>buildin</strong> module</li>
<li>在某个名字空间中，找到某个符号所对应的对象</li>
</ul>
<blockquote>
<p>参考<br>《python源码剖析》</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>burpsuite使用</title>
    <url>/2019/03/17/burpsuite%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>burp</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql总结</title>
    <url>/2019/03/13/mysql%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1-mysql查询基础"><a href="#1-mysql查询基础" class="headerlink" title="1 mysql查询基础"></a>1 mysql查询基础</h2><h3 id="1-1-单个表的检索"><a href="#1-1-单个表的检索" class="headerlink" title="1.1 单个表的检索"></a>1.1 单个表的检索</h3><h4 id="列的选择"><a href="#列的选择" class="headerlink" title="列的选择"></a>列的选择</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column1_name, column2_name, ....</span><br><span class="line"><span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="行的选择"><a href="#行的选择" class="headerlink" title="行的选择"></a>行的选择</h4><p><strong>选择值不同的行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> column_name </span><br><span class="line"><span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>
<p><strong>限制行数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span>, <span class="number">5</span>; // 开始行和行数</span><br></pre></td></tr></table></figure>

<h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">desc</span>;  // 单个列排序降序，升序是默认的</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> column_name1 <span class="keyword">desc</span>, column_name2 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> column_name1=<span class="string">"cody"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> column_name1 <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="时间和日期处理"><a href="#时间和日期处理" class="headerlink" title="时间和日期处理"></a>时间和日期处理</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Year</span>(column_name) = <span class="number">2005</span> <span class="keyword">and</span> <span class="keyword">Month</span>(column_name) = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<h4 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">from table_name; // count(*)会计算null值，count(column_name)不会计算null值</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(column_name)</span><br><span class="line"><span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id, <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> vend_id;  // 分组</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> customer_id, <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">where</span> price &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> customer_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(*) &gt;= <span class="number">2</span>  // <span class="keyword">having</span>对分组进行过滤，<span class="keyword">where</span>对行进行过滤</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> customer_id</span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">where</span> order_num <span class="keyword">in</span> (<span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id=<span class="string">'TNT'</span>);  // 子查询由内向外执行</span><br></pre></td></tr></table></figure>

<h3 id="1-2-多个表的检索"><a href="#1-2-多个表的检索" class="headerlink" title="1.2 多个表的检索"></a>1.2 多个表的检索</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">from</span> vendors, products</span><br><span class="line">where vendors.vend_id = products.vend_id; // 不使用连接条件的表关系返回笛卡尔积，第一个表中的行数*第二个表中的行数</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">from</span> vendors <span class="keyword">inner</span> <span class="keyword">join</span> products <span class="keyword">on</span> vendor.id=products.vendor_id;  // 与上面的效果一样</span><br></pre></td></tr></table></figure>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>自己连接自己</p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> table_name1 <span class="keyword">left</span> <span class="keyword">join</span> table_name2</span><br><span class="line"><span class="keyword">on</span> table_name1.column_name = table_name2.column_name;</span><br></pre></td></tr></table></figure>


<h3 id="1-3-组合查询"><a href="#1-3-组合查询" class="headerlink" title="1.3 组合查询"></a>1.3 组合查询</h3><p>union查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column1, column2</span><br><span class="line"><span class="keyword">from</span> table_name1</span><br><span class="line"><span class="keyword">where</span> column1 &lt; <span class="number">10</span>;</span><br><span class="line">union</span><br><span class="line"><span class="keyword">select</span> column1, column2</span><br><span class="line"><span class="keyword">from</span> table_name1</span><br><span class="line"><span class="keyword">where</span> column2 = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>




<h3 id="1-4-创建表"><a href="#1-4-创建表" class="headerlink" title="1.4 创建表"></a>1.4 创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">    customer_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    customer_name <span class="built_in">char</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (customer_id)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure>

<h4 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name</span><br><span class="line"><span class="keyword">add</span> vend_phone <span class="built_in">char</span>(<span class="number">20</span>); // 添加一列</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> vend_phone; // 删除一列</span><br></pre></td></tr></table></figure>

<h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2 事务"></a>2 事务</h2><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3 索引"></a>3 索引</h2><p>根据键值，快速的找到数据。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>非叶子节点存放的是key， 叶子节点存放的是{key: data}.在B+树中，所有的记录节点都是按键值的大小，顺序存放在同一层的叶子节点上，由各叶子节点指针连接。在数据库中B+树的高度一般为2-4层。也就是说查找某一键值的行记录最多需要2到4次的IO。</p>
<h3 id="MyISAM索引"><a href="#MyISAM索引" class="headerlink" title="MyISAM索引"></a>MyISAM索引</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是<strong>数据记录的地址</strong>, 对于主索引和辅助索引都是如此。索引可以分为</p>
<ul>
<li>主索引: 主键对应的索引,要求key唯一</li>
<li>辅助索引：非主键对应的索引，key可以重复</li>
</ul>
<p>索引文件和行记录文件是分开的。</p>
<h3 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h3><p>InnoDB中的索引可以分为：</p>
<ul>
<li>聚集索引: 按照每张表的<strong>主键</strong>构造一颗B+树，同时叶子节点存放的是整张表的<strong>行记录数据</strong>。</li>
<li>辅助索引: 叶子节点不包含行记录的全部数据而是相应记录<strong>主键的值</strong>, 每张表上可以有多个辅助索引。当通过辅助索引来查找数据的时候，Innodb存储引擎会遍历辅助索引并通过叶子节点中的指针获取指向主键索引的主键，然后在通过主键索引来查找一个完整的记录。</li>
</ul>
<p>InnoDB中聚集索引文件和数据文件是同一个文件。数据文件本身就是要按照主键进行聚集，innodb要求表必须有主键，如果没有显示的指定，Innodb会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<h2 id="4-InnoDB引擎中的锁"><a href="#4-InnoDB引擎中的锁" class="headerlink" title="4 InnoDB引擎中的锁"></a>4 InnoDB引擎中的锁</h2><p><img src="mysql%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="MySQL数据存储的层次结构"></p>
<p>锁机制是用于管理对<strong>共享资源</strong>的并发访问。InnoDB会在行级别上对表数据上锁。</p>
<p>在InnoDB中的锁有: </p>
<ul>
<li>latch: 可以分为mutex和rwlock。其目的是用来保证并发线程操作临界资源的正确定。</li>
<li>lock: lock的对象是事务, 用来锁定的是数据库中的对象，如表、页、行<ul>
<li>共享锁(S lock): 行级锁，允许事务读一行数据. </li>
<li>排他锁(X lock): 行级锁, 允许事务删除或者更新一行数据</li>
</ul>
</li>
</ul>
<p><strong>一致性非锁定读</strong></p>
<ol>
<li>如果事务1和事务2可以同时获取同一行的共享锁。如果事务3想要获取该行的排它锁，需要等待事务1和事务2释放该行上的共享锁。</li>
<li>如果事务1得到了某一行上的排他锁，此时事务2想要获取该行的共享锁，这时事务2不会等待事务1释放在该行上的排它锁，而是会读取行的一个<strong>快照数据</strong>(所谓的快照数据，是指改行的之前版本的数据)，称为一致性的非锁定读。非锁读可以极大的提高数据库的并发性。</li>
</ol>
<p><strong>一致性的锁定读</strong></p>
<p>所谓的锁定读，就是事务1得到了某行的排它锁，此时事务2想要获取该行的共享锁读取该行数据，此时事务2需要等待在该行上的排它锁的释放。</p>
<p>InnoDB引擎对select语句支持两种一致性的锁定读：</p>
<ul>
<li>select….. for update; 对读取的行加一个x锁，其它的事务不能对锁定的行加任何锁。</li>
<li>select  …… lock in share mode; 对读取的行记录加一个s锁。其他事务可以对被锁定的行加s锁，但是如果加x锁，就会被阻塞。</li>
</ul>
<p><strong>自增长</strong></p>
<p>每个含有自增长值的表都有一个自增长计数器，当对这种表进行插入操作时，这个计数器会被初始化。在这里使用了一种特殊的表锁机制，锁不会在事务完成后才释放，而是完成对自增长值插入的sql语句后立即释放。</p>
<p>InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。</p>
<h2 id="5-架构"><a href="#5-架构" class="headerlink" title="5 架构"></a>5 架构</h2><p><img src="mysql%E6%9E%B6%E6%9E%84.png" alt="MySQL架构"></p>
<ul>
<li>最上层的连接服务，用于不同语言与SQL的交互。可以通过<code>show variables like &#39;%connections%&#39;</code>命令查看MySQL实例的最大连接数和单个用户的最大连接数。</li>
<li>第二层MySQL Server，大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存，所有跨存储引擎的功能都集中在这一层实现。<ul>
<li><strong>Management Services &amp; Utilities</strong>：系统管理和控制工具，备份和恢复的安全性，复制，集群，管理，配置，迁移和元数据。</li>
<li><strong>Connection Pool</strong>：连接池，进行身份验证、线程重用，连接限制，检查内存，数据缓存；管理用户的连接，线程处理等需要缓存的需求。</li>
<li><strong>SQL Interface</strong>：SQL 接口，进行 DML、DDL，存储过程、视图、触发器等操作和管理，用户通过 SQL 命令来查询所需结果。</li>
<li><strong>Parser</strong>：解析器；查询翻译对象的特权，SQL 命令传递到解析器的时候会被解析器验证和解析。</li>
<li><strong>Optimizer</strong>：查询优化器。</li>
<li><strong>Cache 和 Buffer</strong>：查询缓存，全局和引擎特定的缓存和缓冲区。</li>
</ul>
</li>
<li>第三层为存储引擎层，存储引擎负责MySQL中数据的存储和提取，服务器通过API于存储引擎进行通信。可以通过<code>SHOW ENGINES</code>命令查看各个存储引擎信息。</li>
</ul>
<h2 id="6-优化"><a href="#6-优化" class="headerlink" title="6 优化"></a>6 优化</h2><h3 id="库表结构优化"><a href="#库表结构优化" class="headerlink" title="库表结构优化"></a>库表结构优化</h3><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h2 id="7-高可用架构"><a href="#7-高可用架构" class="headerlink" title="7 高可用架构"></a>7 高可用架构</h2><h3 id="主从复制架构"><a href="#主从复制架构" class="headerlink" title="主从复制架构"></a>主从复制架构</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置</title>
    <url>/2019/03/10/nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-版本介绍"><a href="#1-版本介绍" class="headerlink" title="1 版本介绍"></a>1 版本介绍</h2><ul>
<li>开发版</li>
<li>稳定版</li>
<li>历史版</li>
</ul>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><ul>
<li>首先安装依赖包 <code>libpcre3</code>（解析正则的库） <code>libpcre3-dev</code> <code>zlib1g-dev</code></li>
<li>下载nginx包</li>
<li>安装nginx</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./config  生成makefiel</span><br><span class="line">make 编译文件</span><br><span class="line">make install 安装</span><br></pre></td></tr></table></figure>

<h2 id="3-功能"><a href="#3-功能" class="headerlink" title="3 功能"></a>3 功能</h2><h2 id="4-配置解读"><a href="#4-配置解读" class="headerlink" title="4 配置解读"></a>4 配置解读</h2><h2 id="5-nginx的日志类型"><a href="#5-nginx的日志类型" class="headerlink" title="5 nginx的日志类型"></a>5 nginx的日志类型</h2><ul>
<li>error.log</li>
<li>access.log</li>
</ul>
<h3 id="错误日志的配置"><a href="#错误日志的配置" class="headerlink" title="错误日志的配置"></a>错误日志的配置</h3><h3 id="nginx中有哪些变量"><a href="#nginx中有哪些变量" class="headerlink" title="nginx中有哪些变量"></a>nginx中有哪些变量</h3><ul>
<li><p>请求的变量</p>
</li>
<li><p>需求，我们想要记录用户的user-agent，应该怎么处理</p>
<ul>
<li>request的请求变量是http_请求头信息，如http_user_agent</li>
</ul>
</li>
<li><p>nginx -c -t config  检查配置文件的配置是否正确</p>
</li>
</ul>
<h2 id="不同场景下的配置"><a href="#不同场景下的配置" class="headerlink" title="不同场景下的配置"></a>不同场景下的配置</h2><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h3><ul>
<li>curl -v <a href="http://ww.baidu.com" target="_blank" rel="noopener">http://ww.baidu.com</a>  # 详细的查看每次的请求信息</li>
</ul>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
